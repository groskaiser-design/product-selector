<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>График веса</title>
  <style>
    :root {
      /* Переменные стиля графика */
      --line-width: 1;               /* толщина линии */
      --point-radius: 4;               /* радиус точек */

      --line-color: 255,255,255;       /* цвет линии (RGB) */
      --point-color: 245,158,11;       /* цвет точек (RGB) — как у кнопки "Сохранить" (#f59e0b) */

      --line-opacity: 0.7;            /* прозрачность линии */
      --point-opacity: 1;              /* прозрачность точек */

      --label-font-size: 14px;         /* подписи весов */
      --date-font-size: 8px;           /* подписи дат */
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #25275c 0%, #050714 55%, #02030a 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      color: #fff;
    }

    /* ===== График веса (чистый canvas-вид) ===== */
.weight-chart {
  width: 90%; /* Устанавливаем ширину графика на 100% */
  max-width: 90%; /* Чтобы не выходил за пределы экрана */
  padding: 10px 12px 12px;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.26);
  background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 18px 40px rgba(0,0,0,.55);
  position: relative;
  overflow: hidden;
}

.weight-chart-body svg {
  width: 90%; /* Устанавливаем SVG на 100% ширины */
  height: auto; /* Для сохранения пропорций */
  display: block;
}

   

    /* Линия веса */
    .weight-chart-body .wc-line {
      fill: none;
      stroke: rgba(var(--line-color), var(--line-opacity));
      stroke-width: var(--line-width);
      stroke-linejoin: round;
      stroke-linecap: round;
    }

    /* Точки */
    .weight-chart-body .wc-points circle {
      fill: rgba(var(--point-color), var(--point-opacity));
      stroke: rgba(0,0,0,.22);
      stroke-width: 1;
      r: var(--point-radius);
    }

    /* Подписи весов (каждой точки) */
    .weight-chart-body .wc-labels text {
      font-size: var(--label-font-size);
      fill: rgba(255,255,255,0.9);
    }

    /* Вертикальные линии от дат к точкам */
    .weight-chart-body .wc-date-lines line {
      stroke: rgba(255,255,255,0.18);
      stroke-width: 0.5;
    }

    /* Подписи дат снизу */
    .weight-chart-body .wc-date-labels text {
      font-size: var(--date-font-size);
      fill: rgba(255,255,255,0.78);
    }
  </style>
</head>
<body>
  <div class="weight-chart">
    <div class="weight-chart-body">
      <svg viewBox="0 0 300 140" aria-hidden="true" focusable="false">
        <!-- Трек графика -->
        <g class="wc-track">
          <!-- Линия веса -->
          <polyline class="wc-line" />

          <!-- Точки на линии -->
          <g class="wc-points"></g>

          <!-- Подписи весов -->
          <g class="wc-labels"></g>

          <!-- Вертикальные линии от дат к точкам -->
          <g class="wc-date-lines"></g>

          <!-- Подписи дат снизу -->
          <g class="wc-date-labels"></g>
        </g>
      </svg>
    </div>
  </div>

  <script>
    // Данные: 10 замеров веса (110 → 95)
    const weights = [110, 108, 106, 104, 102, 100, 99, 98, 96, 95];

    // Пример дат под те же замеры (можно подставить реальные)
    const dates = [
      '01.09', '04.09', '07.09', '10.09', '13.09',
      '16.09', '19.09', '22.09', '25.09', '28.09'
    ];

    const svg = document.querySelector('svg');
    const chart = document.querySelector('.weight-chart');
    const polyline = svg.querySelector('.wc-line');
    const pointsGroup = svg.querySelector('.wc-points');
    const labelsGroup = svg.querySelector('.wc-labels');
    const dateLinesGroup = svg.querySelector('.wc-date-lines');
    const dateLabelsGroup = svg.querySelector('.wc-date-labels');

    const width = 300;
    const height = 140;
    const paddingX = 10;
    const paddingTop = 16;
    const paddingBottom = 92; // верх точки по Y ~ [paddingTop..paddingBottom]

    const dateLineY = 112;    // низ вертикальной линии даты
    const dateLabelY = 130;   // базовая линия текста даты

    const maxW = Math.max.apply(null, weights);
    const minW = Math.min.apply(null, weights);

    const windowSize = 5;          // одновременно показываем 5 точек
    let offset = 0;                // стартовое окно: [0..4]

    function weightToY(w) {
      if (maxW === minW) return (paddingTop + paddingBottom) / 2;
      const t = (maxW - w) / (maxW - minW); // 0..1
      return paddingTop + t * (paddingBottom - paddingTop);
    }

    function renderChart() {
      const slice = weights.slice(offset, offset + windowSize);
      const dateSlice = dates.slice(offset, offset + windowSize);

      const n = slice.length;
      const stepX = (width - paddingX * 2) / (windowSize - 1 || 1); // фиксированный шаг по X

      const pts = [];
      const circles = [];
      const labels = [];
      const dateLines = [];
      const dateLabels = [];

      for (let i = 0; i < n; i++) {
        const x = paddingX + i * stepX;
        const y = weightToY(slice[i]);
        pts.push(x.toFixed(1) + ',' + y.toFixed(1));
        circles.push(`<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" />`);

        // подпись веса над каждой точкой
        const labelY = y - 8;
        labels.push(
          `<text x="${x.toFixed(1)}" y="${labelY.toFixed(1)}" text-anchor="middle">${slice[i]}</text>`
        );

        // линия от даты снизу к точке
        dateLines.push(
          `<line x1="${x.toFixed(1)}" y1="${y.toFixed(1)}" x2="${x.toFixed(1)}" y2="${dateLineY.toFixed(1)}" />`
        );

        // подпись даты внизу
        const dateText = dateSlice[i] || '';
        dateLabels.push(
          `<text x="${x.toFixed(1)}" y="${dateLabelY.toFixed(1)}" text-anchor="middle">${dateText}</text>`
        );
      }

      polyline.setAttribute('points', pts.join(' '));
      pointsGroup.innerHTML = circles.join('');
      labelsGroup.innerHTML = labels.join('');
      dateLinesGroup.innerHTML = dateLines.join('');
      dateLabelsGroup.innerHTML = dateLabels.join('');
    }

    function shiftWindow(dir) {
      const maxOffset = Math.max(0, weights.length - windowSize);
      const newOffset = Math.min(maxOffset, Math.max(0, offset + dir));
      if (newOffset === offset) return; // уже край, ничего не делаем
      offset = newOffset;
      renderChart();
    }

    // ===== Жесты: трекпад/колёсико, тач, мышь =====
    const swipeTarget = chart; // вся карточка — удобнее попадать
    const threshold = 30;      // порог для тач/мыши

    // 1) Тач-события (телефон/планшет)
    let touchStartX = null;

    swipeTarget.addEventListener('touchstart', (e) => {
      if (e.touches.length === 1) {
        touchStartX = e.touches[0].clientX;
      }
    }, { passive: true });

    swipeTarget.addEventListener('touchend', (e) => {
      if (touchStartX === null) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      if (dx > threshold) {
        // свайп вправо → листаем влево (к более ранним точкам)
        shiftWindow(-1);
      } else if (dx < -threshold) {
        // свайп влево → листаем вправо (к более поздним точкам)
        shiftWindow(1);
      }
      touchStartX = null;
    }, { passive: true });

    // 2) Мышь (лёгкий drag влево/вправо)
    let mouseStartX = null;

    swipeTarget.addEventListener('mousedown', (e) => {
      mouseStartX = e.clientX;
    });

    swipeTarget.addEventListener('mouseup', (e) => {
      if (mouseStartX === null) return;
      const dx = e.clientX - mouseStartX;
      if (dx > threshold) {
        shiftWindow(-1);
      } else if (dx < -threshold) {
        shiftWindow(1);
      }
      mouseStartX = null;
    });

    // 3) Трекпад / колёсико мыши
    // На трекпаде горизонтальный жест даёт wheel с deltaX, часто вместе с deltaY.
    swipeTarget.addEventListener('wheel', (e) => {
      // Если пользователь просто скроллит страницу вверх/вниз, не трогаем график.
      const absX = Math.abs(e.deltaX);
      const absY = Math.abs(e.deltaY);

      // Считаем, что это навигация по графику, только если горизонтальная компонента заметно больше вертикальной
      if (absX < absY || absX < 10) return;

      e.preventDefault();

      if (e.deltaX > 0) {
        // свайп влево (движение контента влево) → показываем более поздние точки
        shiftWindow(1);
      } else if (e.deltaX < 0) {
        // свайп вправо → показываем более ранние точки
        shiftWindow(-1);
      }
    }, { passive: false });

    // Первый рендер (масштаб по всему диапазону 110–95, не прыгает при скролле)
    renderChart();
  </script>
</body>
</html>
