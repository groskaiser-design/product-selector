<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>График веса</title>
  <style>
    :root {
      --line-width: 1.5;
      --point-radius: 4;
      --line-color: 255,255,255;
      --point-color: 245,158,11;
      --line-opacity: 0.95;
      --point-opacity: 1;
      --label-font-size: 10px;
      --date-font-size: 8px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #25275c 0%, #050714 55%, #02030a 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
      color: #fff;
    }

    .weight-chart {
      width: 100%;
      max-width: 600px;
      padding: 10px 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.26);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 18px 40px rgba(0,0,0,.55);
      position: relative;
      overflow: hidden;
    }

    .weight-chart-body {
      width: 100%;
      overflow: hidden;
    }

    .weight-chart-body svg {
      width: 100%;
      height: auto;
      display: block;
    }

    .weight-chart-body .wc-line {
      fill: none;
      stroke: rgba(var(--line-color), var(--line-opacity));
      stroke-width: var(--line-width);
      stroke-linejoin: round;
      stroke-linecap: round;
    }

    .weight-chart-body .wc-points circle {
      fill: rgba(var(--point-color), var(--point-opacity));
      stroke: rgba(0,0,0,.22);
      stroke-width: 1;
      r: var(--point-radius);
    }

    .weight-chart-body .wc-labels text {
      font-size: var(--label-font-size);
      fill: rgba(255,255,255,0.9);
    }

    .weight-chart-body .wc-date-lines line {
      stroke: rgba(255,255,255,0.18);
      stroke-width: 1;
    }

    .weight-chart-body .wc-date-labels text {
      font-size: var(--date-font-size);
      fill: rgba(255,255,255,0.78);
    }
  </style>
</head>
<body>
  <div class="weight-chart">
    <div class="weight-chart-body">
      <svg viewBox="0 0 600 160" aria-hidden="true" focusable="false">
        <g class="wc-track">
          <polyline class="wc-line" />
          <g class="wc-points"></g>
          <g class="wc-labels"></g>
          <g class="wc-date-lines"></g>
          <g class="wc-date-labels"></g>
        </g>
      </svg>
    </div>
  </div>

  <script>
    // Данные: 10 замеров веса (110 → 95)
    const weights = [110, 108, 106, 104, 102, 100, 99, 98, 96, 95];
    const dates = ['01.09', '04.09', '07.09', '10.09', '13.09', '16.09', '19.09', '22.09', '25.09', '28.09'];

    const svg = document.querySelector('svg');
    const chart = document.querySelector('.weight-chart');
    const polyline = svg.querySelector('.wc-line');
    const pointsGroup = svg.querySelector('.wc-points');
    const labelsGroup = svg.querySelector('.wc-labels');
    const dateLinesGroup = svg.querySelector('.wc-date-lines');
    const dateLabelsGroup = svg.querySelector('.wc-date-labels');

    const width = 600;
    const height = 160;
    const paddingX = 40;
    const paddingTop = 16;
    const paddingBottom = 92;

    const maxW = Math.max.apply(null, weights);
    const minW = Math.min.apply(null, weights);

    const windowSize = 5;
    let offset = 0;
    let startX = 0;
    let isDragging = false;

    function weightToY(w) {
      if (maxW === minW) return (paddingTop + paddingBottom) / 2;
      const t = (maxW - w) / (maxW - minW); // 0..1
      return paddingTop + t * (paddingBottom - paddingTop);
    }

    function renderChart() {
      const slice = weights.slice(offset, offset + windowSize);
      const dateSlice = dates.slice(offset, offset + windowSize);

      const n = slice.length;
      const stepX = (width - paddingX * 2) / (windowSize - 1 || 1);

      const pts = [];
      const circles = [];
      const labels = [];
      const dateLines = [];
      const dateLabels = [];

      for (let i = 0; i < n; i++) {
        const x = paddingX + i * stepX;
        const y = weightToY(slice[i]);
        pts.push(x.toFixed(1) + ',' + y.toFixed(1));
        circles.push(`<circle cx="${x.toFixed(1)}" cy="${y.toFixed(1)}" />`);

        const labelY = y - 8;
        labels.push(
          `<text x="${x.toFixed(1)}" y="${labelY.toFixed(1)}" text-anchor="middle">${slice[i]}</text>`
        );

        dateLines.push(
          `<line x1="${x.toFixed(1)}" y1="${y.toFixed(1)}" x2="${x.toFixed(1)}" y2="${paddingBottom}" />`
        );

        const dateText = dateSlice[i] || '';
        dateLabels.push(
          `<text x="${x.toFixed(1)}" y="${paddingBottom + 10}" text-anchor="middle">${dateText}</text>`
        );
      }

      polyline.setAttribute('points', pts.join(' '));
      pointsGroup.innerHTML = circles.join('');
      labelsGroup.innerHTML = labels.join('');
      dateLinesGroup.innerHTML = dateLines.join('');
      dateLabelsGroup.innerHTML = dateLabels.join('');
    }

    // Обработчик мыши и тача для плавного сдвига
    chart.addEventListener('mousedown', (e) => {
      isDragging = true;
      startX = e.clientX;
    });

    chart.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      chart.style.transform = `translateX(${dx}px)`;
    });

    chart.addEventListener('mouseup', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const moveThreshold = 100; // Порог для сдвига
      if (Math.abs(dx) > moveThreshold) {
        const shiftAmount = Math.sign(dx) * windowSize;
        offset = Math.max(0, Math.min(weights.length - windowSize, offset + shiftAmount));
        renderChart();
      }
      chart.style.transform = 'translateX(0)';
      isDragging = false;
    });

    // Рендеринг графика
    renderChart();
  </script>
</body>
</html>
