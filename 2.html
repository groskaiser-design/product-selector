<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>План vs Факт — диаграмма отклонений (мобайл)</title>
    <style>
      /* ===== Базовые переменные (минимально необходимые) ===== */
      :root{
        --font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
        --name-size: clamp(10px, 3.2vw, 16px);
        --name-weight: 400;
        --meta-size: clamp(10px, 3.2vw, 16px);
        --value-size: clamp(10px, 3.8vw, 16px);
        --value-weight: 800;
        --line-name: 1.25;

        --gauge-height: 28px;
        --plan-radius: 6px;
        --fact-radius: 3px;
        --fact-height: 50%;

        --text:#ffffff;
        --muted:rgba(255,255,255,.82);

        --fact-green:#22c55e;
        --fact-orange:#f59e0b;
        --fact-red:#ef4444;

        --plan-fill: rgba(255,255,255,.38);
        --plan-border: rgba(255,255,255,.52);

        --shadow:0 8px 24px rgba(27,35,78,.22);
        --page-grad-from:#7B6EF6;
        --page-grad-to:#6F7FF0;
        --outer-pad: clamp(12px, 4.5vw, 18px);
      }

      *{box-sizing:border-box}
      body{ margin:0; color:var(--text); font-family:var(--font-family); -webkit-font-smoothing:antialiased; min-height:100vh;
        background:linear-gradient(180deg,var(--page-grad-from) 0%,var(--page-grad-to) 100%); background-attachment:fixed; }
      .page{ padding: var(--outer-pad); padding-left: max(var(--outer-pad), env(safe-area-inset-left)); padding-right: max(var(--outer-pad), env(safe-area-inset-right)); padding-top: max(var(--outer-pad), env(safe-area-inset-top)); padding-bottom: max(var(--outer-pad), env(safe-area-inset-bottom)); }

      .card{ max-width:680px; margin:clamp(8px,4vw,20px) auto; padding:12px; border-radius:20px;
        background:linear-gradient(180deg,rgba(255,255,255,.22) 0%,rgba(255,255,255,.14) 100%);
        backdrop-filter:blur(22px) saturate(1.35);
        border:1.5px solid rgba(255,255,255,.45);
        box-shadow:var(--shadow); }

      /* Контейнер со скроллом: показываем 5 строк, остальное прокручивается */
      .scroller{ position:relative; overflow:auto; -webkit-overflow-scrolling:touch; overscroll-behavior:contain; scroll-snap-type:y proximity; scroll-behavior:smooth; border-radius:16px }

      /* Подсказка-стрелка для вертикального скролла */
      .scroll-hint{ position:relative; margin:10px auto 0; opacity:.65; pointer-events:none; transition:opacity .2s ease; width:18px; height:18px }
      .scroll-hint.hidden{ opacity:0; visibility:hidden }
      .scroll-hint svg{ display:block; width:18px; height:18px; filter:drop-shadow(0 1px 2px rgba(0,0,0,.25)); animation:hint-bounce 1.2s infinite }
      .scroll-hint svg.up{ rotate:180deg; animation-name:hint-bounce-up }
      @keyframes hint-bounce{0%,100%{translate:0 0}50%{translate:0 4px}}
      @keyframes hint-bounce-up{0%,100%{translate:0 0}50%{translate:0 -4px}}
      @media (prefers-reduced-motion:reduce){ .scroll-hint svg{ animation:none } }

      .list{ display:flex; flex-direction:column; gap:0; padding:8px 10px; border-radius:16px; overflow:hidden;
        background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.06)); border:1px solid rgba(255,255,255,.30); }
      .row{ display:flex; flex-direction:column; gap:8px; padding:10px 4px; scroll-snap-align:start }
      .row+.row{ border-top:1px solid rgba(255,255,255,.22); margin-top:8px; padding-top:16px }

      .top{ display:flex; align-items:baseline; justify-content:flex-start; gap:10px; flex-wrap:wrap }
      .name{ font-size: var(--name-size); font-weight: var(--name-weight); line-height: var(--line-name) }
      .vals{ display:flex; flex-wrap:wrap; gap:4px; font-size:var(--meta-size); line-height:1.25 }
      .vals .kv{ display:inline-flex; align-items:baseline; gap:2px }
      .vals .lab{ color:var(--muted); margin-right:2px }
      .vals .val{ font-weight: var(--value-weight); font-size: var(--value-size) }
      .dot{ color:var(--muted); margin:0 2px }

      .gauge{ position:relative; height:var(--gauge-height); border-radius:var(--plan-radius) }
      .plan{ position:absolute; inset:0 auto 0 0; width:var(--wp,0%); border-radius:var(--plan-radius);
        background:var(--plan-fill); border:1px solid var(--plan-border); box-shadow:inset 0 -1px 0 rgba(255,255,255,.18); z-index:1 }
      .fact{ position:absolute; left:0; top:50%; transform:translateY(-50%); height:var(--fact-height); width:var(--wf,0%);
        min-width:6px; border-radius:var(--fact-radius); border:1px solid rgba(255,255,255,.95);
        background: var(--fact-green);
        box-shadow:inset 0 -1px 0 rgba(255,255,255,.16),0 10px 24px -14px rgba(9,25,52,.55);
        transform-origin:left center; transition:width .22s ease; z-index:2 }
      .fact.orange{ background: var(--fact-orange); }
      .fact.red{ background: var(--fact-red); }
      @supports (background: color-mix(in oklab, white 50%, black)){
        .fact{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%), color-mix(in oklab,var(--fact-green) 88%, transparent); }
        .fact.orange{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%), color-mix(in oklab,var(--fact-orange) 88%, transparent); }
        .fact.red{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%), color-mix(in oklab,var(--fact-red) 88%, transparent); }
      }
      .fact.neutral{ background: rgba(255,255,255,.08); border-color: rgba(255,255,255,.6); box-shadow: inset 0 -1px 0 rgba(255,255,255,.12); }

      /* === Timeline (горизонтальное колесо) === */
      .timeline{ position:relative; display:flex; align-items:center; gap:10px; padding:10px 8px 6px }
      .timeline[hidden]{ display:none !important }
      .wheel{ position:relative; flex:1; display:flex; align-items:center; gap:8px; overflow-x:auto; overflow-y:hidden; scroll-snap-type:x mandatory; -webkit-overflow-scrolling:touch; padding:10px 8px; border-radius:14px }
      .wheel{ scrollbar-width:none }
      .wheel::-webkit-scrollbar{ display:none }
      .wheel .item{ flex:0 0 auto; min-width:76px; padding:8px 12px; margin:0 4px; display:flex; align-items:center; justify-content:center; text-align:center; opacity:.6; border-radius:14px; border:1px solid rgba(255,255,255,.25); background:rgba(255,255,255,.08); scroll-snap-align:center; font-size:clamp(12px,3.3vw,14px); font-weight:700; letter-spacing:.2px; color:var(--text); user-select:none; transition:opacity .18s ease, transform .18s ease, box-shadow .18s ease; line-height:1.2 }
      .wheel .item.active{ opacity:1; background:rgba(255,255,255,.18); border-color:rgba(255,255,255,.45); box-shadow:0 6px 20px rgba(27,35,78,.18); transform:scale(1.02) }
      .wheel .spacer{ flex:0 0 var(--edge,0px); height:1px; padding:0; margin:0; border:0; background:transparent }

      /* Маска стеклянной подложки под активной датой */
      .wheel-mask{ pointer-events:none; position:absolute; inset:0 }
      .wheel-mask::before{
        content:""; position:absolute;
        left:var(--mask-left,50%); top:var(--mask-top,50%);
        width:var(--mask-w,min(70%,260px)); height:var(--mask-h,44px);
        border-radius:16px;
        border:1.5px solid rgba(255,255,255,.35);
        background:rgba(255,255,255,.08);
        box-shadow:inset 0 -1px 0 rgba(255,255,255,.16),0 8px 24px rgba(27,35,78,.12);
        box-sizing:border-box;
      }

      /* Custom thin scrollbar for .scroller (WebKit + Firefox) */
      .scroller{ scrollbar-width: thin; scrollbar-color: rgba(255,255,255,.35) transparent; }
      .scroller::-webkit-scrollbar{ width: 8px; height: 8px; }
      .scroller::-webkit-scrollbar-track{ background: transparent; }
      .scroller::-webkit-scrollbar-thumb{ background-color: rgba(255,255,255,.35); border-radius: 8px; border: 2px solid transparent; background-clip: content-box; }
      .scroller:hover::-webkit-scrollbar-thumb{ background-color: rgba(255,255,255,.55); }
      .scroller::-webkit-scrollbar-corner{ background: transparent; }

      /* Делаем верх блока из двух строк: 1) название, 2) Факт/План/∆ */
      #pfHApp .top{
        align-items: flex-start;
        flex-wrap: wrap;
        gap: 4px 0;
      }

      #pfHApp .top .name{
        flex: 1 0 100%;
        display: block;
      }

      #pfHApp .top .vals{
        gap: 6px;
        margin-top: 0;
      }

      /* Индикатор загрузки */
      .loading{
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: var(--muted);
      }
      .error{
        text-align: center;
        padding: 20px;
        font-size: 14px;
        color: var(--fact-red);
      }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="card" id="pfHApp" role="region" aria-label="План против факта — диаграмма отклонений">
        <div class="loading" id="loading">Загрузка данных...</div>
        <div class="scroller" id="scroller" style="display:none;">
          <div class="list" id="rows"></div>
        </div>
        <div class="scroll-hint" id="scrollHint" aria-hidden="true" style="display:none;">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6 9l6 6 6-6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
        <div class="timeline" id="timeline" hidden>
          <div class="wheel" id="dateWheel" tabindex="0" aria-label="Выбор даты" role="listbox"></div>
          <div class="wheel-mask" aria-hidden="true"></div>
        </div>
      </div>
    </div>

    <script>
      // ============================================================================
      // КОНФИГУРАЦИЯ БЭКЭНДА
      // ============================================================================
      const BACKEND_CONFIG = {
        // URL вашего Google Apps Script Web App
        url: 'https://script.google.com/macros/s/AKfycbxuUU5TviXa02gCyKkEy_cKjeyC_fgwR9XPu01qLwdCkltT0kPAQjLplKccJg-gZhrYDw/exec',
        
        // Telegram Init Data (получаем из Telegram WebApp)
        getInitData: function() {
          if (typeof window.Telegram !== 'undefined' && window.Telegram.WebApp) {
            return window.Telegram.WebApp.initData || '';
          }
          return '';
        }
      };

      // ============================================================================
      // ЗАГРУЗКА ДАННЫХ С БЭКЭНДА
      // ============================================================================
      async function loadDataFromBackend() {
        try {
          const initData = BACKEND_CONFIG.getInitData();
          
          const response = await fetch(BACKEND_CONFIG.url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              action: 'front_bootstrap',
              init_data: initData
            })
          });

          if (!response.ok) {
            throw new Error('Ошибка загрузки: ' + response.status);
          }

          const data = await response.json();
          
          if (!data.ok) {
            throw new Error(data.error || 'Неизвестная ошибка');
          }

          // Данные из столбца CE (macros_json)
          let seriesData = null;
          if (data.macros_json) {
            try {
              // Парсим JSON с учетом десятичной запятой
              const normalizedJson = data.macros_json.replace(/([0-9]),([0-9])/g, '$1.$2');
              seriesData = JSON.parse(normalizedJson);
            } catch (e) {
              console.error('Ошибка парсинга macros_json:', e);
            }
          }

          return seriesData;
        } catch (error) {
          console.error('Ошибка загрузки данных:', error);
          throw error;
        }
      }

      // ============================================================================
      // ОСНОВНОЙ КОД ГРАФИКА (из оригинального файла)
      // ============================================================================
      (function(){
        const LABELS = { fat:'% Жира', neck:'Шея', shoulders:'Плечи', chest:'Грудь', waist:'Талия', hips:'Ягодицы', thigh:'Бедро', calf:'Икра', bicep:'Бицепс' };
        const ORDER = ['fat','neck','shoulders','chest','waist','hips','thigh','calf','bicep'];

        function round(n,d){ if(!isFinite(n)) return '—'; var p=Math.pow(10,d||0); return Math.round(n*p)/p; }

        function toRows(json){
          var rows=[]; if(!json) return rows;
          for(var i=0;i<ORDER.length;i++){
            var key = ORDER[i];
            var it = json[key];
            if(!it) continue;
            var unit = it.unit || (key==='fat' ? '%' : 'см');
            var planRaw = (it.plan != null ? it.plan : it.target);
            var factRaw = (it.fact != null ? it.fact : it.actual);
            var plan = Number(planRaw);
            var fact = Number(factRaw);
            if(!isFinite(plan) || !isFinite(fact)) continue;
            var delta = (it.hasOwnProperty('delta') && isFinite(Number(it.delta))) ? Number(it.delta) : null;
            rows.push({ key: key, label: (LABELS[key]||key), unit: unit, target: plan, actual: fact, delta: delta });
          }
          return rows;
        }

        function render(el, initialData){
          var state = { data: initialData };
          var rowsEl = el.querySelector('#rows');
          var scroller = el.querySelector('#scroller');
          var hint = el.querySelector('#scrollHint');
          if(!rowsEl || !scroller){ return { setData: function(_){} }; }

          var lastScrollTop = scroller.scrollTop || 0;
          var lastDirUp = false;

          function buildDomains(list){
            var cmMax = 0; for(var i=0;i<list.length;i++){ var d=list[i]; var u=(d.unit||'').trim(); if(u!=='%') cmMax=Math.max(cmMax, (d.target||0), (d.actual||0)); }
            return { '%':100, 'см':cmMax||1, 'cm':cmMax||1 };
          }

          function draw(){
            var data = state.data || []; var maxByUnit = buildDomains(data); rowsEl.innerHTML='';
            for(var i=0;i<data.length;i++){
              var d = data[i]; var delta = (isFinite(d.delta) ? d.delta : null); var unitMax = maxByUnit[(d.unit||'').trim()] || 1;
              var wp = Math.max(0, Math.min(100, ((d.target||0)/unitMax)*100));
              var wf = Math.max(0, Math.min(100, ((d.actual||0)/unitMax)*100));

              var row = document.createElement('div'); row.className='row';
              var top = document.createElement('div'); top.className='top';
              top.innerHTML = '<span class="name">'+(d.key==='fat' ? (LABELS[d.key]||d.label) : (d.label+' ('+d.unit+')'))+'</span>'+
                '<span class="vals">'+
                  '<span class="kv"><span class="lab">Факт:</span> <b class="val">'+round(d.actual,1)+'</b></span>'+
                  '<span class="dot">•</span>'+
                  '<span class="kv"><span class="lab">План:</span> <b class="val">'+round(d.target,1)+'</b></span>'+
                  '<span class="dot">•</span>'+
                  '<span class="kv"><span class="lab">∆:</span> <b class="val">'+fmtDeltaNoUnit(delta)+(isFinite(delta)?(delta>0?' ▲':(delta<0?' ▼':'')):'')+'</b></span>'+
                '</span>';

              var g = document.createElement('div'); g.className='gauge';
              var plan = document.createElement('div'); plan.className='plan'; plan.style.setProperty('--wp', wp+'%');
              var fact = document.createElement('div'); fact.className='fact'; fact.style.setProperty('--wf', wf+'%');

              if (isFinite(delta)) {
                if (d.key === 'fat' || d.key === 'waist') { if (d.actual > d.target) fact.classList.add('red'); }
                else { if (d.actual < d.target) fact.classList.add('orange'); }
              } else { fact.classList.add('neutral'); }

              g.appendChild(plan); g.appendChild(fact); row.appendChild(top); row.appendChild(g);
              rowsEl.appendChild(row);
            }
            limitToRows(5);
            updateHint();
          }

          function limitToRows(n){
            var items = rowsEl.children; var rows=[]; for(var i=0;i<items.length;i++){ if(items[i].classList && items[i].classList.contains('row')) rows.push(items[i]); }
            if(!rows.length) return; var csList = getComputedStyle(rowsEl); var maxH = parseFloat(csList.paddingTop) + parseFloat(csList.paddingBottom);
            for(var i=0;i<Math.min(n,rows.length);i++){ var r=rows[i]; var cs=getComputedStyle(r); maxH += r.offsetHeight + parseFloat(cs.marginTop||0) + parseFloat(cs.marginBottom||0); }
            maxH += 2; scroller.style.maxHeight = Math.ceil(maxH) + 'px';
          }

          function updateHint(){
            if(!hint) return;
            var hasMore = (scroller.scrollHeight - scroller.clientHeight) > 2;
            hint.classList.toggle('hidden', !hasMore);
            if(!hasMore) return;

            var st = scroller.scrollTop;
            if (Math.abs(st - lastScrollTop) > 0.5) {
              lastDirUp = st < lastScrollTop;
            }
            lastScrollTop = st;

            var nearTop = st <= 1;
            var nearBottom = Math.ceil(st + scroller.clientHeight) >= scroller.scrollHeight - 2;

            var showUp = false;
            if (nearTop && !nearBottom) showUp = false;
            else if (nearBottom && !nearTop) showUp = true;
            else showUp = lastDirUp;

            var svg = hint.querySelector('svg');
            if(svg){ svg.classList.toggle('up', showUp); }
          }

          function fmtDeltaNoUnit(n){ if(!isFinite(n)) return '—'; var s=n>0?'+':''; return s+round(n,1); }

          draw();
          scroller.addEventListener('scroll', updateHint, { passive:true });
          window.addEventListener('resize', function(){ limitToRows(5); updateHint(); }, { passive:true });

          return { setData:function(payload){ state.data = Array.isArray(payload) ? payload : toRows(payload); draw(); } };
        }

        function normalizeSeries(input){
          if(!input) return { dates:[], rows:[] };
          var seriesMap = null;
          if (input.series && typeof input.series === 'object' && !Array.isArray(input.series)) {
            seriesMap = input.series;
          } else if (Array.isArray(input) && input.length && input[0] && typeof input[0] === 'object' && ('date' in input[0])) {
            seriesMap = {}; for (var i=0;i<input.length;i++){ var it=input[i]; if(!it) continue; var k=String(it.date||i); seriesMap[k] = it.data || it.snapshot || {}; }
          } else {
            return { dates:['—'], rows:[ toRows(input) ] };
          }
          var dates = Object.keys(seriesMap);
          dates.sort(function(a,b){ var da=new Date(a), db=new Date(b); if(isFinite(da.getTime()) && isFinite(db.getTime())) return da-db; return (a>b?1:-1); });
          var rows = []; for(var j=0;j<dates.length;j++){ rows.push( toRows(seriesMap[dates[j]]||{}) ); }
          return { dates:dates, rows:rows };
        }

        function formatDateRu(s){ var d=new Date(s); if(!isFinite(d.getTime())) return s; try{ return d.toLocaleDateString('ru-RU',{year:'numeric',month:'short',day:'2-digit'}); }catch(_){ return s; } }

        function setupTimeline(norm, api){
          const tl = document.getElementById('timeline');
          const wheel = document.getElementById('dateWheel');
          const maskEl = tl ? tl.querySelector('.wheel-mask') : null;
          if(!tl || !wheel) return;

          const n = (norm && Array.isArray(norm.rows)) ? norm.rows.length : 0;
          if(n <= 1){ tl.hidden = true; return; }

          tl.hidden = false; wheel.innerHTML = '';
          const items = new Array(n);

          function syncMask(){
            if(!maskEl) return;
            const el = items[Math.max(0, active)] || items[0];
            if(!el) return;
            const rect = el.getBoundingClientRect();
            const wr = wheel.getBoundingClientRect();
            const pr = tl.getBoundingClientRect();
            const padX = 8, padY = 8;
            const scale = 1.5;
            const w = Math.round(rect.width * scale + padX*2);
            const h = Math.round(rect.height + padY*2);
            const centerX = wr.left + wr.width/2;
            const left = Math.round(centerX - w/2 - pr.left);
            const top  = Math.round((wr.top - pr.top) + (wr.height - h)/2);
            maskEl.style.setProperty('--mask-left', left + 'px');
            maskEl.style.setProperty('--mask-top',  top  + 'px');
            maskEl.style.setProperty('--mask-w',    w    + 'px');
            maskEl.style.setProperty('--mask-h',    h    + 'px');
          }
          for(let i=0;i<n;i++){
            const label = formatDateRu(norm.dates[i]||String(i));
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'item';
            btn.setAttribute('role','option');
            btn.setAttribute('aria-selected','false');
            btn.dataset.idx = String(i);
            btn.textContent = label;
            btn.addEventListener('click', function(){ centerTo(Number(this.dataset.idx), true, 'smooth'); });
            wheel.appendChild(btn);
            items[i] = btn;
          }

          function ensureSpacers(){
            const olds = wheel.querySelectorAll('.spacer'); olds.forEach(x=>x.remove());
            const left = document.createElement('div'); left.className='spacer'; left.setAttribute('aria-hidden','true');
            const right = document.createElement('div'); right.className='spacer'; right.setAttribute('aria-hidden','true');
            wheel.prepend(left); wheel.appendChild(right); resizeSpacers();
          }
          function resizeSpacers(){ const edge = Math.max(0, Math.floor(wheel.clientWidth/2)); wheel.style.setProperty('--edge', edge+'px'); }
          ensureSpacers();

          let active = -1, rafId = 0, snapTimer = 0;
          function setAria(){ for(let k=0;k<items.length;k++){ if(!items[k]) continue; items[k].setAttribute('aria-selected', String(k===active)); items[k].setAttribute('tabindex', k===active? '0':'-1'); } }
          function activate(i, announce){
            if(i === active || i < 0 || i >= n) return;
            if(items[active]){ items[active].classList.remove('active'); items[active].setAttribute('aria-selected','false'); }
            active = i;
            if(items[active]){ items[active].classList.add('active'); items[active].setAttribute('aria-selected','true'); }
            setAria();
            api && api.setData(norm.rows[i]||[]);
            syncMask();
          }
          function centerTo(i, announce, behavior){
            i = Math.max(0, Math.min(n-1, i)); const el = items[i]; if(!el) return;
            const target = el.offsetLeft + el.offsetWidth/2 - wheel.clientWidth/2;
            wheel.scrollTo({ left: Math.max(0, target), behavior: (behavior||'auto') });
            activate(i, announce);
            syncMask();
          }
          function onScroll(){
            if(rafId) cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(function(){
              const center = wheel.scrollLeft + wheel.clientWidth/2;
              let best = -1, bestDist = 1e12;
              for(let k=0;k<n;k++){
                const el = items[k]; const c = el.offsetLeft + el.offsetWidth/2; const d = Math.abs(c - center);
                if(d < bestDist){ bestDist = d; best = k; }
              }
              const changed = best !== active;
              activate(best, changed);
              syncMask();
              if(snapTimer) clearTimeout(snapTimer);
              snapTimer = setTimeout(function(){
                const el = items[active]; if(!el) return;
                const target = el.offsetLeft + el.offsetWidth/2 - wheel.clientWidth/2;
                const curCenter = wheel.scrollLeft + wheel.clientWidth/2;
                if(Math.abs(curCenter - (el.offsetLeft + el.offsetWidth/2)) > 3){
                  wheel.scrollTo({ left: Math.max(0, target), behavior: 'auto' });
                }
              }, 140);
            });
          }

          wheel.addEventListener('scroll', onScroll, { passive:true });
          wheel.addEventListener('wheel', function(e){ if(Math.abs(e.deltaY) > Math.abs(e.deltaX)){ e.preventDefault(); wheel.scrollLeft += e.deltaY; } }, { passive:false });
          wheel.addEventListener('keydown', function(e){ if(e.key==='ArrowLeft'){ e.preventDefault(); centerTo(active-1, true, 'smooth'); } else if(e.key==='ArrowRight'){ e.preventDefault(); centerTo(active+1, true, 'smooth'); } });
          window.addEventListener('resize', function(){ resizeSpacers(); centerTo(active, false, 'auto'); syncMask(); }, { passive:true });

          centerTo(n-1, false, 'auto');
          syncMask();
        }

        // ============================================================================
        // ИНИЦИАЛИЗАЦИЯ С ЗАГРУЗКОЙ ДАННЫХ
        // ============================================================================
        const container = document.getElementById('pfHApp');
        const loading = document.getElementById('loading');
        const scroller = document.getElementById('scroller');
        const hint = document.getElementById('scrollHint');
        
        let api = null;

        // Загружаем данные с бэкэнда
        loadDataFromBackend()
          .then(function(seriesData) {
            // Скрываем индикатор загрузки
            loading.style.display = 'none';
            scroller.style.display = 'block';
            hint.style.display = 'block';

            // Нормализуем данные
            const norm = normalizeSeries(seriesData || {});
            
            // Инициализируем график
            if (norm.rows.length > 0) {
              const lastData = norm.rows[norm.rows.length - 1] || [];
              api = render(container, lastData);
              
              // Настраиваем временную шкалу если есть несколько дат
              if (norm.rows.length > 1) {
                setupTimeline(norm, api);
              }
            } else {
              loading.textContent = 'Нет данных для отображения';
              loading.style.display = 'block';
            }

            // Экспортируем API для внешнего использования
            if (typeof window !== 'undefined') {
              window.PlanFactChart = {
                setData: function(json) {
                  if (api) api.setData(json);
                },
                setSeries: function(json) {
                  const nrm = normalizeSeries(json || {});
                  if (api) {
                    const l = nrm.rows[nrm.rows.length - 1] || [];
                    api.setData(l);
                  }
                  setupTimeline(nrm, api);
                }
              };
            }
          })
          .catch(function(error) {
            loading.className = 'error';
            loading.textContent = 'Ошибка загрузки данных: ' + error.message;
            console.error('Ошибка:', error);
          });
      })();

      // ============================================================================
      // HAPTIC FEEDBACK ДЛЯ TELEGRAM
      // ============================================================================
      (function () {
        var root = document.getElementById('dateWheel') || document.body;
        var scroller = document.querySelector('div.TabList.no-scrollbar') || root;

        if (!scroller) return;

        var touching = false, lastTick = 0, stopTimer = 0;
        var TICK_EVERY = 180;
        var STOP_DELAY = 160;

        function tick(){
          window.Telegram?.WebApp?.HapticFeedback?.selectionChanged?.();
        }
        function bump(){
          var h = window.Telegram?.WebApp?.HapticFeedback;
          if (h?.impactOccurred) h.impactOccurred('medium');
          else h?.notificationOccurred?.('success');
        }

        root.addEventListener('touchstart', function(){ touching = true;  clearTimeout(stopTimer); }, {passive:true});
        root.addEventListener('touchend',   function(){ touching = false;                            }, {passive:true});
        root.addEventListener('touchcancel',function(){ touching = false;                            }, {passive:true});

        scroller.addEventListener('scroll', function(){
          if (!touching) return;
          var now = (performance && performance.now) ? performance.now() : Date.now();
          if (now - lastTick >= TICK_EVERY) { lastTick = now; tick(); }
          clearTimeout(stopTimer);
          stopTimer = setTimeout(bump, STOP_DELAY);
        }, {passive:true});

        root.addEventListener('click', function(e){
          if (e.target.closest && e.target.closest('.item')) tick();
        }, {passive:true});
      })();
    </script>
  </body>
</html>
