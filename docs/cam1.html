<!DOCTYPE html>
<html lang="ru">
<head>
<script src="version-control.js?t=1"></script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Ultima FoodCam</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root {
    --bg-core: #000000;
    --surface-glass: rgba(28, 28, 30, 0.65);
    --acc-green: #30d158;
    --acc-red: #ff453a;
    --acc-orange: #ff9f0a;
    --acc-blue: #0a84ff;
    --text-main: #ffffff;
    --font-stack: -apple-system, BlinkMacSystemFont, 'SF Pro Text', Roboto, sans-serif;
    --safe-bottom: calc(12px + env(safe-area-inset-bottom));
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  body {
    margin: 0; padding: 0;
    background: var(--bg-core);
    color: var(--text-main);
    font-family: var(--font-stack);
    height: 100vh; overflow: hidden;
    display: flex; flex-direction: column;
    overscroll-behavior-y: none;
  }

  /* === ICONS (SVG) === */
  .icon-svg {
    width: 24px; height: 24px;
    fill: currentColor;
    display: block;
  }

  /* === VIEWPORT === */
  .cam-viewport {
    position: relative;
    flex: 1;
    width: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
  }

  video {
    position: absolute;
    width: 100%; height: 100%;
    object-fit: cover; 
    z-index: 1;
    opacity: 0; /* –°–∫—Ä—ã—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
    transition: opacity 0.3s;
  }
  video.active { opacity: 1; }

  /* === PRELOADER (SPINNER) === */
  .cam-loader {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }
  .spinner {
    width: 40px; height: 40px;
    border: 4px solid rgba(255,255,255,0.3);
    border-top: 4px solid #fff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

  #uiCanvas {
    position: absolute; inset: 0;
    width: 100%; height: 100%;
    z-index: 10; pointer-events: none;
  }

  .ui-layer {
    position: absolute; inset: 0; z-index: 20;
    display: flex; flex-direction: column;
    justify-content: space-between;
    padding: calc(16px + env(safe-area-inset-top)) 16px calc(32px + env(safe-area-inset-bottom)) 16px;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }
  
  /* –°–∫—Ä—ã–≤–∞–µ–º —Å–ª–æ–π —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π, –∫–æ–≥–¥–∞ –∞–∫—Ç–∏–≤–Ω–æ –º–µ–Ω—é */
  .ui-layer.idle { opacity: 0; pointer-events: none; }

  /* === TOP BAR === */
  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: center; 
    pointer-events: auto;
    height: 48px;
  }

  .btn-close {
    width: 40px; height: 40px;
    border-radius: 50%;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
    color: #fff; cursor: pointer;
    border: 1px solid rgba(255,255,255,0.1);
  }

  .status-chip {
    background: rgba(0,0,0,0.4);
    border: 1px solid rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    padding: 8px 16px;
    border-radius: 20px;
    display: flex; align-items: center; gap: 8px;
    font-size: 13px; font-weight: 600;
  }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--acc-orange); box-shadow: 0 0 8px var(--acc-orange); transition: 0.3s; }
  .status-dot.ok { background: var(--acc-green); box-shadow: 0 0 8px var(--acc-green); }

  .spacer { width: 40px; }

  /* === BOTTOM GRID CONTROLS === */
  .controls-grid {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    align-items: center;
    pointer-events: auto;
    width: 100%;
    margin-bottom: 10px;
  }

  .grid-cell-left { display: flex; justify-content: flex-start; }
  .grid-cell-center { display: flex; justify-content: center; }
  .grid-cell-right { display: flex; justify-content: flex-end; }

  .action-btn {
    width: 56px; height: 56px;
    border-radius: 50%;
    background: rgba(30,30,30,0.6);
    backdrop-filter: blur(12px);
    display: flex; align-items: center; justify-content: center;
    color: #fff;
    border: 1px solid rgba(255,255,255,0.15);
    cursor: pointer;
    transition: transform 0.15s, background 0.2s;
  }
  .action-btn:active { transform: scale(0.92); background: rgba(60,60,60,0.8); }
  .action-btn.hidden { opacity: 0; pointer-events: none; }
  .action-btn.disabled { opacity: 0.5; pointer-events: none; }

  .shutter-outer {
    width: 80px; height: 80px;
    border-radius: 50%;
    border: 4px solid rgba(255,255,255,0.8);
    display:flex; align-items:center; justify-content:center;
    transition: 0.3s;
    background: transparent;
  }
  .shutter-inner {
    width: 62px; height: 62px;
    border-radius: 50%;
    background: #fff;
    transition: 0.3s;
    cursor: pointer;
  }
  .shutter-outer.disabled { border-color: rgba(255, 69, 58, 0.5); }
  .shutter-outer.disabled .shutter-inner { background: var(--acc-red); transform: scale(0.4); opacity: 0.8; }
  .shutter-outer.active { border-color: var(--acc-green); transform: scale(1.05); }
  .shutter-outer:active:not(.disabled) .shutter-inner { transform: scale(0.9); }

  /* === TOAST === */
  .cam-toast {
    position: absolute;
    top: 100px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 8px 16px;
    border-radius: 20px;
    font-size: 13px;
    font-weight: 500;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: 50;
    backdrop-filter: blur(4px);
  }
  .cam-toast.visible { opacity: 1; }

  /* === OMNI BAR (NEW MENU) === */
  .omni-bar { 
    position: absolute; 
    bottom: 0; left: 0; right: 0; 
    background: rgba(10, 10, 10, 0.85); 
    backdrop-filter: blur(30px); -webkit-backdrop-filter: blur(30px);
    border-top: 1px solid rgba(255, 255, 255, 0.1); 
    padding: 8px 12px var(--safe-bottom) 12px; 
    z-index: 100; 
    display: flex; align-items: flex-end; gap: 10px; 
    transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  }
  .omni-bar.hidden { transform: translateY(100%); }

  .omni-icon-btn { 
    width: 40px; height: 40px; 
    display: flex; align-items: center; justify-content: center; 
    color: #fff; cursor: pointer; 
  }
  .input-wrap { 
    flex: 1; min-height: 42px; 
    background: rgba(255,255,255,0.1); 
    border-radius: 20px; 
    padding: 2px 16px; 
    display: flex; align-items: center; 
  }
  .omni-input { 
    width: 100%; 
    background: transparent; border: none; 
    color: #fff; font-size: 16px; 
    resize: none; padding: 10px 0; margin: 0; 
    max-height: 80px; 
    font-family: inherit;
  }
  .omni-input::placeholder { color: rgba(255,255,255,0.4); }
  
  /* –ò–∫–æ–Ω–∫–∞ –∫–∞–º–µ—Ä—ã —Å–ø—Ä–∞–≤–∞ –≤ –º–µ–Ω—é */
  .cam-trigger-btn { 
    width: 40px; height: 40px; 
    display: flex; align-items: center; justify-content: center; 
    color: #fff; cursor: pointer; 
    transition: 0.2s;
  }
  .cam-trigger-btn:active { transform: scale(0.9); opacity: 0.7; }

  /* === PERMISSION & PREVIEW === */
  .perm-overlay {
    position: absolute; inset: 0; z-index: 100;
    background: rgba(0,0,0,0.9);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center; padding: 32px; gap: 24px;
  }
  .perm-btn {
    background: var(--acc-blue); color: #fff;
    border: none; padding: 14px 28px;
    border-radius: 14px; font-size: 16px; font-weight: 600; cursor: pointer;
  }

  .preview-overlay {
    position: absolute; inset: 0; z-index: 200;
    background: #000; 
    display: none; 
    flex-direction: column;
    height: 100%; 
    overflow: hidden; 
  }
  .preview-img { 
    flex: 1; 
    width: 100%; 
    object-fit: contain; 
    background: #111; 
    margin-bottom: 12px;
    min-height: 0; 
  }
  .comment-wrap { 
    flex-shrink: 0;
    padding: 0 24px 16px 24px; 
    width: 100%; 
  }
  .comment-label { 
    display: block; 
    color: rgba(255,255,255,0.6); 
    font-size: 13px; 
    margin-bottom: 8px; 
    margin-left: 4px; 
  }
  .comment-input {
    width: 100%; height: 80px;
    background: rgba(255,255,255,0.12);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px; padding: 12px 16px;
    color: #fff; font-size: 16px; font-family: var(--font-stack);
    resize: none; outline: none; transition: 0.2s;
  }
  .comment-input:focus { background: rgba(255,255,255,0.18); border-color: var(--acc-blue); }
  .preview-controls { 
    flex-shrink: 0;
    padding: 0 24px 34px 24px; 
    display: flex; 
    gap: 16px; 
    background: #000; 
  }
  .btn {
    flex: 1; padding: 14px; border-radius: 14px;
    font-weight: 600; font-size: 16px;
    border: 1px solid rgba(255,255,255,0.1);
    background: rgba(255,255,255,0.1);
    color: #fff; cursor: pointer; text-align: center;
  }
  .btn.primary { background: var(--acc-blue); border-color: transparent; }
  .hidden { display: none !important; }

</style>
</head>
<body>

  <div class="cam-viewport">
    <video id="video" autoplay playsinline muted></video>
    
    <div id="loader" class="cam-loader hidden">
      <div class="spinner"></div>
    </div>
    
    <canvas id="uiCanvas"></canvas>
    <div id="camToast" class="cam-toast">Camera Name</div>

    <div class="ui-layer idle" id="camUI">
      <div class="top-bar">
        <div class="btn-close" id="btnClose">
          <svg class="icon-svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </div>

        <div class="status-chip" id="lvlChip">
          <div class="status-dot" id="lvlDot"></div>
          <span id="lvlText">–£—Ä–æ–≤–µ–Ω—å</span>
        </div>

        <div class="spacer"></div>
      </div>

      <div class="controls-grid">
        <div class="grid-cell-left">
          <div class="action-btn" id="btnTorch">
            <svg class="icon-svg" viewBox="0 0 24 24"><path d="M7 2v11h3v9l7-12h-4l4-8z"/></svg>
          </div>
        </div>

        <div class="grid-cell-center">
          <div class="shutter-outer disabled" id="shutterBtn">
            <div class="shutter-inner"></div>
          </div>
        </div>

        <div class="grid-cell-right">
          <div class="action-btn hidden" id="btnSwitch">
            <svg class="icon-svg" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
          </div>
        </div>
      </div>
    </div>
    
    <div class="omni-bar" id="omniBar">
      <div class="omni-icon-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>
      </div>
      <div class="input-wrap">
        <textarea class="omni-input" rows="1" placeholder="–Ø–±–ª–æ–∫–æ 200–≥, –∫–æ—Ñ–µ..."></textarea>
      </div>
      <div class="cam-trigger-btn" id="btnStartCam">
      <img 
        src="https://raw.githubusercontent.com/groskaiser-design/icons/main/cam.svg" 
        alt="Camera" 
        style="width: 28px; height: 28px; display: block;">
      </div>
    </div>

  </div>

  <div id="permReq" class="perm-overlay hidden">
    <div style="font-size:48px; margin-bottom:10px">üìê</div>
    <h2 style="margin:0">–ù–∞—Å—Ç—Ä–æ–π–∫–∞</h2>
    <p style="color:var(--text-muted)">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –¥–ª—è —Ä–∞–±–æ—Ç—ã —É—Ä–æ–≤–Ω—è.</p>
    <button class="perm-btn" onclick="requestSensors()">–†–∞–∑—Ä–µ—à–∏—Ç—å</button>
  </div>

  <div id="previewScreen" class="preview-overlay">
    <img id="finalPhoto" class="preview-img">
    <div class="comment-wrap">
      <label class="comment-label">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)</label>
      <textarea id="commentInput" class="comment-input" placeholder="–ú–æ–∂–µ—Ç–µ —É–∫–∞–∑–∞—Ç—å –ø—Ä–æ–¥—É–∫—Ç—ã, —ç—Ç–æ –ø–æ–≤—ã—Å–∏—Ç —Ç–æ—á–Ω–æ—Å—Ç—å –º–æ–¥–µ–ª–∏. –ù–∞–ø—Ä–∏–º–µ—Ä: —Ä–∏—Å 200, —Ç—Ä–µ—Å–∫–∞ 150"></textarea>
    </div>
    <div class="preview-controls">
      <button class="btn" onclick="retake()">–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
      <button class="btn primary" id="btnSend" onclick="sendPhoto()">–ì–æ—Ç–æ–≤–æ</button>
    </div>
  </div>

<script>
  // === CONFIG ===
  const API_URL = "https://script.google.com/macros/s/AKfycbx0fUaaCH-JwnG5R_3TFgU5FSibsEuhuS0ZZZfyxPNVPQ1ZpCfUIaa5aE8vjgqitac/exec"; // ‚ö†Ô∏è –í–°–¢–ê–í–¨ –°–Æ–î–ê –°–í–û–ô URL!

  // === TELEGRAM INIT ===
  const tg = window.Telegram?.WebApp;
  if(tg) {
    tg.ready(); tg.expand();
    tg.setHeaderColor('#000000');
    if(tg.disableVerticalSwipes) tg.disableVerticalSwipes();
  }

  // === API HELPER ===
  const API = {
    // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Blob –≤ Base64 (–±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞ data:image/...)
    blobToBase64: (blob) => {
      return new Promise((resolve, _) => {
        const reader = new FileReader();
        reader.onloadend = () => {
           const base64 = reader.result.split(',')[1]; 
           resolve(base64);
        };
        reader.readAsDataURL(blob);
      });
    },

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ GAS
    send: async (action, payload) => {
      // –î–∞–Ω–Ω—ã–µ —é–∑–µ—Ä–∞ –∏–∑ Telegram (–∏–ª–∏ –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Ç–µ—Å—Ç–æ–≤)
      const user = tg?.initDataUnsafe?.user || { id: 0, first_name: 'BrowserTest' };
      
      const body = {
        action: action,
        user: user,
        initData: tg?.initData || '',
        ...payload
      };

      const response = await fetch(API_URL, {
        method: "POST",
        // mode: "no-cors", // –ù–ï –í–ö–õ–Æ–ß–ê–ô –≠–¢–û, –∏–Ω–∞—á–µ –Ω–µ –ø–æ–ª—É—á–∏—à—å –æ—Ç–≤–µ—Ç JSON!
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });

      const json = await response.json();
      if (!json.ok) throw new Error(json.error || 'Server Error');
      return json;
    }
  };

  // === STATE & DOM (–¢–≤–æ–π –∫–æ–¥) ===
  const state = {
    stream: null,
    track: null,
    levelOK: false,
    angleX: 0, angleY: 0,
    photoBlob: null,
    isCapturing: false,
    isSwitching: false,
    devices: [],      
    currentDevIdx: 0, 
    torchOn: false,
    sensorActive: false,
    uiMode: 'menu'
  };

  const DOM = {
    video: document.getElementById('video'),
    canvas: document.getElementById('uiCanvas'),
    ctx: document.getElementById('uiCanvas').getContext('2d'),
    shutter: document.getElementById('shutterBtn'),
    lvlDot: document.getElementById('lvlDot'),
    lvlText: document.getElementById('lvlText'),
    permReq: document.getElementById('permReq'),
    preview: document.getElementById('previewScreen'),
    finalImg: document.getElementById('finalPhoto'),
    btnSend: document.getElementById('btnSend'),
    commentInput: document.getElementById('commentInput'),
    btnTorch: document.getElementById('btnTorch'),
    btnSwitch: document.getElementById('btnSwitch'),
    toast: document.getElementById('camToast'),
    loader: document.getElementById('loader'),
    
    omniBar: document.getElementById('omniBar'),
    camUI: document.getElementById('camUI'),
    btnStartCam: document.getElementById('btnStartCam'),
    btnClose: document.getElementById('btnClose')
  };

  // === –õ–û–ì–ò–ö–ê –ü–ï–†–ï–ö–õ–Æ–ß–ï–ù–ò–Ø ===
  DOM.btnStartCam.onclick = async () => {
    state.uiMode = 'camera';
    DOM.omniBar.classList.add('hidden');
    DOM.camUI.classList.remove('idle');
    DOM.camUI.style.pointerEvents = 'auto'; 
    if(tg?.HapticFeedback) tg.HapticFeedback.impactOccurred('light');
    await initCamera();
  };

  DOM.btnClose.onclick = () => {
    state.uiMode = 'menu';
    DOM.camUI.classList.add('idle');
    DOM.camUI.style.pointerEvents = 'none';
    DOM.omniBar.classList.remove('hidden');
    stopStream();
  };

  // === –õ–û–ì–ò–ö–ê –ö–ê–ú–ï–†–´ –ò –°–ï–ù–°–û–†–û–í (–û—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ) ===
  let toastTimer;
  function showToast(msg) {
    DOM.toast.textContent = msg;
    DOM.toast.classList.add('visible');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { DOM.toast.classList.remove('visible'); }, 2000);
  }

  function stopStream() {
    if (state.stream) { state.stream.getTracks().forEach(t => t.stop()); state.stream = null; }
    state.track = null; state.torchOn = false; 
    updateTorchUI();
    DOM.video.srcObject = null;
    DOM.video.classList.remove('active');
  }

  async function startStream(deviceId) {
    if (state.stream) stopStream();
    const constraints = { audio: false, video: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: deviceId ? undefined : 'environment', width: { ideal: 1920 }, height: { ideal: 2560 } } };
    try {
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      state.stream = stream; state.track = stream.getVideoTracks()[0];
      DOM.video.srcObject = stream; DOM.video.classList.add('active');
      const settings = state.track.getSettings();
      if (settings.deviceId) localStorage.setItem('ultima_cam_id', settings.deviceId);
      
      let label = state.track.label || "–ö–∞–º–µ—Ä–∞";
      label = label.replace(/\(.*\)/, '').replace(/camera2/i, '').replace(/facing/i, '').trim();
      if(label.length < 2) label = "–ö–∞–º–µ—Ä–∞ " + (state.currentDevIdx + 1);
      if(state.devices.length > 1) showToast(label);

      const caps = state.track.getCapabilities();
      if (caps.focusMode?.includes('continuous')) { try { await state.track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); } catch(e){} }
    } catch (e) {
      if (deviceId) { localStorage.removeItem('ultima_cam_id'); await startStream(null); } 
      else { alert("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: " + e.message); }
    }
  }

  DOM.btnSwitch.onclick = async () => {
    if (state.devices.length < 2 || state.isSwitching) return;
    state.isSwitching = true; haptic('medium');
    DOM.loader.classList.remove('hidden');
    DOM.btnSwitch.classList.add('disabled'); DOM.btnTorch.classList.add('disabled'); DOM.shutter.classList.add('disabled');
    const svg = DOM.btnSwitch.querySelector('svg'); svg.style.transition = 'transform 0.4s'; svg.style.transform = 'rotate(180deg)';
    if (state.stream) state.stream.getTracks().forEach(t => t.stop());
    await new Promise(r => setTimeout(r, 500));
    let nextIdx = state.currentDevIdx + 1;
    if (nextIdx >= state.devices.length) nextIdx = 0;
    state.currentDevIdx = nextIdx;
    await startStream(state.devices[nextIdx].deviceId);
    DOM.loader.classList.add('hidden');
    DOM.btnSwitch.classList.remove('disabled'); DOM.btnTorch.classList.remove('disabled'); DOM.shutter.classList.remove('disabled');
    state.isSwitching = false; setTimeout(() => svg.style.transform = '', 400);
  };

  DOM.btnTorch.onclick = async () => {
    if(!state.track) return;
    const caps = state.track.getCapabilities();
    if (!caps.torch) { showToast("–í—Å–ø—ã—à–∫–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞"); haptic('error'); return; }
    const newState = !state.torchOn;
    try { await state.track.applyConstraints({ advanced: [{ torch: newState }] }); state.torchOn = newState; updateTorchUI(); haptic('light'); } 
    catch(e) { showToast("–û—à–∏–±–∫–∞ –≤—Å–ø—ã—à–∫–∏"); }
  };

  function updateTorchUI() {
    if (state.torchOn) { DOM.btnTorch.style.backgroundColor = 'var(--acc-orange)'; DOM.btnTorch.style.color = '#000'; } 
    else { DOM.btnTorch.style.backgroundColor = ''; DOM.btnTorch.style.color = '#fff'; }
  }

  function checkSensorPerms() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { DOM.permReq.classList.remove('hidden'); } 
    else { window.addEventListener('deviceorientation', handleOrientation); }
  }
  async function requestSensors() {
    try { const resp = await DeviceOrientationEvent.requestPermission(); if (resp === 'granted') { window.addEventListener('deviceorientation', handleOrientation); } } 
    catch (e) {} finally { DOM.permReq.classList.add('hidden'); }
  }
  function handleOrientation(e) {
    let x = e.beta; let y = e.gamma; 
    if (x === null || y === null) return;
    state.sensorActive = true; state.angleX = x; state.angleY = y;
  }
  function updateUI() {
    if (state.uiMode === 'menu') return;
    if (state.isCapturing || state.isSwitching) return;
    if (!state.sensorActive) { DOM.lvlDot.classList.remove('ok'); DOM.lvlText.textContent = "–ö–∞–º–µ—Ä–∞"; DOM.shutter.classList.remove('disabled'); DOM.shutter.classList.add('active'); return; }
    if (state.levelOK) { DOM.lvlDot.classList.add('ok'); DOM.lvlText.textContent = "–†–æ–≤–Ω–æ"; DOM.shutter.classList.remove('disabled'); DOM.shutter.classList.add('active'); } 
    else { DOM.lvlDot.classList.remove('ok'); DOM.lvlText.textContent = "–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ"; DOM.shutter.classList.add('disabled'); DOM.shutter.classList.remove('active'); }
  }
  function resizeCanvas() { const w = window.innerWidth; const h = window.innerHeight; if (DOM.canvas.width !== w || DOM.canvas.height !== h) { DOM.canvas.width = w; DOM.canvas.height = h; } }

  async function initCamera() {
    try { const savedId = localStorage.getItem('ultima_cam_id'); await startStream(savedId); await updateDeviceList(); resizeCanvas(); window.addEventListener('resize', resizeCanvas); requestAnimationFrame(drawLoop); checkSensorPerms(); } 
    catch (e) { console.warn("Init Error:", e); }
  }
  async function updateDeviceList() {
    try {
      const allDevices = await navigator.mediaDevices.enumerateDevices();
      state.devices = allDevices.filter(d => d.kind === 'videoinput');
      if (state.devices.length > 1) { DOM.btnSwitch.classList.remove('hidden'); } else { DOM.btnSwitch.classList.add('hidden'); }
      if (state.track) {
        const currentId = state.track.getSettings().deviceId;
        state.currentDevIdx = state.devices.findIndex(d => d.deviceId === currentId);
        if(state.currentDevIdx === -1) state.currentDevIdx = 0;
      }
    } catch(e) {}
  }

  function drawLoop() {
    const ctx = DOM.ctx; const w = DOM.canvas.width; const h = DOM.canvas.height;
    ctx.clearRect(0, 0, w, h);
    if (state.uiMode === 'menu') { requestAnimationFrame(drawLoop); return; }
    
    const cx = w / 2; const cy = h / 2;
    const cardRatio = 1.586; const cardW = w * 0.22; const cardH = cardW * cardRatio;
    const cardX = cx + 80; const cardY = cy - cardH / 2; const r = 8; 
    ctx.beginPath(); ctx.moveTo(cardX + r, cardY); ctx.lineTo(cardX + cardW - r, cardY); ctx.quadraticCurveTo(cardX + cardW, cardY, cardX + cardW, cardY + r); ctx.lineTo(cardX + cardW, cardY + cardH - r); ctx.quadraticCurveTo(cardX + cardW, cardY + cardH, cardX + cardW - r, cardY + cardH); ctx.lineTo(cardX + r, cardY + cardH); ctx.quadraticCurveTo(cardX, cardY + cardH, cardX, cardY + cardH - r); ctx.lineTo(cardX, cardY + r); ctx.quadraticCurveTo(cardX, cardY, cardX + r, cardY);
    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)'; ctx.fill(); 
    ctx.save(); ctx.translate(cardX + cardW / 2, cardY + cardH / 2); ctx.rotate(-Math.PI / 2); ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 12px sans-serif'; ctx.fillText("CREDIT CARD", 0, -10); ctx.font = '10px sans-serif'; ctx.fillText("(–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ)", 0, 10); ctx.restore(); 

    if (state.sensorActive) {
        const rBubble = 14; const rTarget = 18; const maxOffset = 60; 
        const rawX = (isNaN(state.angleY) || state.angleY === null) ? 0 : state.angleY;
        const rawY = (isNaN(state.angleX) || state.angleX === null) ? 0 : state.angleX;
        const clamp = (val) => Math.max(-20, Math.min(20, val));
        const dx = (clamp(rawX) / 20) * maxOffset; const dy = (clamp(rawY) / 20) * maxOffset;
        const dist = Math.hypot(dx, dy);
        const isInside = (dist + rBubble) <= rTarget;
        if (state.levelOK !== isInside && !state.isCapturing && !state.isSwitching) { state.levelOK = isInside; updateUI(); if(isInside) haptic('medium'); }
        ctx.shadowBlur = 4; ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.beginPath(); ctx.arc(cx, cy, rTarget, 0, Math.PI * 2); 
        const color = (state.levelOK || state.isCapturing) ? '#30d158' : 'rgba(255,255,255,0.85)';
        ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
        ctx.beginPath(); ctx.arc(cx + dx, cy + dy, rBubble, 0, Math.PI * 2); ctx.fillStyle = color; ctx.fill(); ctx.shadowBlur = 0;
    } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx-10, cy); ctx.lineTo(cx+10, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, cy-10); ctx.lineTo(cx, cy+10); ctx.stroke();
    }
    requestAnimationFrame(drawLoop);
  }

  DOM.shutter.addEventListener('click', async () => {
    if (state.isCapturing || state.isSwitching) return; 
    if (state.sensorActive && !state.levelOK) { haptic('error'); showToast("–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω"); return; }
    try {
        state.isCapturing = true; haptic('heavy');
        DOM.shutter.style.transform = 'scale(0.8)'; DOM.shutter.style.opacity = '0.5';
        await new Promise(r => setTimeout(r, 50));
        const vid = DOM.video;
        if (vid.readyState < 2 || vid.videoWidth === 0) throw new Error("–ö–∞–º–µ—Ä–∞ –Ω–µ –≥–æ—Ç–æ–≤–∞");
        const c = document.createElement('canvas'); c.width = vid.videoWidth; c.height = vid.videoHeight;
        c.getContext('2d').drawImage(vid, 0, 0);
        const blob = await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.95));
        if (!blob) throw new Error("–ü—É—Å—Ç–æ–π –∫–∞–¥—Ä");
        showPreview(blob);
    } catch(err) {
        console.error(err); haptic('error'); showToast("–û—à–∏–±–∫–∞: " + err.message);
        state.isCapturing = false; updateUI();
    } finally {
        DOM.shutter.style.transform = ''; DOM.shutter.style.opacity = ''; state.isCapturing = false;
    }
  });

  function showPreview(blob) {
    if(!blob) return; state.photoBlob = blob;
    DOM.finalImg.src = URL.createObjectURL(blob); DOM.preview.style.display = 'flex';
  }
  function retake() {
    DOM.preview.style.display = 'none';
    if(DOM.finalImg.src) URL.revokeObjectURL(DOM.finalImg.src);
    DOM.finalImg.src = ''; state.photoBlob = null; DOM.commentInput.value = ''; 
  }

  // üî• –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –û–¢–ü–†–ê–í–ö–ò üî•
  async function sendPhoto() {
    const btn = DOM.btnSend;
    if (btn.disabled) return; 
    
    // UI: –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
    btn.disabled = true;
    btn.textContent = '–ê–Ω–∞–ª–∏–∑...';
    btn.style.opacity = '0.8'; 
    haptic('light');

    try {
        if (!state.photoBlob) throw new Error("–ù–µ—Ç —Ñ–æ—Ç–æ");

        // 1. –ì–æ—Ç–æ–≤–∏–º –¥–∞–Ω–Ω—ã–µ
        const base64 = await API.blobToBase64(state.photoBlob);
        const userText = DOM.commentInput.value;

        // 2. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ –ë–≠–ö
        const result = await API.send('scan', {
            image: base64,
            userText: userText
        });

        // 3. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
        // –ù–∞–º –ø—Ä–∏–¥–µ—Ç result.data (draft) –∏ result.scanId (–¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ–≥–∞)
        // –°–æ—Ö—Ä–∞–Ω–∏–º —ç—Ç–æ –≤ localStorage, —á—Ç–æ–±—ã –ø–µ—Ä–µ–¥–∞—Ç—å –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π —ç–∫—Ä–∞–Ω
        const sessionData = {
            draft: result.data,
            scanId: result.scanId,
            preview: DOM.finalImg.src // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: –º–æ–∂–Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å blob url, –Ω–æ –æ–Ω —Å–≥–æ—Ä–∏—Ç –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ
        };
        localStorage.setItem('ultima_session', JSON.stringify(sessionData));

        // 4. –£—Å–ø–µ—Ö
        btn.textContent = '–£—Å–ø–µ—Ö!';
        btn.style.backgroundColor = 'var(--acc-green)'; 
        btn.style.borderColor = 'var(--acc-green)';
        haptic('success');

        // 5. –ü–µ—Ä–µ—Ö–æ–¥ (–≤ –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –±—É–¥–µ—Ç window.location = 'scanner.html')
        setTimeout(() => {
            alert("–ü–µ—Ä–µ—Ö–æ–¥ –∫ —á–µ—Ä–Ω–æ–≤–∏–∫—É! scanId: " + result.scanId);
            // window.location.href = 'scanner.html?load_session=true';
            
            // –ü–æ–∫–∞ –ø—Ä–æ—Å—Ç–æ —Å–±—Ä–æ—Å–∏–º –¥–ª—è —Ç–µ—Å—Ç–∞
            retake(); 
            btn.textContent = '–ì–æ—Ç–æ–≤–æ';
            btn.disabled = false;
            btn.style.backgroundColor = ''; 
            btn.style.borderColor = '';
            btn.style.opacity = '1';
        }, 1000);

    } catch (e) {
        console.error(e);
        btn.textContent = '–û—à–∏–±–∫–∞';
        btn.style.backgroundColor = 'var(--acc-red)';
        haptic('error');
        alert("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: " + e.message); // –ü–æ–∫–∞–∂–µ–º –¥–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏
        setTimeout(() => {
            btn.textContent = '–ì–æ—Ç–æ–≤–æ';
            btn.disabled = false;
            btn.style.backgroundColor = '';
        }, 2000);
    }
  }

  function haptic(style) { if (tg?.HapticFeedback) tg.HapticFeedback.impactOccurred(style); }
</script>
</body>
</html>