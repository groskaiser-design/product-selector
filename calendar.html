<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Ultima Coach Infinite</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>

<style>
  :root {
    --bg-core: #050505; --bg-panel: #1C1C1E; --bg-elevated: #2C2C2E;
    --text-main: #ffffff; --text-muted: #8E8E93;
    --line-color: rgba(255, 255, 255, 0.08);
    --time-col-width: 55px; --day-col-width: 65px; 
    --acc-blue: #0a84ff; --acc-red: #ff453a; --acc-green: #30d158; --acc-purple: #5e60ce; --acc-current: #3c9cfd;
    --grid-h: 60px;
    --safe-top: env(safe-area-inset-top); --safe-bottom: env(safe-area-inset-bottom);
  }
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; outline: none; }
  *::-webkit-scrollbar { display: none; }
  body { background-color: var(--bg-core); font-family: -apple-system, sans-serif; color: var(--text-main); height: 100%; width: 100%; overflow: hidden; position: fixed; inset: 0; user-select: none; }
  
  /* FX LAYER */
  .fx-layer { position: absolute; inset: 0; pointer-events: none; overflow: hidden; z-index: 0; }
  .orb { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.5; }
  .orb-1 { width: 300px; height: 300px; background: var(--acc-purple); top: -50px; left: -100px; animation: float 20s infinite ease-in-out; }
  .orb-2 { width: 250px; height: 250px; background: var(--acc-blue); bottom: -50px; right: -50px; animation: float 15s infinite ease-in-out reverse; }
  .noise { position: fixed; inset: 0; opacity: 0.04; background: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E"); }
  @keyframes float { 0%, 100% { transform: translate(0,0); } 50% { transform: translate(30px,50px); } }

  /* LAYOUT */
  .app-container { display: flex; flex-direction: column; height: 100%; width: 100%; position: relative; z-index: 2; }
  .top-area { background: rgba(0,0,0,0.3); backdrop-filter: blur(20px); border-bottom: 1px solid var(--line-color); padding-top: calc(10px + var(--safe-top)); padding-bottom: 4px; z-index: 60; flex-shrink: 0; }
  .header-row { display: flex; justify-content: space-between; align-items: center; padding: 0 16px; margin-bottom: 10px; }
  .month-label { font-size: 15px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
  .week-controls { display: flex; gap: 16px; }
  .icon-btn { width: 32px; height: 32px; color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center; }

  /* MATRIX */
  .matrix-viewport { flex: 1; overflow: auto; position: relative; display: flex; flex-direction: column; z-index: 10; }
  .matrix-header-row { display: flex; position: sticky; top: 0; z-index: 40; width: max-content; background: rgba(0,0,0,0.25); backdrop-filter: blur(15px); border-bottom: 1px solid var(--line-color); }
  .corner-cell { width: var(--time-col-width); flex-shrink: 0; position: sticky; left: 0; z-index: 50; background: inherit; border-right: 1px solid var(--line-color); }
  .days-header-track { display: flex; flex: 1; }
  .day-col-header { width: var(--day-col-width); flex-shrink: 0; text-align: center; height: 58px; padding-top: 8px; border-right: 1px solid var(--line-color); display: flex; flex-direction: column; align-items: center; gap: 2px; }
  .dch-day { font-weight: 600; font-size: 11px; color: var(--text-muted); text-transform: uppercase; }
  .dch-num { font-size: 16px; font-weight: 500; color: #fff; }
  .day-col-header.today .dch-day { color: var(--acc-blue); }
  .day-col-header.today { background: rgba(10, 132, 255, 0.15); border-bottom: 2px solid var(--acc-blue); }
  .dch-stats { width: 44px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; margin-top: 4px; overflow: hidden; display: flex; }
  .dch-stats-fill { height: 100%; background: var(--acc-current); width: 0%; }

  .matrix-body { display: flex; width: max-content; position: relative; }
  .time-column { width: var(--time-col-width); flex-shrink: 0; position: sticky; left: 0; z-index: 30; background: rgba(0,0,0,0.25); backdrop-filter: blur(15px); border-right: 1px solid var(--line-color); }
  .time-label { height: var(--grid-h); position: relative; }
  .time-label span { position: absolute; top: -7px; right: 6px; font-size: 11px; color: var(--text-muted); }
  .time-line-badge { position: absolute; right: 4px; background: var(--acc-current); color: #fff; font-size: 11px; font-weight: 700; padding: 2px 6px; border-radius: 4px; z-index: 31; transform: translateY(-50%); }

  .grid-columns-container { display: flex; flex: 1; position: relative; }
  .day-column { width: var(--day-col-width); flex-shrink: 0; border-right: 1px solid var(--line-color); position: relative; background-image: linear-gradient(to bottom, var(--line-color) 1px, transparent 1px); background-size: 100% var(--grid-h); }
  .day-column.today { background-color: rgba(10, 132, 255, 0.02); }

  /* EVENTS & OVERLAYS */
  .event-card { position: absolute; left: 0; border-radius: 6px; padding: 3px 5px; overflow: hidden; border-left: 3px solid; cursor: pointer; z-index: 5; box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.1); }
  .event-card.ghost { opacity: 1; border-width: 1px; border-left-width: 3px; }
  .ev-title { font-size: 11px; font-weight: 700; color: #fff; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .ev-time { font-size: 9px; color: rgba(255,255,255,0.95); font-weight: 600; }
  .ev-recurring-icon { position: absolute; right: 4px; bottom: 4px; opacity: 0.8; width: 8px; height: 8px; }

  .sheet-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; opacity: 0; pointer-events: none; transition: 0.3s; backdrop-filter: blur(4px); }
  .sheet-overlay.active { opacity: 1; pointer-events: auto; }
  .sheet { position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-panel); border-radius: 20px 20px 0 0; padding: 0 16px calc(24px + var(--safe-bottom)) 16px; transform: translateY(110%); transition: transform 0.3s; z-index: 101; max-height: 90vh; overflow-y: auto; }
  .sheet.open { transform: translateY(0); }
  .action-sheet-container { position: fixed; bottom: 0; left: 0; right: 0; z-index: 150; padding: 16px; padding-bottom: calc(16px + var(--safe-bottom)); transform: translateY(110%); transition: transform 0.25s; }
  .action-sheet-container.open { transform: translateY(0); }
  
  /* FORM ELEMENTS */
  .as-group { background: rgba(30,30,32,0.95); backdrop-filter: blur(20px); border-radius: 14px; overflow: hidden; margin-bottom: 8px; }
  .as-button { width: 100%; padding: 16px; background: transparent; border: none; border-bottom: 1px solid rgba(255,255,255,0.1); color: var(--acc-blue); font-size: 17px; cursor: pointer; }
  .as-button:last-child { border-bottom: none; }
  .as-button.danger { color: var(--acc-red); }
  .as-button.bold { font-weight: 600; }
  .as-title { padding: 12px; font-size: 13px; color: var(--text-muted); text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); }
  .as-cancel { background: var(--bg-elevated); border-radius: 14px; color: var(--acc-blue); font-weight: 600; }

  .form-group { margin-bottom: 16px; }
  .form-label { font-size: 12px; color: #8E8E93; margin-bottom: 6px; text-transform: uppercase; }
  .input-box { width: 100%; background: rgba(118,118,128,0.24); border: none; border-radius: 10px; padding: 12px; color: #fff; font-size: 16px; }
  .input-box[type="date"] { color: #fff; }
  .input-row { display: flex; gap: 12px; }
  .btn-primary { width: 100%; padding: 14px; background: #fff; color: #000; font-weight: 600; font-size: 16px; border-radius: 12px; border: none; margin-top: 12px; cursor: pointer; display: flex; justify-content: center; }
  .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
  .btn-danger { background: rgba(255,69,58,0.15); color: var(--acc-red); }
  
  .switch { position: relative; display: inline-block; width: 50px; height: 30px; }
  .switch input { opacity: 0; width: 0; height: 0; }
  .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #3a3a3c; transition: .4s; border-radius: 30px; }
  .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
  input:checked + .slider { background-color: var(--acc-green); }
  input:checked + .slider:before { transform: translateX(20px); }

  .blocked-slot { position: absolute; left: 0; right: 0; height: var(--grid-h); background: repeating-linear-gradient(45deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 10px, rgba(255,255,255,0.06) 10px, rgba(255,255,255,0.06) 20px); pointer-events: none; z-index: 1; }
  .day-off-overlay { position: absolute; inset: 0; background-color: var(--bg-core); background-image: repeating-linear-gradient(45deg, rgba(60, 156, 253, 0.1), rgba(60, 156, 253, 0.1) 10px, rgba(60, 156, 253, 0.2) 10px, rgba(60, 156, 253, 0.2) 20px); z-index: 8; pointer-events: none; }
  .global-time-line { position: absolute; left: 0; width: 100%; height: 1px; background: var(--acc-current); z-index: 10; pointer-events: none; display: none; }
  .global-time-line::before { content: ''; position: absolute; left: -4px; top: -3px; width: 7px; height: 7px; background: var(--acc-current); border-radius: 50%; }

  .toast-notification { position: fixed; top: 60px; left: 16px; right: 16px; background: rgba(28,28,30,0.9); backdrop-filter: blur(12px); border-radius: 16px; padding: 16px; text-align: center; transform: translateY(-200%); transition: transform 0.4s; z-index: 9999; border: 1px solid rgba(255,255,255,0.1); }
  .toast-notification.show { transform: translateY(0); }
  .toast-notification span { display: block; font-weight: 700; margin-bottom: 4px; font-size: 12px; text-transform: uppercase; color: var(--acc-red); }
  .toast-notification.success span { color: var(--acc-green); }
</style>
</head>
<body oncontextmenu="return false;">

<div class="fx-layer"><div class="orb orb-1"></div><div class="orb orb-2"></div><div class="noise"></div></div>
<div class="toast-notification" id="toast"><span id="toastTitle"></span><div id="toastMessage"></div></div>

<div class="app-container">
  <div class="top-area">
    <div class="header-row">
      <div class="month-label" id="headerMonth"></div>
      <div class="week-controls">
        <div class="icon-btn" onclick="openSettings()"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg></div>
      </div>
    </div>
  </div>
  <div class="matrix-viewport" id="matrixViewport">
    <div class="matrix-header-row"><div class="corner-cell"></div><div class="days-header-track" id="daysHeaderTrack"></div></div>
    <div class="matrix-body">
      <div class="time-column" id="timeColumn"><div class="time-line-badge" id="timeLineBadge">00:00</div></div>
      <div class="grid-columns-container" id="gridColumns"><div class="global-time-line" id="globalTimeLine"></div></div>
    </div>
  </div>
</div>

<div class="sheet-overlay" id="overlay" onclick="closeAllSheets()"></div>
<div class="sheet-overlay" id="actionSheetOverlay" style="z-index:140" onclick="closeActionSheet()"></div>

<div class="action-sheet-container" id="actionSheet">
  <div class="as-group">
    <div class="as-title" id="asTitle">Настройки серии</div>
    <button class="as-button" id="asBtnOne">Только эта тренировка</button>
    <button class="as-button bold" id="asBtnSeries">Вся серия</button>
  </div>
  <button class="as-button as-cancel" onclick="closeActionSheet()">Отмена</button>
</div>

<div class="sheet" id="sessionSheet">
  <div class="sheet-header"><div class="sh-title" id="sheetTitle">Тренировка</div><div class="sh-close" onclick="closeAllSheets()">Отмена</div></div>
  
  <div id="patternInfoBox" style="display:none; background: rgba(10,132,255,0.1); border:1px solid var(--acc-blue); border-radius:8px; padding:10px; margin-bottom:16px; align-items:center; gap:10px;">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="color:var(--acc-blue)"><path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/></svg>
    <div style="font-size:13px; color:#fff;">Это часть регулярной серии.</div>
  </div>

  <div class="form-group">
    <div class="form-label">Клиент</div>
    <input type="text" class="input-box" id="inpClient" list="clientList" placeholder="Поиск клиента..." autocomplete="off">
    <datalist id="clientList"></datalist>
  </div>
  <div class="form-group"><div class="form-label">Дата <span id="dateDisplay" style="color:#fff; float:right"></span></div><input type="date" class="input-box" id="inpDate" onchange="updateDateDisplay()"></div>
  <div class="input-row">
    <div class="form-group" style="flex:1"><div class="form-label">Начало</div><input type="time" class="input-box" id="inpStart"></div>
    <div class="form-group" style="flex:1"><div class="form-label">Конец</div><input type="time" class="input-box" id="inpEnd"></div>
  </div>
  <div class="form-group"><div class="form-label">Заметка</div><input type="text" class="input-box" id="inpNote" placeholder="Описание..."></div>
  
  <div class="form-group" id="recurringOptionContainer" style="display:flex; align-items:center; gap:12px; background:rgba(255,255,255,0.05); padding:12px; border-radius:10px; margin-bottom:16px;">
    <div style="flex:1; font-size:16px;">Повторять еженедельно</div>
    <label class="switch"><input type="checkbox" id="inpRecurring"><span class="slider"></span></label>
  </div>

  <button class="btn-primary" onclick="trySaveSession()">Сохранить</button>
  <button class="btn-primary btn-danger" id="btnDelete" style="display:none" onclick="tryDeleteSession()">Удалить</button>
</div>

<div class="sheet" id="settingsSheet">
  <div class="sheet-header"><div class="sh-title">Настройки</div><div class="sh-close" onclick="closeAllSheets()">Закрыть</div></div>
  <div class="form-group"><button class="btn-primary" onclick="alert('Функция в разработке')">График работы (В разработке)</button></div>
</div>

<script>
  // CONFIG
  const APP_VERSION = 'v11.0-CLEAN-ARCH';
  const API_URL = 'https://script.google.com/macros/s/AKfycbx9wM-OzH88XXUnEeA80Nh2QCA84D2AvQroJyl8xk6F0weMSmJNXII01oI5j20odNCnAg/exec'; 
  
  const GRID_H = 60;
  let startOffset = -30, endOffset = 60;
  
  // STATE: Clients = справочник, Patterns = серии, Sessions = разовые
  let clients = [];
  let patterns = []; // Глобальные серии
  let sessions = []; // Разовые события
  
  // Settings State
  let availabilityPattern = {0:[],1:[],2:[],3:[],4:[],5:[],6:[]};
  let dateExceptions = {}; 
  
  // Helpers State
  let editingId = null, editingPatternId = null, tempSessionData = null;
  let isScrolling = false;
  
  const colorPalette = ['#B0BEC5', '#90A4AE', '#78909C', '#607D8B', '#FF5252', '#FF4081', '#E040FB', '#7C4DFF', '#448AFF', '#40C4FF', '#18FFFF', '#69F0AE', '#B2FF59', '#FFFF00', '#FFAB00', '#FF6D00'];

  // ==========================================
  // HELPER FUNCTIONS (Declared first)
  // ==========================================
  const DataManager = {
    saveLocally() { 
        localStorage.setItem('uc_clients_v11', JSON.stringify(clients));
        localStorage.setItem('uc_sessions_v11', JSON.stringify(sessions));
        localStorage.setItem('uc_patterns_v11', JSON.stringify(patterns));
    },
    loadLocal() {
       try {
        clients = JSON.parse(localStorage.getItem('uc_clients_v11')) || [];
        sessions = JSON.parse(localStorage.getItem('uc_sessions_v11')) || [];
        patterns = JSON.parse(localStorage.getItem('uc_patterns_v11')) || [];
      } catch(e) { console.error("Local Load Error", e); }
    },
    async fetchFromServer(action, payload = {}) {
      const tg = window.Telegram?.WebApp;
      const bodyData = { action, init_data: tg?.initData || '', ...payload };
      try {
        const resp = await fetch(API_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=UTF-8' },
          body: JSON.stringify(bodyData)
        });
        const json = await resp.json();
        return json.data;
      } catch (e) { console.error('[API] Error:', e); throw e; }
    }
  };

  function generateUniqueId() { return Date.now() + Math.floor(Math.random() * 1000000); }
  function normalizeTime(t) { if (!t) return "00:00"; const parts = t.split(':'); return `${String(parts[0]).padStart(2,'0')}:${String(parts[1]).padStart(2,'0')}`; }
  function getLocalDateStr(d) { return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`; }
  function getStartOfWeek(d) { const date=new Date(d); const day=date.getDay(); const diff=date.getDate()-day+(day===0?-6:1); date.setDate(diff); date.setHours(0,0,0,0); return date; }
  function hexToRgba(hex, alpha) { const r=parseInt(hex.slice(1,3),16), g=parseInt(hex.slice(3,5),16), b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${alpha})`; }

  // ==========================================
  // SYNC LOGIC (Migration & Parsing)
  // ==========================================
  function applyServerData(data, monthStr) {
      if (!data) return;

      // 1. Process Clients (Strict: ID, Name, Color ONLY)
      if (data.clients && Array.isArray(data.clients)) {
          // Architecture Shift: We extract schedules if backend still sends them, convert to patterns, and clean the client.
          const incomingPatterns = [];
          
          clients = data.clients.map(c => {
              // Migration Logic: Check if legacy schedule exists
              if (c.schedule) {
                  Object.keys(c.schedule).forEach(dayIdx => {
                      if (!c.schedule[dayIdx]) return;
                      c.schedule[dayIdx].forEach(slot => {
                          incomingPatterns.push({
                              id: `pat-${c.id}-${dayIdx}-${slot.s}`,
                              clientId: c.id,
                              dayIdx: parseInt(dayIdx),
                              start: normalizeTime(slot.s),
                              end: normalizeTime(slot.e)
                          });
                      });
                  });
              }
              // Return clean client
              return { id: c.id, name: c.name, color: c.color || colorPalette[0] };
          });
          
          // Merge migration patterns with existing ones (deduplicate by ID)
          if (incomingPatterns.length > 0) {
              const existingIds = new Set(patterns.map(p => p.id));
              incomingPatterns.forEach(p => {
                  if (!existingIds.has(p.id)) patterns.push(p);
              });
          }
      }

      // 2. Process Calendar (Sessions & Patterns from DB)
      if (data.calendar) {
          // If the server sends pattern objects in calendar, we handle them here.
          // For now, assuming standard month session sync:
          sessions = sessions.filter(s => s.dateStr.substring(0, 7) !== monthStr); // Clear month
          
          Object.keys(data.calendar).forEach(dayKey => {
             data.calendar[dayKey].forEach(evt => {
                 // Determine if this is a Session or a Pattern based on structure (if server mixed them)
                 // Assuming standard session for now based on your current backend
                 sessions.push({
                    id: evt.i || generateUniqueId(),
                    clientId: evt.c,
                    dateStr: `${monthStr}-${dayKey.padStart(2, '0')}`,
                    start: normalizeTime(evt.s),
                    end: normalizeTime(evt.e),
                    status: evt.st,
                    note: evt.n,
                    type: 'session' // Explicit type
                 });
             });
          });
      }
      reRenderBlocks();
  }

  // ==========================================
  // RENDER LOGIC (2-Layer System)
  // ==========================================
  function reRenderBlocks() {
      document.querySelectorAll('.day-column').forEach(col => {
          // Clear old events
          col.querySelectorAll('.event-card').forEach(e => e.remove());
          
          const dateStr = col.getAttribute('data-date');
          const dayIdx = parseInt(col.getAttribute('data-day-idx'));
          const colLeft = Math.round(col.offsetLeft); 

          // Background (Slots)
          col.querySelectorAll('.blocked-slot, .day-off-overlay').forEach(e => e.remove());
          (availabilityPattern[dayIdx] || []).forEach(h => { 
              const b = document.createElement('div'); b.className = 'blocked-slot stripe-bg'; 
              b.style.top = `${h*GRID_H}px`; b.style.backgroundPosition = `-${colLeft}px -${h*GRID_H}px`; col.appendChild(b); 
          });

          // LAYER 1: PATTERNS (Ghosts)
          patterns.filter(p => p.dayIdx === dayIdx).forEach(p => {
              // Check if specific session overrides this pattern on this date
              const isOverridden = sessions.some(s => s.dateStr === dateStr && s.start === p.start && String(s.clientId) === String(p.clientId));
              
              if (!isOverridden) {
                  const client = clients.find(c => String(c.id) === String(p.clientId)) || {name: 'Unknown', color: '#555'};
                  renderEventCard(col, { 
                      id: p.id,
                      start: p.start, end: p.end,
                      clientName: client.name, color: client.color,
                      type: 'ghost', // CSS class
                      originalData: p // Reference for editing
                  });
              }
          });

          // LAYER 2: SESSIONS (Real)
          sessions.filter(s => s.dateStr === dateStr && s.status !== 'cancelled').forEach(s => {
              const client = clients.find(c => String(c.id) === String(s.clientId)) || {name: 'Unknown', color: '#555'};
              renderEventCard(col, { 
                  id: s.id,
                  start: s.start, end: s.end,
                  clientName: client.name, color: client.color,
                  type: 'session',
                  originalData: s
              });
          });
      });
  }

  function renderEventCard(col, data) {
      const [h, m] = data.start.split(':').map(Number);
      const [hE, mE] = data.end.split(':').map(Number);
      const top = (h*60 + m)/60 * GRID_H;
      const height = ((hE*60 + mE) - (h*60 + m))/60 * GRID_H;
      
      const el = document.createElement('div');
      el.className = `event-card ${data.type}`;
      el.style.top = top + 'px';
      el.style.height = Math.max(height, 20) + 'px';
      el.style.width = '96%'; el.style.left = '2%';
      el.style.borderLeftColor = data.color;
      el.style.backgroundColor = hexToRgba(data.color, 0.85);
      
      el.innerHTML = `<div class="ev-title">${data.clientName}</div><div class="ev-time">${data.start} - ${data.end}</div>`;
      if(data.type === 'ghost') el.innerHTML += `<svg class="ev-recurring-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 2v6h-6M2.5 22v-6h6"/></svg>`;
      
      el.onclick = (e) => { e.stopPropagation(); openEdit(data); };
      col.appendChild(el);
  }

  // ==========================================
  // INITIALIZATION
  // ==========================================
  document.addEventListener('DOMContentLoaded', init);

  async function init() {
    const tg = window.Telegram?.WebApp;
    if(tg) { tg.ready(); tg.expand(); try{tg.setHeaderColor('#050505');tg.setBackgroundColor('#050505');}catch(_){} }

    DataManager.loadLocal();
    
    // Setup UI
    renderTimeColumn(); 
    renderDayRange(startOffset, endOffset); 
    
    // Safe Scroll
    setTimeout(() => {
        const today = getLocalDateStr(new Date());
        const el = document.getElementById('header-' + today);
        const vp = document.getElementById('matrixViewport');
        if(el && vp) { 
            vp.scrollLeft = el.offsetLeft - vp.clientWidth/2 + el.offsetWidth/2;
            vp.scrollTop = 12 * GRID_H - vp.clientHeight/2;
        }
    }, 100);
    
    startClock(); 
    reRenderBlocks();
    
    document.getElementById('matrixViewport').addEventListener('scroll', ()=>{ 
        const vp = document.getElementById('matrixViewport');
        // Simple Infinite Scroll Logic (Forward only for stability)
        if(vp.scrollWidth - (vp.scrollLeft + vp.clientWidth) < 300) {
             const old = endOffset; endOffset+=14; renderDayRange(old+1, endOffset); reRenderBlocks();
        }
        // Month Label Update
        const headers = document.querySelectorAll('.day-col-header');
        for(let h of headers) {
            if(h.offsetLeft >= vp.scrollLeft) { 
                const d=new Date(h.getAttribute('data-date')); 
                document.getElementById('headerMonth').textContent=`${d.toLocaleString('ru',{month:'long'}).toUpperCase()} ${d.getFullYear()}`; 
                break; 
            } 
        }
    }, {passive: true});

    // Server Sync
    const d = new Date();
    const m1 = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}`;
    
    try {
        const [d1] = await Promise.all([
            DataManager.fetchFromServer('init_load', { month_str: m1 })
        ]);
        applyServerData(d1, m1);
        DataManager.saveLocally();
        showToast("Синхронизация завершена", true);
    } catch (e) { showToast("Оффлайн режим", false); }
  }

  // ==========================================
  // ACTIONS (User Interactions)
  // ==========================================
  async function trySaveSession() {
    const name = document.getElementById('inpClient').value.trim();
    if(!name) return showToast("Введите имя", false);
    
    // Find or Create Client
    let client = clients.find(c => c.name.toLowerCase() === name.toLowerCase());
    if(!client) {
        client = { id: generateUniqueId(), name: name, color: colorPalette[clients.length % colorPalette.length] };
        clients.push(client);
        DataManager.fetchFromServer('save_client', { client }); // Save pure client info
    }
    
    const sData = {
        clientId: client.id,
        dateStr: document.getElementById('inpDate').value,
        start: document.getElementById('inpStart').value,
        end: document.getElementById('inpEnd').value,
        note: document.getElementById('inpNote').value,
        status: 'planned'
    };
    
    const isRecurring = document.getElementById('inpRecurring').checked;
    
    if (isRecurring && !editingPatternId) {
        // Create NEW Pattern
        const dayIdx = new Date(sData.dateStr).getDay() - 1;
        const newPattern = {
            id: `pat-${client.id}-${dayIdx}-${sData.start}`,
            clientId: client.id,
            dayIdx: (dayIdx === -1 ? 6 : dayIdx),
            start: sData.start,
            end: sData.end
        };
        patterns.push(newPattern);
        
        // SYNC: We need to send this pattern to server.
        // HACK for compatibility: Convert pattern to legacy 'schedule' structure inside client for transport
        // until backend supports 'save_pattern' directly.
        const legacyClient = { ...client, schedule: { [newPattern.dayIdx]: [{s: newPattern.start, e: newPattern.end}] } };
        DataManager.fetchFromServer('save_client', { client: legacyClient });
        
    } else {
        // Session Handling
        if(editingId) {
            // Update existing
            const idx = sessions.findIndex(s => s.id == editingId);
            if(idx !== -1) sessions[idx] = { ...sessions[idx], ...sData };
        } else {
            // Create new
            sData.id = generateUniqueId();
            sessions.push(sData);
        }
        
        // SYNC: Send single session payload
        const payload = sessions.filter(s => s.dateStr === sData.dateStr).map(s => ({
            i: s.id, c: s.clientId, s: s.start, e: s.end, st: s.status, n: s.note
        }));
        DataManager.fetchFromServer('sync_day', { date: sData.dateStr, day_data: payload });
    }
    
    DataManager.saveLocally();
    closeAllSheets();
    reRenderBlocks();
  }

  function tryDeleteSession() {
      if (editingPatternId) {
          // Delete Pattern
          patterns = patterns.filter(p => p.id !== editingPatternId);
          // Sync deletion: Send client with EMPTY schedule for that day to clear it on backend
          // We find the client and construct a 'clearing' payload
          // This is a simplification; ideally use explicit 'delete_pattern'
          showToast("Серия удалена (Локально)");
      } else if (editingId) {
          // Delete Session
          const s = sessions.find(s => s.id == editingId);
          if(s) {
              sessions = sessions.filter(x => x.id !== editingId);
              // Sync removal
              const payload = sessions.filter(x => x.dateStr === s.dateStr).map(x => ({
                  i: x.id, c: x.clientId, s: x.start, e: x.end, st: x.status
              }));
              DataManager.fetchFromServer('sync_day', { date: s.dateStr, day_data: payload });
          }
      }
      DataManager.saveLocally();
      closeAllSheets();
      reRenderBlocks();
  }

  // ==========================================
  // UI UTILS
  // ==========================================
  function renderTimeColumn() { 
      const col=document.getElementById('timeColumn'); 
      col.innerHTML='<div class="time-line-badge" id="timeLineBadge">00:00</div>'; 
      for(let i=0;i<24;i++) col.innerHTML+=`<div class="time-label" style="height:${GRID_H}px"><span>${String(i).padStart(2,'0')}:00</span></div>`; 
  }
  
  function renderDayRange(from, to) {
      const track = document.getElementById('daysHeaderTrack');
      const grid = document.getElementById('gridColumns');
      const base = new Date(); base.setHours(0,0,0,0);
      const weekDays = ['ПН','ВТ','СР','ЧТ','ПТ','СБ','ВС'];
      const todayStr = getLocalDateStr(new Date());

      for(let i=from; i<=to; i++) {
          const d = new Date(base); d.setDate(d.getDate()+i);
          const dateStr = getLocalDateStr(d);
          let dayIdx = d.getDay()-1; if(dayIdx===-1) dayIdx=6;
          
          const h = document.createElement('div');
          h.className = `day-col-header ${dateStr===todayStr?'today':''}`;
          h.id = `header-${dateStr}`;
          h.setAttribute('data-date', dateStr);
          h.innerHTML = `<div class="dch-day">${weekDays[dayIdx]}</div><div class="dch-num">${d.getDate()}</div><div class="dch-stats" id="stat-${dateStr}"><div class="dch-stats-fill"></div></div>`;
          h.onclick = () => openDayOptions(dateStr, `${weekDays[dayIdx]} ${d.getDate()}`);
          track.appendChild(h);
          
          const c = document.createElement('div');
          c.className = `day-column ${dateStr===todayStr?'today':''}`;
          c.setAttribute('data-date', dateStr);
          c.setAttribute('data-day-idx', dayIdx);
          c.onclick = (e) => { if(e.target===c) openAddSession(d); };
          // Attach Long Press
          let timer;
          c.addEventListener('touchstart', (e)=>{ 
              if(e.target !== c) return;
              timer = setTimeout(()=>{
                  const rect=c.getBoundingClientRect();
                  const y = e.touches[0].clientY - rect.top;
                  const h = Math.floor(y/GRID_H);
                  const newD = new Date(d); newD.setHours(h,0);
                  openAddSession(newD);
              }, 600);
          }, {passive:true});
          c.addEventListener('touchend', ()=>{ clearTimeout(timer); });
          c.addEventListener('touchmove', ()=>{ clearTimeout(timer); });
          
          grid.appendChild(c);
      }
  }

  function startClock() { 
      setInterval(() => {
          const n = new Date();
          const top = (n.getHours()*60 + n.getMinutes())/60 * GRID_H;
          const line = document.getElementById('globalTimeLine');
          if(line) { line.style.top = top+'px'; line.style.display = 'block'; }
          const badge = document.getElementById('timeLineBadge');
          if(badge) { badge.style.top = top+'px'; badge.textContent = `${String(n.getHours()).padStart(2,'0')}:${String(n.getMinutes()).padStart(2,'0')}`; badge.style.display = 'block'; }
      }, 60000); 
  }

  // Sheets
  function openAddSession(d) {
      editingId = null; editingPatternId = null;
      document.getElementById('inpDate').value = getLocalDateStr(d);
      document.getElementById('inpClient').value = '';
      document.getElementById('inpStart').value = '12:00'; document.getElementById('inpEnd').value = '13:00';
      document.getElementById('patternInfoBox').style.display='none';
      document.getElementById('btnDelete').style.display='none';
      populateClientDatalist();
      openSheet('sessionSheet');
  }

  function openEdit(data) {
      if(data.type === 'ghost') { editingPatternId = data.id; editingId = null; }
      else { editingId = data.id; editingPatternId = null; }
      
      const sessionData = data.originalData;
      document.getElementById('inpClient').value = data.clientName;
      // Ghost dates are tricky, for now we use the column date it was clicked on
      document.getElementById('inpDate').value = (data.type === 'ghost') ? (data.originalData.dateStr || document.querySelector('.day-column').getAttribute('data-date')) : sessionData.dateStr;
      
      document.getElementById('inpStart').value = data.start;
      document.getElementById('inpEnd').value = data.end;
      
      const pBox = document.getElementById('patternInfoBox');
      pBox.style.display = (data.type === 'ghost') ? 'flex' : 'none';
      
      document.getElementById('btnDelete').style.display = 'block';
      populateClientDatalist();
      openSheet('sessionSheet');
  }
  
  function populateClientDatalist() {
      const l = document.getElementById('clientList'); l.innerHTML = '';
      clients.forEach(c => { const o = document.createElement('option'); o.value = c.name; l.appendChild(o); });
  }
  
  function openSheet(id) { document.getElementById('overlay').classList.add('active'); document.getElementById(id).classList.add('open'); }
  function closeAllSheets() { document.getElementById('overlay').classList.remove('active'); document.querySelectorAll('.sheet').forEach(s => s.classList.remove('open')); }
  function showToast(m, s) { const t=document.getElementById('toast'); t.querySelector('span').textContent=s?'Успешно':'Внимание'; document.getElementById('toastMessage').textContent=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); }
  function openSettings() { openSheet('settingsSheet'); }
  function openDayOptions(d, t) { selectedDayForOptions=d; document.getElementById('dayOptionsTitle').textContent=t; openSheet('dayOptionsSheet'); }
  function openPatternEditor() { openSheet('patternEditor'); }
  function closePatternEditor() { closeAllSheets(); }
  function openRangesSheet() { openSheet('rangesSheet'); }
  function openActionSheet(type) { const s = document.getElementById('actionSheet'); const o = document.getElementById('actionSheetOverlay'); s.classList.add('open'); o.classList.add('active'); }
  function closeActionSheet() { document.getElementById('actionSheet').classList.remove('open'); document.getElementById('actionSheetOverlay').classList.remove('active'); }

</script>

</body>
</html>
