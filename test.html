<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>План vs Факт — диаграмма отклонений (мобайл)</title>
    <style>
      /* ===== COSMETICS: шрифты, размеры, радиусы, цвета (настраиваемые переменные) ===== */
      :root{
        /* Типографика */
        --font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
        --name-size: 12px;         /* размер названия метрики */
        --name-weight: 400;        /* толщина названия */
        --meta-size: 12px;         /* размер «Факт | План | ∆» */
        --value-size: 14px;        /* размер чисел */
        --value-weight: 800;       /* толщина чисел */
        --line-name: 1.25;

        /* Геометрия полос */
        --gauge-height: 28px;      /* высота серой плановой полосы */
        --plan-radius: 6px;        /* радиус плана */
        --fact-radius: 3px;        /* радиус факта */
        --fact-height: 50%;        /* толщина факта относительно плана */

        /* Цвета текста */
        --text:#ffffff;
        --muted:rgba(255,255,255,.75);

        /* Цвета факта */
        --fact-green:#22c55e;      /* недобор (∆ > 0) */
        --fact-orange:#f59e0b;     /* перебор (∆ < 0) */
        --fact-red:#ef4444;        /* спец. для % Жира и Талии при переборе (fact>plan) */

        /* Цвета плана */
        --plan-fill: rgba(255,255,255,.38);
        --plan-border: rgba(255,255,255,.52);

        /* Обводка, тени */
        --fact-contour: rgba(255,255,255,.95);
        --shadow:0 8px 24px rgba(27,35,78,.22);

        /* Фон страницы */
        --page-grad-from:#7B6EF6;
        --page-grad-to:#6F7FF0;

        /* Внешние поля страницы */
        --outer-pad: clamp(12px, 4.5vw, 18px);
      }

      *{box-sizing:border-box}
      body{
        margin:0; color:var(--text);
        font-family:var(--font-family);
        -webkit-font-smoothing:antialiased;
        min-height:100vh;
        background:linear-gradient(180deg,var(--page-grad-from) 0%,var(--page-grad-to) 100%);
        background-attachment:fixed;
      }
      /* Контейнер страницы с безопасными отступами по краям, как в демо */
      .page{
        padding: var(--outer-pad);
        padding-left: max(var(--outer-pad), env(safe-area-inset-left));
        padding-right: max(var(--outer-pad), env(safe-area-inset-right));
        padding-top: max(var(--outer-pad), env(safe-area-inset-top));
        padding-bottom: max(var(--outer-pad), env(safe-area-inset-bottom));
      }
      .card{max-width:680px;margin:clamp(8px,4vw,20px) auto;padding:12px;border-radius:20px;
        background:linear-gradient(180deg,rgba(255,255,255,.22) 0%,rgba(255,255,255,.14) 100%);
        backdrop-filter:blur(22px) saturate(1.35);
        border:1.5px solid rgba(255,255,255,.45);
        box-shadow:var(--shadow);
      }

      /* Контейнер со скроллом: показываем 5 строк, остальное прокручивается */
      .scroller{position:relative;overflow:auto;-webkit-overflow-scrolling:touch;overscroll-behavior:contain;scroll-snap-type:y proximity;border-radius:16px}
      /* подсказка: прыгающая стрелка, как намёк на скролл */
      .scroll-hint{position:relative;left:auto;bottom:auto;transform:none;margin:10px auto 0;opacity:.65;pointer-events:none;transition:opacity .2s ease;animation:hint-bounce 1.2s infinite;width:18px;height:18px}
      .scroll-hint.hidden{opacity:0;animation:none;height:0;margin-top:0;overflow:hidden}
      .scroll-hint svg{display:block;width:18px;height:18px;filter:drop-shadow(0 1px 2px rgba(0,0,0,.25))}
      @keyframes hint-bounce{0%,100%{transform:translateY(0)}50%{transform:translateY(4px)}}
      /* визуальный намёк на скролл: нижний фейд показывается, когда есть скрытый контент */
      
      

      /* Единая стеклянная панель */
      .list{display:flex;flex-direction:column;gap:0;padding:8px 10px;border-radius:16px;overflow:hidden;
        background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.06));
        border:1px solid rgba(255,255,255,.30);
      }
      .row{display:flex;flex-direction:column;gap:8px;padding:10px 4px;scroll-snap-align:start}
      .row+.row{border-top:1px solid rgba(255,255,255,.22);margin-top:8px;padding-top:16px}

      /* Заголовок строки */
      .top{display:flex;align-items:baseline;justify-content:flex-start;gap:10px;flex-wrap:wrap}
      .name{font-size: var(--name-size) !important; font-weight: var(--name-weight) !important; line-height: var(--line-name)}
      .vals{display:flex;flex-wrap:wrap;gap:4px;font-size:var(--meta-size);line-height:1.25}
      .vals .kv{display:inline-flex;align-items:baseline;gap:2px}
      .vals .lab{color:var(--muted);margin-right:2px}
      .vals .val{font-weight:var(--value-weight);font-size:var(--value-size)}
      .dot{color:var(--muted);margin:0 2px}

      /* Полосы: план (серый), факт (зелёный/оранжевый) */
      .gauge{position:relative;height:var(--gauge-height);border-radius:var(--plan-radius)}
      .plan{position:absolute;inset:0 auto 0 0;width:var(--wp,0%);border-radius:var(--plan-radius);
        background:var(--plan-fill);border:1px solid var(--plan-border);
        box-shadow:inset 0 -1px 0 rgba(255,255,255,.18);z-index:1}
      .fact{position:absolute;left:0;top:50%;transform:translateY(-50%);height:var(--fact-height);width:var(--wf,0%);
        min-width:6px;border-radius:var(--fact-radius);border:1px solid var(--fact-contour);
        /* Фолбэк для старых устройств (без color-mix) — будет использован, если следующий блок @supports не сработает */
        background: var(--fact-green);
        box-shadow:inset 0 -1px 0 rgba(255,255,255,.16),0 10px 24px -14px rgba(9,25,52,.55);
        transform-origin:left center;transition:width .22s ease;z-index:2}
      .fact.orange{ background: var(--fact-orange); }
      .fact.red{ background: var(--fact-red); }

      /* Улучшенная заливка для современных движков */
      @supports (background: color-mix(in oklab, white 50%, black)){
        .fact{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
                           color-mix(in oklab,var(--fact-green) 88%, transparent); }
        .fact.orange{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
                                   color-mix(in oklab,var(--fact-orange) 88%, transparent); }
        .fact.red{ background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
                                   color-mix(in oklab,var(--fact-red) 88%, transparent); }
      }

      .fact.neutral{ /* когда delta нет — нейтральный вид */
        background: rgba(255,255,255,.08);
        border-color: rgba(255,255,255,.6);
        box-shadow: inset 0 -1px 0 rgba(255,255,255,.12);
      }

      .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
      @media (prefers-reduced-motion:reduce){.fact{transition:none}}
    </style>
  </head>
  <body>
    <div class="page">
      <div class="card" id="pfHApp" role="region" aria-label="План против факта — диаграмма отклонений">
      <div class="scroller" id="scroller">
        <div class="list" id="rows"></div>
      </div>
      <div class="scroll-hint" id="scrollHint" aria-hidden="true">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M6 9l6 6 6-6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </div>
      <div class="sr-only" id="live" aria-live="polite"></div>
    </div>
    </div>

    <!-- ТЕСТОВЫЕ ДАННЫЕ. ВНИМАНИЕ: НЕТ НИ ОДНОГО <script type="application/json"> -->
    <template id="pfData">{ "fat": { "unit": "%", "plan": 18, "fact": 23, "delta": -5 }, "neck": { "unit": "см", "plan": 39, "fact": 42, "delta": -3 }, "shoulders": { "unit": "см", "plan": 140, "fact": 127, "delta": 13 }, "chest": { "unit": "см", "plan": 115, "fact": 115, "delta": 0 }, "waist": { "unit": "см", "plan": 89, "fact": 91, "delta": -2 }, "hips": { "unit": "см", "plan": 102, "fact": 100, "delta": 2 }, "thigh": { "unit": "см", "plan": 62, "fact": 58, "delta": 4 }, "calf": { "unit": "см", "plan": 44, "fact": 35, "delta": 9 }, "bicep": { "unit": "см", "plan": 44, "fact": 41, "delta": 3 } }</template>

    <template id="pfData_missingDelta">{ "fat": { "unit": "%", "plan": 18, "fact": 23 }, "neck": { "unit": "см", "plan": 39, "fact": 42 }, "shoulders": { "unit": "см", "plan": 140, "fact": 127 }, "chest": { "unit": "см", "plan": 115, "fact": 115 }, "waist": { "unit": "см", "plan": 89, "fact": 91 }, "hips": { "unit": "см", "plan": 102, "fact": 100 }, "thigh": { "unit": "см", "plan": 62, "fact": 58 }, "calf": { "unit": "см", "plan": 44, "fact": 35 }, "bicep": { "unit": "см", "plan": 44, "fact": 41 } }</template>

    <template id="pfData_extreme">{ "fat": { "unit": "%", "plan": 15, "fact": 35, "delta": -20 }, "neck": { "unit": "см", "plan": 39, "fact": 39, "delta": 0 }, "shoulders": { "unit": "см", "plan": 140, "fact": 160, "delta": -20 }, "chest": { "unit": "см", "plan": 115, "fact": 100, "delta": 15 }, "waist": { "unit": "см", "plan": 89, "fact": 120, "delta": -31 }, "hips": { "unit": "см", "plan": 102, "fact": 102, "delta": 0 }, "thigh": { "unit": "см", "plan": 62, "fact": 50, "delta": 12 }, "calf": { "unit": "см", "plan": 44, "fact": 30, "delta": 14 }, "bicep": { "unit": "см", "plan": 44, "fact": 60, "delta": -16 } }</template>

    <!-- ДОП. ТЕСТ №4: минимальный набор (проверка устойчивости разметки) -->
    <template id="pfData_minimal">{ "fat": { "unit": "%", "plan": 20, "fact": 22, "delta": -2 }, "bicep": { "unit": "см", "plan": 44, "fact": 41, "delta": 3 } }</template>

    <!-- ДОП. ТЕСТ №5: пустой шаблон (не должен ломать рендер) -->
    <template id="pfData_empty"></template>

    <script>
      (function(){
        const LABELS = { fat:'% Жира', neck:'Шея', shoulders:'Плечи', chest:'Грудь', waist:'Талия', hips:'Бёдра/Ягодицы', thigh:'Бедро', calf:'Икра', bicep:'Бицепс' };
        const ORDER = ['fat','neck','shoulders','chest','waist','hips','thigh','calf','bicep'];

        // Telegram Mini App / WebApp Haptics + fallback
        const TG = (typeof window !== 'undefined' && window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
        try { TG && TG.ready && TG.ready(); } catch(_){}
        const HAPTICS = {
          enabled: true,
          impact: function(type){ try{ if(!this.enabled) return; if(TG && TG.HapticFeedback && TG.HapticFeedback.impactOccurred){ TG.HapticFeedback.impactOccurred(type||'light'); return; } if('vibrate' in navigator) navigator.vibrate(10);}catch(e){} },
          selection: function(){ try{ if(!this.enabled) return; if(TG && TG.HapticFeedback && TG.HapticFeedback.selectionChanged){ TG.HapticFeedback.selectionChanged(); return; } if('vibrate' in navigator) navigator.vibrate(6);}catch(e){} },
          edge: function(){ this.impact('light'); },
          notify: function(kind){ try{ if(!this.enabled) return; if(TG && TG.HapticFeedback && TG.HapticFeedback.notificationOccurred){ TG.HapticFeedback.notificationOccurred(kind||'success'); return; } if('vibrate' in navigator) navigator.vibrate([8,60,8]); }catch(e){} }
        };

        function parseJSONFromTemplate(id){
          const el = document.getElementById(id);
          if (!el || el.tagName !== 'TEMPLATE') return null;
          // В некоторых окружениях textContent у <template> может быть пустым — берём content.textContent
          let raw = '';
          if (el.content && typeof el.content.textContent === 'string') {
            raw = el.content.textContent;
          } else {
            raw = el.textContent || '';
          }
          raw = raw.trim();
          // Если блок пустой или не похож на JSON — не пытаемся парсить
          if (!raw || (raw[0] !== '{' && raw[0] !== '[')) return null;
          try {
            return JSON.parse(raw);
          } catch (e) {
            console.error('Bad JSON in <template>#' + id, e);
            return null;
          }
        }

        function toRows(json){
          var rows=[]; if(!json) return rows;
          for(var i=0;i<ORDER.length;i++){
            var key = ORDER[i];
            var it = json[key];
            if(!it) continue;

            var unit = it.unit || (key==='fat' ? '%' : 'см');
            // Берём «как есть» без дефолта в 0: если нет числа — строку не показываем
            var planRaw = (it.plan != null ? it.plan : it.target);
            var factRaw = (it.fact != null ? it.fact : it.actual);
            var plan = Number(planRaw);
            var fact = Number(factRaw);
            if(!isFinite(plan) || !isFinite(fact)) continue; // <— требование: если нет числа, НЕ показываем строку

            var delta = (it.hasOwnProperty('delta') && isFinite(Number(it.delta))) ? Number(it.delta) : null;
            rows.push({ key: key, label: (LABELS[key]||key), unit: unit, target: plan, actual: fact, delta: delta });
          }
          return rows;
        }

        function render(el, initialData){
          var state = { data: initialData };
          var rowsEl = el.querySelector('#rows');
          var live = el.querySelector('#live');
          var scroller = el.querySelector('#scroller');

          // --- Haptics wiring (snap + edges) ---
          var hObs = null, lastSnapIndex = -1, edgeLock = false;
          function onScrollEdge(){
            if(edgeLock) return;
            var atTop = scroller.scrollTop <= 0;
            var atBottom = Math.ceil(scroller.scrollTop + scroller.clientHeight) >= scroller.scrollHeight;
            if(atTop || atBottom){ edgeLock = true; HAPTICS.edge(); setTimeout(function(){ edgeLock=false; }, 400); }
          }
          function setupHaptics(){
            if(hObs && hObs.disconnect) hObs.disconnect();
            lastSnapIndex = -1; hObs = null;
            var rows = Array.prototype.slice.call(rowsEl.querySelectorAll('.row'));
            if(!rows.length || !('IntersectionObserver' in window)) return;
            hObs = new IntersectionObserver(function(entries){
              entries.forEach(function(en){
                if(en.isIntersecting && en.intersectionRatio > 0.95){
                  var idx = rows.indexOf(en.target);
                  if(idx !== -1 && idx !== lastSnapIndex){ lastSnapIndex = idx; HAPTICS.selection(); }
                }
              });
            }, { root: scroller, threshold: [0.5, 0.95, 1] });
            rows.forEach(function(r){ hObs.observe(r); });
          }

          function buildDomains(list){
            var cmMax = 0; for(var i=0;i<list.length;i++){ var d=list[i]; var u=(d.unit||'').trim(); if(u!=='%') cmMax=Math.max(cmMax, (d.target||0), (d.actual||0)); }
            return { '%':100, 'см':cmMax||1, 'cm':cmMax||1 };
          }

          function draw(){
            var data = state.data || []; var maxByUnit = buildDomains(data); rowsEl.innerHTML='';
            for(var i=0;i<data.length;i++){
              var d = data[i]; var delta = (isFinite(d.delta) ? d.delta : null); var unitMax = maxByUnit[(d.unit||'').trim()] || 1;
              var wp = Math.max(0, Math.min(100, ((d.target||0)/unitMax)*100));
              var wf = Math.max(0, Math.min(100, ((d.actual||0)/unitMax)*100));

              var row = document.createElement('div'); row.className='row';
              var top = document.createElement('div'); top.className='top';
              top.innerHTML = '<span class="name">'+(d.key==='fat' ? (LABELS[d.key]||d.label) : (d.label+' ('+d.unit+')'))+'</span>'+
                '<span class="vals">'+
                  '<span class="kv"><span class="lab">Факт:</span> <b class="val">'+fmtNoUnit(d.actual)+'</b></span>'+
                  '<span class="dot">•</span>'+
                  '<span class="kv"><span class="lab">План:</span> <b class="val">'+fmtNoUnit(d.target)+'</b></span>'+
                  '<span class="dot">•</span>'+
                  '<span class="kv"><span class="lab">∆:</span> <b class="val">'+fmtDeltaNoUnit(delta)+(isFinite(delta)? (delta>0? ' ▲' : (delta<0? ' ▼' : '')) : '')+'</b></span>'+
                '</span>';

              var g = document.createElement('div'); g.className='gauge';
              var plan = document.createElement('div'); plan.className='plan'; plan.style.setProperty('--wp', wp+'%');
              var fact = document.createElement('div'); fact.className='fact'; fact.style.setProperty('--wf', wf+'%');
              if (isFinite(delta)) {
              if (d.key === 'fat' || d.key === 'waist') {
                if (d.actual > d.target) fact.classList.add('red'); // перебор жира/талии — плохо
                // недобор/равно — зелёный (норма/хорошо)
              } else {
                if (d.actual < d.target) fact.classList.add('orange'); // недобор по мышцам — предупреждение
                // перебор по мышцам — зелёный (норма/хорошо)
              }
            } else { fact.classList.add('neutral'); }

              g.appendChild(plan); g.appendChild(fact); row.appendChild(top); row.appendChild(g);

              (function(d){ row.addEventListener('click', function(){ live.textContent = d.label+': план '+fmt(d.target,d)+', факт '+fmt(d.actual,d)+', отклонение '+fmtDelta(delta,d); HAPTICS.selection(); }); })(d);
              rowsEl.appendChild(row);
            }
            limitToRows(5); updateHint(); setupHaptics();
          }

          function limitToRows(n){
            var items = rowsEl.children; var rows=[]; for(var i=0;i<items.length;i++){ if(items[i].classList.contains('row')) rows.push(items[i]); }
            if(!rows.length) return; var csList = getComputedStyle(rowsEl); var maxH = parseFloat(csList.paddingTop) + parseFloat(csList.paddingBottom);
            for(var i=0;i<Math.min(n,rows.length);i++){ var r=rows[i]; var cs=getComputedStyle(r); maxH += r.offsetHeight + parseFloat(cs.marginTop||0) + parseFloat(cs.marginBottom||0); }
            maxH += 2; scroller.style.maxHeight = Math.ceil(maxH) + 'px';
          }

          function updateHint(){
            var hint = el.querySelector('#scrollHint'); if(!hint) return;
            var hasMore = scroller.scrollHeight > scroller.clientHeight + 2;
            var nearBottom = Math.ceil(scroller.scrollTop + scroller.clientHeight) >= scroller.scrollHeight - 2;
            hint.classList.toggle('hidden', !hasMore || nearBottom);
          }
          window.addEventListener('resize', function(){ limitToRows(5); updateHint(); });
          scroller.addEventListener('scroll', updateHint, { passive:true });
          scroller.addEventListener('scroll', onScrollEdge, { passive:true });

          function fmt(n,d){ return d.unit==='%' ? (round(n,1)+'%') : (round(n,1)+' '+d.unit); }
          function fmtDelta(n,d){ if(!isFinite(n)) return '—'; var s=n>0?'+':''; return d.unit==='%'? (s+round(n,1)+' п.п.') : (s+round(n,1)+' '+d.unit); }
          function fmtNoUnit(n){ return round(n,1); }
          function fmtDeltaNoUnit(n){ if(!isFinite(n)) return '—'; var s=n>0?'+':''; return s+round(n,1); }
          function round(n,p){ var m=Math.pow(10, (p||1)); return Math.round(n*m)/m; }

          draw();

          return { setData:function(json){ state.data = toRows(json); draw(); } };
        }

        // Инициализация данных (strict без JSON-скриптов)
        var container = document.getElementById('pfHApp');
        var params = new URLSearchParams(location.search);
        var caseName = (params.get('case')||'').toLowerCase();
        // toggle haptics: add ?haptics=0 to URL to disable
        if (typeof HAPTICS !== 'undefined') { HAPTICS.enabled = params.get('haptics') !== '0'; }

        var input = null;
        if(typeof window !== 'undefined' && window.PLAN_FACT_JSON){ input = window.PLAN_FACT_JSON; }
        else if(caseName === 'missing'){ input = parseJSONFromTemplate('pfData_missingDelta'); }
        else if(caseName === 'extreme'){ input = parseJSONFromTemplate('pfData_extreme'); }
        else if(caseName === 'minimal'){ input = parseJSONFromTemplate('pfData_minimal'); }
        else if(caseName === 'empty'){ input = parseJSONFromTemplate('pfData_empty'); }
        else { input = parseJSONFromTemplate('pfData'); }
        // Guard: если парсинг не удался или шаблон пуст — используем пустой объект, чтобы не падать
        if (input == null) { console.warn('pf: template data is null/empty — using {}'); input = {}; }

        var api = render(container, toRows(input||{}));
        if(typeof window!== 'undefined'){
          window.PlanFactChart = { mount:function(el, json){ return render(el, toRows(json)); }, setData:function(json){ api && api.setData(json); } };
        }
      })();
    </script>
  </body>
</html>
