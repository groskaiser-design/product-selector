<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no,maximum-scale=1" />
  <title>FoodCam ‚Äî —Ñ–æ—Ç–æ –µ–¥—ã</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root { --bg:#fff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --danger:#ef4444; }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;-webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;touch-action:pan-y pan-x}
    video,canvas,img{touch-action:none;user-select:none;-webkit-user-select:none}
    /* Keep camera video producing frames even when hidden (Android WebView quirk) */
    #video.hidden{display:block!important;width:100%;height:100%;position:absolute;inset:0;opacity:0;pointer-events:none}
    .container{max-width:760px;margin:0 auto;padding:16px}
    .hidden{display:none!important} .row{display:flex;gap:10px;flex-wrap:wrap}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer;font-size:16px}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent} .btn[disabled]{opacity:.45;cursor:not-allowed}
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4;contain:layout paint}
    .cam-preview{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .3s ease}
    .cam-photo{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000}
    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    .grid{position:absolute;inset:0;opacity:.15;background:linear-gradient(#fff 1px,transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,linear-gradient(#fff 1px,transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}
    .topbar{position:absolute;left:0;right:0;top:16px;display:flex;justify-content:center;gap:10px;z-index:9;padding:0 12px}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.65);color:#fff;font-size:13px;backdrop-filter:blur(8px);max-width:calc(100% - 24px);text-align:center}
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(0,0,0,.5);backdrop-filter:blur(4px);font-size:20px;cursor:pointer}
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:140px;height:140px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.1);width:30px;height:30px}
    .level-target.ok{border-color:#34d399;background:rgba(34,197,94,.15)}
    .level-bubble{position:absolute;left:50%;top:50%;width:20px;height:20px;border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.4)}
    .level-bubble.ok{background:#22c55e}
    .card-guide{position:absolute;right:12px;top:50%;transform:translateY(-50%);width:100px;height:160px;border-radius:12px;border:2px dashed rgba(255,255,255,.4);background:rgba(128,128,128,.2);pointer-events:none;display:flex;align-items:center;justify-content:center;color:rgba(255,255,255,.7);font-size:11px;text-align:center;padding:8px;backdrop-filter:blur(2px)}
    .indicators{position:absolute;left:0;right:0;bottom:96px;display:flex;gap:10px;justify-content:center;z-index:9;pointer-events:none}
    .ind{pointer-events:auto;display:flex;align-items:center;gap:8px;padding:6px 10px;border-radius:12px;background:rgba(0,0,0,.6);border:1px solid rgba(255,255,255,.2);color:#fff;backdrop-filter:blur(4px);font-size:13px}
    .ind .bulb{width:10px;height:10px;border-radius:50%;background:#f59e0b;box-shadow:0 0 0 2px rgba(0,0,0,.3) inset}
    .ind.ok .bulb{background:#22c55e}
    .controls{position:absolute;left:0;right:0;bottom:0;padding:16px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top,rgba(0,0,0,.6),rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:50%;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 4px 16px rgba(0,0,0,.3);transition:transform .1s}
    .shutter:active:not([disabled]){transform:scale(.95)} .shutter[disabled]{opacity:.4;cursor:not-allowed;border-color:rgba(255,255,255,.5)}
    .meta{color:var(--muted);font-size:13px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px;margin-top:12px}
    .textarea{width:100%;min-height:72px;resize:vertical;padding:10px 12px;border:1px solid var(--ring);border-radius:12px;font:inherit;line-height:1.4}
    .helper{color:var(--muted);font-size:13px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0;font-size:14px}
    .btn-permission{position:absolute;right:12px;top:12px;z-index:10;pointer-events:auto;padding:8px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(245,158,11,.8);backdrop-filter:blur(4px);font-size:18px;cursor:pointer;animation:pulse 2s infinite}
    @keyframes pulse{0%,100%{opacity:1}50%{opacity:.7}}
  </style>
</head>
<body>
  <main class="container">
    <div id="err" class="error hidden"></div>

    <section id="sec-main">
      <input id="file-cam" type="file" accept="image/*" capture="environment" class="hidden" />
      <input id="file-gallery" type="file" accept="image/*" class="hidden" />

      <div class="cam-wrap" id="camWrap" aria-label="–ö–∞–º–µ—Ä–∞">
        <video id="video" class="hidden" playsinline muted autoplay></video>
        <canvas id="preview" class="cam-preview" aria-label="–ü—Ä–µ–≤—å—é –∫–∞–º–µ—Ä—ã" role="img"></canvas>
        <img id="photo" class="cam-photo hidden" alt="–°–Ω–∏–º–æ–∫" />

        <div id="overlay" class="cam-overlay">
          <div class="grid" aria-hidden="true"></div>
          <div class="topbar"><div id="chipInfo" class="chip" role="status" aria-live="polite">–î–µ—Ä–∂–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω —Ä–æ–≤–Ω–æ</div></div>
          <button id="btnTorch" class="btn-torch hidden" aria-label="–§–æ–Ω–∞—Ä–∏–∫" aria-pressed="false">üí°</button>
          <button id="btnPermission" class="btn-permission hidden" aria-label="–†–∞–∑—Ä–µ—à–∏—Ç—å –¥–∞—Ç—á–∏–∫–∏">‚ö†Ô∏è</button>
          <div class="center-level" aria-hidden="true">
            <div class="level-outer" id="levelOuter">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>
          <div class="card-guide"><span>–ö–∞—Ä—Ç–∞<br>(–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)</span></div>
          <div class="indicators"><div id="indLevel" class="ind"><span class="bulb"></span><span class="label">–†–æ–≤–Ω–æ</span></div></div>
        </div>

        <div id="controls" class="controls">
          <button id="btnShot" class="shutter" aria-label="–°–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫" disabled></button>
        </div>
      </div>

      <div class="field">
        <label for="comment" class="helper">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –ø–æ–≤—ã—Å–∏—Ç —Ç–æ—á–Ω–æ—Å—Ç—å)</label>
        <textarea id="comment" class="textarea" maxlength="200" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: —Ç—Ä–µ—Å–∫–∞ 150–≥, —Ä–∏—Å 200–≥"></textarea>
        <div id="commentWarn" class="helper hidden"></div>
      </div>

      <div class="row" style="margin-top:12px">
        <button id="btnRetake" class="btn" disabled>–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
        <button id="btnGallery" class="btn">–ì–∞–ª–µ—Ä–µ—è</button>
        <button id="btnSend" class="btn primary" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </div>
    </section>
  </main>

  <script>
  'use strict';
  const PERM_KEY = 'fc_motion_perm_v1';

  // ==================== PLATFORM ====================
  const PLATFORM = {
    isIOS: /iP(hone|od|ad)/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1),
    isAndroid: /Android/.test(navigator.userAgent),
    isSafari: /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent),
    memoryGB: navigator.deviceMemory || 8
  };

  // ==================== CONFIG ====================
  const CONFIG = {
    idealFacing: { facingMode: { ideal: 'environment' }, aspectRatio: { ideal: 3/4 }, height: { ideal: 1920 }, width: { ideal: 1440 } },
    previewScale: 1, previewFPS: 30, preferImageCapture: !PLATFORM.isIOS,
    maxPhotoSide: 8192, jpegQuality: 0.95,
    bubbleRadius: 10, targetRadius: 15, levelRadius: 50,
    needsPermissionRequest: PLATFORM.isIOS, sensorStaleMs: 4000,
    tiltSmoothing: 0.15, orientationStaleMs: 400
  };

  // ==================== STATE ====================
  const STATE = {
    stream:null, track:null, videoElement:null, imageCapture:null,
    hasTorch:false, torchOn:false,
    sensorsEnabled:false, lastSensorTime:0, sensorWatchdog:null,
    rawNx:0, rawNy:0, levelOK:false,
    currentView:'camera', lastBlob:null, capturing:false,
    previewRunning:false, previewRaf:null, lastPreviewTime:0,
    wakeLock:null, screenAngle:0,
    lastCropRect:null,
    sensorPermission:'unknown', smoothNx:0, smoothNy:0, lastOrientationEvent:0,
    levelRaf:null, lastGrabTime:0
  };

  // ==================== DOM ====================
  const $ = id => document.getElementById(id);
  const DOM = {
    err: $('err'), video: $('video'), preview: $('preview'), photo: $('photo'), overlay: $('overlay'), controls: $('controls'),
    btnShot: $('btnShot'), btnTorch: $('btnTorch'), btnPermission: $('btnPermission'), chipInfo: $('chipInfo'), fileCam: $('file-cam'), fileGallery: $('file-gallery'),
    levelBubble: $('levelBubble'), levelTarget: $('levelTarget'), levelOuter: $('levelOuter'), indLevel: $('indLevel'),  btnRetake: $('btnRetake'), btnGallery: $('btnGallery'), btnSend: $('btnSend'), comment: $('comment'), commentWarn: $('commentWarn'), camWrap: $('camWrap')
  };

  const previewCtx = DOM.preview.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:true });

  // ==================== UTIL ====================
  const sleep = ms => new Promise(r => setTimeout(r, ms));
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{}
  }
  function setError(msg){ if(!msg){ DOM.err.classList.add('hidden'); DOM.err.textContent=''; return;} DOM.err.textContent=msg; DOM.err.classList.remove('hidden'); }
  function sanitizeComment(input){ return String(input||'').slice(0,200).replace(/<[^>]*>/g,'').replace(/[\u0000-\u001F\u007F-\u009F]/g,'').replace(/(javascript:|data:|vbscript:|<script|on\w+=)/gi,'').replace(/[^\w\s\.,!?:;"'()\-\[\]{}#@+/&%–ê-–Ø–∞-—è–Å—ë]/g,'').replace(/\s+/g,' ').trim(); }
  function hasContent(){ return STATE.lastBlob || sanitizeComment(DOM.comment.value).length>0; }

  // ==================== UI ====================
  function updateButtons(){ DOM.btnRetake.disabled = STATE.currentView==='camera'||STATE.capturing; DOM.btnSend.disabled = !hasContent()||STATE.capturing; DOM.btnShot.disabled = !STATE.levelOK||STATE.capturing; }
  function syncLevelIndicator(){ DOM.indLevel.classList.toggle('ok',STATE.levelOK); DOM.indLevel.setAttribute('aria-label', STATE.levelOK?'–£—Ä–æ–≤–µ–Ω—å: OK':'–£—Ä–æ–≤–µ–Ω—å: –Ω–∞–∫–ª–æ–Ω'); }
  function showCameraUI(){
    STATE.currentView='camera';
    DOM.preview.classList.remove('hidden');
    DOM.overlay.classList.remove('hidden');
    DOM.controls.classList.remove('hidden');
    DOM.photo.classList.add('hidden');
    DOM.chipInfo.textContent='–î–µ—Ä–∂–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω —Ä–æ–≤–Ω–æ';
    computeLevelRadiusDeferred();
    startPreviewLoop();
    startLevelLoop();
    startSensorWatchdog();
    ensureWakeLock(true);
    updateButtons();
    syncLevelIndicator();
  }
  function showPhotoUI(){
    STATE.currentView='photo';
    DOM.preview.classList.add('hidden');
    DOM.overlay.classList.add('hidden');
    DOM.controls.classList.add('hidden');
    DOM.photo.classList.remove('hidden');
    stopPreviewLoop();
    stopLevelLoop();
    stopSensorWatchdog();
    ensureWakeLock(false);
    updateButtons();
  }

  // ==================== WAKE LOCK ====================
  async function ensureWakeLock(enable){ if(!('wakeLock'in navigator))return; try{ if(enable && !STATE.wakeLock){ STATE.wakeLock = await navigator.wakeLock.request('screen'); STATE.wakeLock.addEventListener('release',()=>{STATE.wakeLock=null}); } else if(!enable && STATE.wakeLock){ await STATE.wakeLock.release(); STATE.wakeLock=null; } }catch{ STATE.wakeLock=null; } }

  // ==================== CAMERA ====================
  async function openCamera(){
    try{
      const stream=await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ideal:'environment'}, aspectRatio:{ideal:3/4}, height:{ideal:1920}, width:{ideal:1440} }, audio:false });
      bindStream(stream);
      return true;
    } catch(err){
      console.warn('Portrait camera failed:',err);
      try{
        const stream=await navigator.mediaDevices.getUserMedia({ video:{facingMode:'environment'}, audio:false });
        bindStream(stream);
        return true;
      } catch{
        return false;
      }
    }
  }
  function bindStream(stream){
    stopCamera();
    STATE.stream=stream;
    STATE.track=stream.getVideoTracks()[0];
    STATE.videoElement=DOM.video;
    DOM.video.srcObject=stream;
    DOM.video.play().catch(()=>{});
    const trackSettings=STATE.track.getSettings?.()||{};
    const trackLabel=STATE.track.label||'unknown';
    console.log('üìπ Camera:',trackLabel,trackSettings);
    const checkResolution=()=>{
      if(DOM.video.videoWidth>0){
        const vw=DOM.video.videoWidth, vh=DOM.video.videoHeight;
        const isPortrait = vh>vw;
        const cameraName = trackLabel.includes('back')?'–∑–∞–¥–Ω—è—è': trackLabel.includes('ultra')?'ultra-wide': trackLabel.includes('tele')?'tele':'–∫–∞–º–µ—Ä–∞';
        // keep UI hint text intact; log only
        console.log(`üìπ ${vw}√ó${vh} ${isPortrait?'portrait':'landscape'} ‚Ä¢ ${cameraName}`);
      } else {
        setTimeout(checkResolution,100);
      }
    };
    setTimeout(checkResolution,200);
    const caps=STATE.track.getCapabilities?.()||{};
    STATE.hasTorch=!!caps.torch && !PLATFORM.isIOS;
    DOM.btnTorch.classList.toggle('hidden',!STATE.hasTorch);
    if(CONFIG.preferImageCapture&&typeof ImageCapture!=='undefined'){
      try{ STATE.imageCapture=new ImageCapture(STATE.track); }catch{}
    }
  }
  function stopCamera(){
    try{ DOM.video.pause(); DOM.video.srcObject=null; }catch{}
    try{ STATE.track?.stop(); }catch{}
    try{ STATE.stream?.getTracks().forEach(t=>t.stop()); }catch{}
    STATE.stream=null; STATE.track=null; STATE.imageCapture=null; STATE.torchOn=false;
  }

  // ==================== PREVIEW ====================
  async function drawPreviewFrame(){
    const video=DOM.video, canvas=DOM.preview;
    const {width:cssW,height:cssH}=DOM.camWrap.getBoundingClientRect();
    const dpr=Math.min(2,window.devicePixelRatio||1);
    const scale=CONFIG.previewScale*dpr;
    const tw=Math.max(1,Math.round(cssW*scale));
    const th=Math.max(1,Math.round(cssH*scale));
    if(canvas.width!==tw||canvas.height!==th){ canvas.width=tw; canvas.height=th; }
    previewCtx.imageSmoothingEnabled=true;
    previewCtx.imageSmoothingQuality='high';

    // Path A: draw from <video> when it reports dimensions
    if(video.videoWidth && video.videoHeight){
      const vw=video.videoWidth, vh=video.videoHeight;
      const videoAspect=vw/vh;
      const canvasAspect=tw/th;
      let sx,sy,sw,sh;
      if(videoAspect>canvasAspect){
        sh=vh; sw=Math.round(sh*canvasAspect); sx=Math.floor((vw-sw)/2); sy=0;
      } else {
        sw=vw; sh=Math.round(sw/canvasAspect); sx=0; sy=Math.floor((vh-sh)/2);
      }
      STATE.lastCropRect={sx,sy,sw,sh,videoWidth:vw,videoHeight:vh,canvasAspect};
      previewCtx.drawImage(video,sx,sy,sw,sh,0,0,tw,th);
      return;
    }

    // Path B: some Android WebViews keep videoWidth=0 when video is visually hidden.
    // If ImageCapture.grabFrame is available, use it to fetch a preview frame.
    if(STATE.imageCapture?.grabFrame && performance.now() - (STATE.lastGrabTime||0) > 120){
      try{
        const bmp = await STATE.imageCapture.grabFrame();
        STATE.lastGrabTime = performance.now();
        const vw=bmp.width, vh=bmp.height;
        const canvasAspect=tw/th;
        const videoAspect=vw/vh;
        let sx,sy,sw,sh;
        if(videoAspect>canvasAspect){
          sh=vh; sw=Math.round(sh*canvasAspect); sx=Math.floor((vw-sw)/2); sy=0;
        } else {
          sw=vw; sh=Math.round(sw/canvasAspect); sx=0; sy=Math.floor((vh-sh)/2);
        }
        STATE.lastCropRect={sx,sy,sw,sh,videoWidth:vw,videoHeight:vh,canvasAspect};
        previewCtx.drawImage(bmp,sx,sy,sw,sh,0,0,tw,th);
        bmp.close?.();
        return;
      }catch(e){ /* ignore and try next tick */ }
    }

    // Not ready yet ‚Äî skip this frame
    return;
  }
  function startPreviewLoop(){
    if(STATE.previewRunning) return;
    STATE.previewRunning=true;
    DOM.preview.style.opacity='0';
    const fps=CONFIG.previewFPS, frameTime=1000/fps;
    const tick=async()=>{
      if(!STATE.previewRunning||STATE.currentView!=='camera')return;
      const now=performance.now();
      if(now-STATE.lastPreviewTime>=frameTime){
        STATE.lastPreviewTime=now;
        try{
          await drawPreviewFrame();
          if(DOM.preview.style.opacity==='0'&&DOM.preview.width>0){ DOM.preview.style.opacity='1'; }
        }catch(err){ console.warn('Preview frame error:',err); }
      }
      STATE.previewRaf=requestAnimationFrame(tick);
    };
    STATE.previewRaf=requestAnimationFrame(tick);
  }
  function stopPreviewLoop(){ STATE.previewRunning=false; if(STATE.previewRaf){ cancelAnimationFrame(STATE.previewRaf); STATE.previewRaf=null; } }

  // ==================== CAPTURE (WYSIWYG) ====================
  function canvasToBlob(canvas,quality=CONFIG.jpegQuality){ return new Promise(r=>{ canvas.toBlob(b=>r(b),'image/jpeg',quality); }); }
  function computeCoverCropByAspect(vw,vh,canvasAspect){ let sx,sy,sw,sh; const videoAspect=vw/vh; if(videoAspect>canvasAspect){ sh=vh; sw=Math.round(sh*canvasAspect); sx=Math.floor((vw-sw)/2); sy=0; } else { sw=vw; sh=Math.round(sw/canvasAspect); sx=0; sy=Math.floor((vh-sh)/2); } return {sx,sy,sw,sh}; }
  async function captureWysiwygFromVideo(){
    const video=DOM.video; const vw=video.videoWidth, vh=video.videoHeight; if(!vw||!vh) throw new Error('Video not ready');
    if(STATE.imageCapture?.takePhoto){
      try{
        const raw=await STATE.imageCapture.takePhoto();
        const bmp=await createImageBitmap(raw);
        const aspect=STATE.lastCropRect?.canvasAspect || (DOM.preview.width&&DOM.preview.height ? (DOM.preview.width/DOM.preview.height) : (DOM.camWrap.clientWidth/DOM.camWrap.clientHeight));
        const {sx,sy,sw,sh}=computeCoverCropByAspect(bmp.width,bmp.height,aspect);
        const scale=Math.min(1,CONFIG.maxPhotoSide/Math.max(sw,sh));
        const outW=Math.max(1,Math.round(sw*scale)), outH=Math.max(1,Math.round(sh*scale));
        const c=document.createElement('canvas'); c.width=outW; c.height=outH;
        c.getContext('2d').drawImage(bmp,sx,sy,sw,sh,0,0,outW,outH);
        bmp.close?.();
        return canvasToBlob(c);
      }catch(e){ console.warn('ImageCapture failed, fallback video frame',e); }
    }
    let crop=STATE.lastCropRect;
    if(!crop||crop.videoWidth!==vw||crop.videoHeight!==vh){
      const aspect=DOM.preview.width&&DOM.preview.height ? (DOM.preview.width/DOM.preview.height) : (DOM.camWrap.clientWidth/DOM.camWrap.clientHeight);
      crop=computeCoverCropByAspect(vw,vh,aspect);
    }
    const {sx,sy,sw,sh}=crop;
    const scale=Math.min(1,CONFIG.maxPhotoSide/Math.max(sw,sh));
    const outW=Math.max(1,Math.round(sw*scale)), outH=Math.max(1,Math.round(sh*scale));
    const c=document.createElement('canvas'); c.width=outW; c.height=outH;
    c.getContext('2d').drawImage(video,sx,sy,sw,sh,0,0,outW,outH);
    return canvasToBlob(c);
  }
  async function onShutter(){ if(DOM.btnShot.disabled||STATE.capturing) return; STATE.capturing=true; updateButtons(); haptic(); try{ const blob=await captureWysiwygFromVideo(); STATE.lastBlob=blob; const url=URL.createObjectURL(blob); DOM.photo.onload=()=>{ URL.revokeObjectURL(url); }; DOM.photo.src=url; showPhotoUI(); }catch(err){ console.error('Capture failed:',err); setError('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑.'); } finally { STATE.capturing=false; updateButtons(); } }

  // ==================== TORCH ====================
  async function toggleTorch(){ if(!STATE.track||!STATE.hasTorch) return; try{ STATE.torchOn=!STATE.torchOn; await STATE.track.applyConstraints({advanced:[{torch:STATE.torchOn}]}); DOM.btnTorch.setAttribute('aria-pressed',String(STATE.torchOn)); haptic(); }catch(err){ console.warn('Torch toggle failed:',err); STATE.torchOn=false; STATE.hasTorch=false; DOM.btnTorch.classList.add('hidden'); } }

  // ==================== SENSORS ====================
  function refreshScreenAngle(){ const angle=screen.orientation?.angle??window.orientation??0; STATE.screenAngle=((angle%360)+360)%360; }
  function mapTilt(pitchDeg,rollDeg){ const maxTilt=30; const pr=Math.max(-1,Math.min(1,pitchDeg/maxTilt)); const rr=Math.max(-1,Math.min(1,rollDeg/maxTilt)); let nx=0,ny=0; switch(STATE.screenAngle){ case 0:nx=rr;ny=pr;break; case 90:nx=-pr;ny=rr;break; case 180:nx=-rr;ny=-pr;break; case 270:nx=pr;ny=-rr;break; } return {nx,ny}; }
  function onDeviceOrientation(e){
    if(STATE.currentView!=='camera') return;
    const now = performance.now();
    STATE.lastSensorTime = now;
    const pitch = e.beta ?? 0, roll = e.gamma ?? 0;
    const { nx, ny } = mapTilt(pitch, roll);
    const a = CONFIG.tiltSmoothing;
    STATE.smoothNx = STATE.smoothNx + a * (nx - STATE.smoothNx);
    STATE.smoothNy = STATE.smoothNy + a * (ny - STATE.smoothNy);
    STATE.rawNx = nx; STATE.rawNy = ny;
    STATE.lastOrientationEvent = now;
  }
  function onDeviceMotion(e){
    if(STATE.currentView!=='camera') return;
    const now = performance.now();
    STATE.lastSensorTime = now;
    // Prefer orientation events on Android; use motion only if orientation is stale
    if (now - (STATE.lastOrientationEvent||0) <= CONFIG.orientationStaleMs) return;
    const accel = e.accelerationIncludingGravity || {};
    const x = accel.x || 0, y = accel.y || 0, z = accel.z || 0;
    const pitch = (Math.atan2(-x, Math.sqrt(y*y + z*z)) * 180 / Math.PI) || 0;
    const roll  = (Math.atan2(y, z) * 180 / Math.PI) || 0;
    const { nx, ny } = mapTilt(pitch, roll);
    const a = CONFIG.tiltSmoothing;
    STATE.smoothNx = STATE.smoothNx + a * (nx - STATE.smoothNx);
    STATE.smoothNy = STATE.smoothNy + a * (ny - STATE.smoothNy);
    STATE.rawNx = nx; STATE.rawNy = ny;
  }
  function attachSensorListeners(){ try{ window.addEventListener('deviceorientation',onDeviceOrientation,{capture:true,passive:true}); }catch{ window.addEventListener('deviceorientation',onDeviceOrientation,true); } try{ window.addEventListener('devicemotion',onDeviceMotion,{capture:true,passive:true}); }catch{ window.addEventListener('devicemotion',onDeviceMotion,true); } }
  function removeSensorListeners(){ window.removeEventListener('deviceorientation',onDeviceOrientation,true); window.removeEventListener('deviceorientation',onDeviceOrientation,{ capture:true }); window.removeEventListener('devicemotion',onDeviceMotion,true); window.removeEventListener('devicemotion',onDeviceMotion,{ capture:true }); }
  async function requestSensorPermission(){ let granted=false; try{ if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const r=await DeviceOrientationEvent.requestPermission(); granted=(r==='granted'); }catch{} } if(!granted&&typeof DeviceMotionEvent!=='undefined'&&typeof DeviceMotionEvent.requestPermission==='function'){ try{ const r=await DeviceMotionEvent.requestPermission(); granted=(r==='granted'); }catch{} } }catch{} attachSensorListeners(); if(granted||!CONFIG.needsPermissionRequest){ STATE.sensorsEnabled=true; STATE.lastSensorTime=performance.now(); DOM.btnPermission.classList.add('hidden'); DOM.chipInfo.textContent='–î–µ—Ä–∂–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω —Ä–æ–≤–Ω–æ'; try{ localStorage.setItem(PERM_KEY,'granted'); }catch{} STATE.sensorPermission='granted'; } else { DOM.btnPermission.classList.remove('hidden'); try{ localStorage.setItem(PERM_KEY,'denied'); }catch{} STATE.sensorPermission='denied'; showSensorHelp(); } return granted; }
  function showSensorHelp(){ DOM.chipInfo.textContent='iOS: –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ‚Üí Safari ‚Üí –î–≤–∏–∂–µ–Ω–∏–µ –∏ –û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è'; DOM.btnPermission.classList.remove('hidden'); }
  function setupAutoSensorPermission(){ if(!PLATFORM.isIOS) return; try{ STATE.sensorPermission=localStorage.getItem(PERM_KEY)||'unknown'; }catch{ STATE.sensorPermission='unknown'; } const onFirstGesture=()=>{ if(STATE.sensorPermission!=='granted'){ requestSensorPermission(); } document.removeEventListener('pointerdown',onFirstGesture,true); document.removeEventListener('touchstart',onFirstGesture,true); document.removeEventListener('click',onFirstGesture,true); document.removeEventListener('keydown',onFirstGesture,true); }; document.addEventListener('pointerdown',onFirstGesture,true); document.addEventListener('touchstart',onFirstGesture,true); document.addEventListener('click',onFirstGesture,true); document.addEventListener('keydown',onFirstGesture,true); }
  async function enableSensors(){ if(STATE.sensorsEnabled) return true; if(!CONFIG.needsPermissionRequest){ attachSensorListeners(); STATE.sensorsEnabled=true; STATE.lastSensorTime=performance.now(); return true; } try{ STATE.sensorPermission=localStorage.getItem(PERM_KEY)||STATE.sensorPermission; }catch{} if(STATE.sensorPermission==='granted'){ attachSensorListeners(); STATE.sensorsEnabled=true; STATE.lastSensorTime=performance.now(); DOM.btnPermission.classList.add('hidden'); return true; } DOM.btnPermission.classList.remove('hidden'); return false; }
  function rebindSensors(){ removeSensorListeners(); attachSensorListeners(); STATE.lastSensorTime=performance.now(); }
  function startSensorWatchdog(){ stopSensorWatchdog(); if(!PLATFORM.isIOS)return; STATE.sensorWatchdog=setInterval(()=>{ if(STATE.currentView!=='camera')return; const stale=(performance.now()-STATE.lastSensorTime)>CONFIG.sensorStaleMs; if(stale&&STATE.sensorsEnabled){ rebindSensors(); } },1000); }
  function stopSensorWatchdog(){ if(STATE.sensorWatchdog){ clearInterval(STATE.sensorWatchdog); STATE.sensorWatchdog=null; } }

  // ==================== LEVEL UI LOOP ====================
  function computeLevelRadius(){
    const outer = DOM.levelOuter;
    if (!outer) return;
    const rect = outer.getBoundingClientRect();
    if (!rect.width || !rect.height) return;
    const rOuter = Math.min(rect.width, rect.height) * 0.5;
    CONFIG.levelRadius = Math.max(10, Math.floor(rOuter * 0.7));
  }
  function computeLevelRadiusDeferred(){ requestAnimationFrame(()=>requestAnimationFrame(computeLevelRadius)); }
  function updateLevel(){ const R=CONFIG.levelRadius; const dx=STATE.smoothNx*R, dy=STATE.smoothNy*R; DOM.levelBubble.style.transform=`translate(-50%, -50%) translate(${dx}px, ${dy}px)`; const distance=Math.hypot(dx,dy); const wasOK=STATE.levelOK; STATE.levelOK=(distance+CONFIG.bubbleRadius)<=CONFIG.targetRadius; if(STATE.levelOK!==wasOK){ DOM.levelBubble.classList.toggle('ok',STATE.levelOK); DOM.levelTarget.classList.toggle('ok',STATE.levelOK); syncLevelIndicator(); updateButtons(); } }
  function startLevelLoop(){ if(STATE.levelRaf)return; const tick=()=>{ if(STATE.currentView==='camera'){ updateLevel(); } STATE.levelRaf=requestAnimationFrame(tick); }; STATE.levelRaf=requestAnimationFrame(tick); }
  function stopLevelLoop(){ if(STATE.levelRaf){ cancelAnimationFrame(STATE.levelRaf); STATE.levelRaf=null; } }

  // ==================== FILE PICK ====================
  async function onFilePicked(e){ const file=e.target?.files?.[0]; if(!file) return; if(!file.type.startsWith('image/')){ setError('–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ'); return; } STATE.lastBlob=file; const url=URL.createObjectURL(file); DOM.photo.onload=()=>{ URL.revokeObjectURL(url); }; DOM.photo.src=url; showPhotoUI(); updateButtons(); e.target.value=''; }

  // ==================== SEND ====================
  async function onSend(){ const comment=sanitizeComment(DOM.comment.value); if(!STATE.lastBlob && !comment){ setError('–î–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π'); return; } console.log('Send:',{hasImage:!!STATE.lastBlob, comment, imageSize:STATE.lastBlob?.size}); setError('‚úÖ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ (demo mode)'); setTimeout(()=>{ startCameraFlow(); DOM.comment.value=''; setError(''); },1500); }

  // ==================== STARTUP FLOW ====================
  async function startCameraFlow(){
    stopPreviewLoop();
    stopLevelLoop();
    stopSensorWatchdog();
    STATE.lastBlob=null; STATE.capturing=false; STATE.levelOK=false; STATE.rawNx=0; STATE.rawNy=0; STATE.smoothNx=0; STATE.smoothNy=0; STATE.lastOrientationEvent=0; STATE.lastSensorTime=0;
    updateButtons(); setError('');
    refreshScreenAngle();
    if(!navigator.mediaDevices?.getUserMedia){ setError('–ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —ç—Ç–æ–º –±—Ä–∞—É–∑–µ—Ä–µ'); return; }
    const opened=await openCamera();
    if(!opened){ setError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–∞–ª–µ—Ä–µ—é.'); return; }
    await enableSensors();
    showCameraUI();
  }

  // ==================== EVENT HANDLERS ====================
  DOM.btnShot.addEventListener('click', onShutter);
  DOM.btnTorch.addEventListener('click', toggleTorch);
  DOM.btnPermission.addEventListener('click', requestSensorPermission);
  DOM.btnRetake.addEventListener('click', ()=>{ if(!DOM.btnRetake.disabled){ startCameraFlow(); } });
  DOM.btnGallery.addEventListener('click', ()=>{ DOM.fileGallery?.click(); });
  DOM.fileGallery.addEventListener('change', onFilePicked);
  DOM.fileCam.addEventListener('change', onFilePicked);
  DOM.btnSend.addEventListener('click', onSend);
  DOM.comment.addEventListener('input', ()=>{ const raw=DOM.comment.value; const safe=sanitizeComment(raw); if(raw!==safe){ DOM.commentWarn.textContent='–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–∏–º–≤–æ–ª—ã —É–¥–∞–ª–µ–Ω—ã'; DOM.commentWarn.classList.remove('hidden'); } else { DOM.commentWarn.classList.add('hidden'); } updateButtons(); });

  // ==================== LIFECYCLE ====================
  screen.orientation?.addEventListener?.('change', refreshScreenAngle);
  window.addEventListener('resize', computeLevelRadius);
  window.addEventListener('pageshow', ()=>{ if(STATE.currentView==='camera'){ STATE.lastSensorTime=0; try{ STATE.sensorPermission=localStorage.getItem(PERM_KEY)||STATE.sensorPermission; }catch{} if(PLATFORM.isIOS && STATE.sensorPermission!=='granted'){ DOM.btnPermission.classList.remove('hidden'); } } });
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible'){ if(STATE.currentView==='camera'){ STATE.lastSensorTime=0; ensureWakeLock(true); } } else { ensureWakeLock(false); } });
  window.addEventListener('beforeunload', ()=>{ stopPreviewLoop(); stopLevelLoop(); stopSensorWatchdog(); stopCamera(); removeSensorListeners(); ensureWakeLock(false); });

  // ==================== INIT ====================
  window.addEventListener('DOMContentLoaded', ()=>{
    startCameraFlow();
    setupAutoSensorPermission();

    // Observe size changes of level circle to keep radius in sync
    try{ if('ResizeObserver' in window){ const ro = new ResizeObserver(()=>computeLevelRadiusDeferred()); ro.observe(DOM.levelOuter); } }catch{}

    // Prevent pinch-zoom / double-tap zoom only inside camera area
    DOM.camWrap.addEventListener('touchstart', e=>{ if(e.touches.length>1){ e.preventDefault(); } }, {passive:false});
    DOM.camWrap.addEventListener('touchmove', e=>{ if(e.touches.length>1){ e.preventDefault(); } }, {passive:false});
    let lastTap=0; DOM.camWrap.addEventListener('touchend', e=>{ const now=Date.now(); if(now-lastTap<300){ e.preventDefault(); } lastTap=now; });

    // Telegram WebApp integration
    try{ window.Telegram?.WebApp?.ready?.(); window.Telegram?.WebApp?.expand?.(); }catch{}

    // ==================== SELF-TESTS ====================
    (function runSelfTests(){
      const tests = [];
      function t(name, fn){ try{ fn(); console.log('‚úÖ', name); tests.push({name, ok:true}); } catch(e){ console.error('‚ùå', name, e); tests.push({name, ok:false, err:e}); } }
      t('DOM elements exist', ()=>{ if(!DOM.video||!DOM.preview||!DOM.btnShot) throw new Error('Missing key DOM nodes'); });
      t('computeCoverCropByAspect wide‚Üícrop sides', ()=>{ const {sx,sy,sw,sh}=computeCoverCropByAspect(4000,2000,3/4); if(sh!==2000) throw new Error('sh'); if(sw!==1500) throw new Error('sw'); if(sx!==1250||sy!==0) throw new Error('sx/sy'); });
      t('computeCoverCropByAspect tall‚Üícrop top/bottom', ()=>{ const {sx,sy,sw,sh}=computeCoverCropByAspect(2000,4000,3/4); if(sw!==2000) throw new Error('sw'); const exp=Math.round(2000/(3/4)); if(Math.abs(sh-exp)>1) throw new Error('sh approx'); if(sx!==0) throw new Error('sx'); });
      t('capture function present', ()=>{ if(typeof captureWysiwygFromVideo!=='function') throw new Error('no capture fn'); });
      t('mapTilt bounds', ()=>{ const r0=mapTilt(0,0); if(Math.hypot(r0.nx,r0.ny)>1e-6) throw new Error('center not zero'); const r1=mapTilt(30,30); if(r1.nx<-1||r1.nx>1||r1.ny<-1||r1.ny>1) throw new Error('clamp failed'); });
      // New: updateLevel uses smoothed values (not raw)
      t('updateLevel uses smoothed tilt', ()=>{ CONFIG.levelRadius=50; STATE.smoothNx=1; STATE.smoothNy=0; STATE.rawNx=0; STATE.rawNy=0; updateLevel(); if(!DOM.levelBubble.style.transform.includes('50px')) throw new Error('not using smooth values'); });
      // New: devicemotion ignored when orientation fresh
      t('devicemotion ignored when orientation fresh', ()=>{ const prevNx=STATE.smoothNx, prevNy=STATE.smoothNy; STATE.lastOrientationEvent=performance.now(); const e={accelerationIncludingGravity:{x:100,y:100,z:100}}; onDeviceMotion(e); if(STATE.smoothNx!==prevNx||STATE.smoothNy!==prevNy) throw new Error('motion not ignored'); });
      // New: drawPreviewFrame is callable
      t('drawPreviewFrame exists', ()=>{ if(typeof drawPreviewFrame!== 'function') throw new Error('no preview'); });
      const failed = tests.some(x=>!x.ok);
      if(!failed) console.log('‚úÖ All self-tests passed');
    })();
  });
  </script>
</body>
</html>
