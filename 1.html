<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam — фото-режим</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* CAMERA AREA */
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4;contain:layout paint;}
    .cam-video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .2s ease;transform:translateZ(0);backface-visibility:hidden}
    .cam-photo{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000}

    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    /* grid */
    .grid{position:absolute;inset:0;opacity:.15;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    .topbar{position:absolute;left:0;right:0;top:64px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}

    /* Torch */
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}

    /* Level (target + dot) */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:160px;height:160px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%, -50%);border-radius:50%;border:2px solid rgba(255,255,255,.75);background:rgba(0,0,0,.15)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{
      position:absolute;left:50%;top:50%;
      transform: translate(-50%, -50%) translateZ(0);
      border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);
      will-change:transform;
      transition: background-color .12s;
    }
    .level-bubble.ok{background:#22c55e}

    /* bottom controls inside camera */
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    .meta{color:var(--muted);font-size:12px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px;margin-top:10px}
    .textarea{width:100%;min-height:68px;resize:vertical;padding:10px 12px;border:1px solid var(--ring);border-radius:12px;font:inherit;line-height:1.35}
    .helper{color:var(--muted);font-size:12px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}

    .card-area{
      position:absolute; right:12px; top:50%; transform:translateY(-50%);
      width:115px; height:183px;
      border-radius:14px;
      border:2px solid rgba(255,255,255,.95);
      background:
        repeating-linear-gradient(45deg,
          rgba(255,255,255,.18) 0 10px,
          rgba(255,255,255,0) 10px 20px);
      box-shadow:0 0 0 1px rgba(0,0,0,.15) inset;
      pointer-events:none;
    }
    .card-area.ok{ border-color:#22c55e; box-shadow:0 0 0 2px rgba(34,197,94,.45) inset }

    .indicators{position:absolute;left:0;right:0;bottom:96px;display:flex;gap:10px;justify-content:center;z-index:9;pointer-events:none}
    .ind{pointer-events:auto;display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);color:#fff;backdrop-filter:blur(2px)}
    .ind .bulb{width:12px;height:12px;border-radius:50%;background:var(--warn);box-shadow:0 0 0 2px rgba(0,0,0,.25) inset}
    .ind.ok .bulb{background:var(--ok)}
    .ind .label{font-size:12px;opacity:.95}

    /* кнопка перезапроса датчиков справа сверху */
    .btn-sensors{position:absolute;right:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}

    /* холст для аннотации (контур карты поверх фото) */
    .anno{position:absolute;inset:0;pointer-events:none;z-index:12}
  </style>
</head>
<body>
  <main class="container">
    <div id="err" class="error hidden"></div>

    <section id="sec-main">
      <!-- Фолбэки -->
      <input id="file-cam" type="file" accept="image/*" capture="environment" class="hidden" />
      <input id="file-gallery" type="file" accept="image/*" class="hidden" />

      <div class="cam-wrap" id="camWrap" aria-label="Камера и/или снимок">
        <!-- Скрытый <video> как технический фолбэк (не показывается) -->
        <video id="video" class="hidden" playsinline muted></video>
        <!-- Превью внутри окна на canvas -->
        <canvas id="pv" class="cam-video" aria-label="Превью" role="img"></canvas>
        <img id="photo" class="cam-photo hidden" alt="Снимок" />
        <canvas id="anno" class="anno hidden"></canvas>

        <div id="overlay" class="cam-overlay">
          <div class="grid" aria-hidden="true"></div>
          <div class="topbar">
            <div id="chipInfo" class="chip" role="status" aria-live="polite">Держите телефон ровно. Банковская карта не обязательна, но повысит точность модели.</div>
          </div>
          <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик" aria-pressed="false">⚡️</button>
          <button id="btnSensors" class="btn-sensors hidden" aria-label="Включить уровень">⬤</button>

          <div class="center-level" aria-hidden="true">
            <div class="level-outer" id="levelOuter">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>

          <div id="cardArea" class="card-area" aria-label="Подсказка: положите карту (портрет)"></div>

          <div class="indicators">
            <div id="indLevel" class="ind"><span class="bulb"></span><span class="label">Ровно</span></div>
          </div>
        </div>

        <div id="controls" class="controls">
          <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
        </div>
      </div>

      <div id="meta" class="meta"></div>

      <div class="field">
        <label for="comment" class="helper">Комментарий (необязательно, но он повысит точность)</label>
        <textarea id="comment" class="textarea" maxlength="200" placeholder="Треска 150 гр и рис 200 гр"></textarea>
        <div id="commentWarn" class="helper hidden"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnRetake" class="btn" disabled>Переснять</button>
        <button id="btnGallery" class="btn">Галерея</button>
        <button id="btnSend" class="btn primary" disabled>Отправить</button>
      </div>
    </section>
  </main>

  <script>
  // ===================== CONFIG / STATE =====================
  const CONFIG = {
    // Просим высокое базовое качество видеопотока; итоговый снимок берём либо системно, либо в полном разрешении кадра
    idealFacing: { facingMode: { ideal: 'environment' }, aspectRatio: { ideal: 3/4 }, height: { ideal: 2880 }, width: { ideal: 2160 } },
    jpegQ: 0.98, webpQ: 0.98,

    // level geometry
    BUBBLE_R: 12, TARGET_R: 16, ENFORCE_GEOMETRY: true,

    // presence (подсказка, не блокирует)
    DETECT_HZ: 12, EDGE_MARGIN_PX: 3, MIN_SIDE_FRAC: 0.30, BOX_ALPHA: 0.18,
    HOLD_MAX_MS: 300, HIT_ON: 3, HIT_OFF: 2,
    CORNER_BOX: 7, CORNER_MIN_N: 3, AR_MIN: 1.35, AR_MAX: 1.85,
    DSCALE_W: 224
  };

  const CARD_MM = { W:85.60, H:53.98, AR:85.60/53.98, AR_TOL:0.10 };

  const S = { stream:null, track:null, torchCap:false, _torchOn:false, levelOn:false };
  let ic = null; // ImageCapture
  let _lastBlob = null, _view='camera', _taking=false;

  // RAW level inputs (без сглаживания)
  let _rawNx=0, _rawNy=0, _rafId=null, _levelRadius=40;

  // Hysteresis only for color/ok-state
  let _levelOK=false, _lvlHits=0, _lvlMiss=0; const LVL_ON=2, LVL_OFF=3;

  // Presence (подсказка для карты)
  let _detIdle=null, _lastDetTS=0, _fitOK=false, _hitCount=0,_missCount=0,_lastInsideTS=0;

  // iOS
  const isIOS = /iP(hone|od|ad)/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && 'ontouchend' in document);
  let _sensorLastTS = 0, _sensorWatch = null; const SENSOR_STALE_MS = 4000;

  // Wake Lock
  let _wakeLock = null;
  async function ensureWakeLock(on){
    try{
      if('wakeLock' in navigator && navigator.wakeLock?.request){
        if(on && !_wakeLock){ _wakeLock = await navigator.wakeLock.request('screen'); _wakeLock.addEventListener?.('release', ()=>{ _wakeLock=null; }); }
        if(!on && _wakeLock){ await _wakeLock.release(); _wakeLock=null; }
      }
    }catch(e){ _wakeLock=null; }
  }

  // ===================== DOM =====================
  const $ = id => document.getElementById(id);
  const err=$('err');
  const video=$('video'); // скрытый, только для фолбэка
  const pv=$('pv'), pvCtx=pv.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:true });
  const overlay=$('overlay'), controls=$('controls');
  const btnShot=$('btnShot'), btnTorch=$('btnTorch'), chipInfo=$('chipInfo');
  const btnSensors=$('btnSensors');
  const fileCam=$('file-cam'), fileGallery=$('file-gallery');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget'), levelOuter=$('levelOuter');
  const cardArea=$('cardArea'); const camWrap=$('camWrap');
  const indLevel=$('indLevel');
  const meta=$('meta');
  const photo=$('photo');
  const btnRetake=$('btnRetake'), btnGallery=$('btnGallery'), btnSend=$('btnSend');
  const commentEl=$('comment'), commentWarn=$('commentWarn');
  const anno=$('anno'), annoCtx=anno.getContext('2d', { alpha:true });

  // OpenCV.js dynamic loader
  let _cvReady=false, _cvLoading=null;
  function loadOpenCV(){
    if(_cvReady) return Promise.resolve(true);
    if(_cvLoading) return _cvLoading;
    _cvLoading = new Promise((resolve)=>{
      const s=document.createElement('script');
      s.src='https://docs.opencv.org/4.x/opencv.js';
      s.async=true;
      let resolved=false;
      function done(ok){ if(resolved) return; resolved=true; resolve(!!ok); }
      s.onload=()=>{
        try{
          if(window.cv){
            if(typeof cv['onRuntimeInitialized']==='function'){
              cv['onRuntimeInitialized']=()=>{ _cvReady=true; done(true); };
            } else {
              const check=()=>{ if(window.cv && cv.Mat) { _cvReady=true; done(true); } else { setTimeout(check,30); } };
              check();
            }
          } else { done(false); }
        }catch{ done(false); }
      };
      s.onerror=()=>done(false);
      document.head.appendChild(s);
      setTimeout(()=>done(_cvReady), 8000);
    });
    return _cvLoading;
  }

  // ===================== UTILS =====================
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  function setError(msg,hint){ if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; } const extra = hint?`<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>`:''; err.innerHTML = msg + extra; err.classList.remove('hidden'); }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
  function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
  async function queryPerm(name){ try{ const p=await navigator.permissions?.query?.({name}); return p?.state??null }catch{return null} }

  function canCanvasWebP(){ try{ const c=document.createElement('canvas'); return c.toDataURL('image/webp').startsWith('data:image/webp'); }catch{return false} }

  let supportsUnicodeProps=false; try{ new RegExp('\\p{L}','u'); supportsUnicodeProps=true; }catch(e){}
  function sanitizeComment(input){
    let s = String(input||'').slice(0, 200)
      .replace(/<[^>]*>/g, '')
      .replace(/[\u0000-\u001F\u007F-\u009F]/g, '')
      .replace(/(javascript:|data:|vbscript:|<script|<\/script|on\w+\s*=)/gi, '');
    if(supportsUnicodeProps){ s = s.replace(/[^\p{L}\p{N}\p{M}\s\.,!?:;"'()\-\u2013\u2014\[\]{}#@+/&%]/gu, ''); }
    else { s = s.replace(/[^A-Za-z0-9А-Яа-яЁё\s\.,!?:;"'()\-\u2013\u2014\[\]{}#@+/&%]/g, ''); }
    return s.replace(/\s+/g, ' ').trim();
  }
  function hasText(){ return sanitizeComment(commentEl.value).length > 0; }
  function showCommentWarning(show, text){ commentWarn.textContent = text || ''; commentWarn.classList.toggle('hidden', !show); }
  function updateButtons(){
    btnRetake.disabled = (_view === 'camera') || _taking;
    btnSend.disabled = !(_lastBlob || hasText()) || _taking;
    btnShot.disabled = !_levelOK; // только «ровно»
  }
  function syncIndicators(){
    indLevel.classList.toggle('ok', _levelOK);
    indLevel.setAttribute('aria-label', _levelOK ? 'Ровно: ок' : 'Ровно: нет');
  }

  function showCameraUI(){
    _view='camera';
    pv.classList.remove('hidden'); overlay.classList.remove('hidden'); controls.classList.remove('hidden');
    photo.classList.add('hidden'); anno.classList.add('hidden');
    meta.textContent='';
    chipInfo.textContent='Держите телефон ровно. Банковская карта не обязательна, но повысит точность модели.';
    startPreviewLoop(); startDetection(); startLevelLoop(); startSensorsWatchdog();
    enableLevelSensors(false);
    ensureWakeLock(true);
    updateButtons(); syncIndicators();
  }
  function showPhotoUI(){
    _view='photo';
    pv.classList.add('hidden'); overlay.classList.add('hidden'); controls.classList.add('hidden');
    photo.classList.remove('hidden');
    stopPreviewLoop();
    stopDetection();
    stopLevelLoop();
    stopSensorsWatchdog();
    removeSensorListeners();
    ensureWakeLock(false);
    updateButtons();
  }

  // ===================== AUTOSTART =====================
  window.addEventListener('DOMContentLoaded', () => {
    adaptPerf();
    startCameraFlow();
    loadOpenCV();
    try { window.Telegram?.WebApp?.ready?.(); } catch {}
  });

  // ===================== CAMERA (PHOTO MODE) =====================
  btnShot.addEventListener('click', onShutter);
  btnTorch.addEventListener('click', toggleTorch);
  btnSensors.addEventListener('click', ()=>{ requestSensorPermission(); });
  btnRetake.addEventListener('click', ()=>{ if(btnRetake.disabled) return; startCameraFlow(true); });
  btnGallery.addEventListener('click', ()=>fileGallery?.click());
  fileGallery.addEventListener('change', onFilePicked);
  fileCam.addEventListener('change', onFilePicked);
  commentEl.addEventListener('input', ()=>{
    const raw=commentEl.value, safe=sanitizeComment(raw);
    showCommentWarning(raw!==safe, raw!==safe ? 'Некоторые символы удалены для безопасности.' : '');
    updateButtons();
  });

  function adaptPerf(){
    const mem=(navigator.deviceMemory||8);
    if(mem <= 4){ CONFIG.DETECT_HZ = 6; CONFIG.DSCALE_W = Math.min(CONFIG.DSCALE_W, 160); }
  }

  function syncRadii(){
    let bubble=Number(CONFIG.BUBBLE_R)||0, target=Number(CONFIG.TARGET_R)||0;
    if (CONFIG.ENFORCE_GEOMETRY && target < bubble + 1) target = bubble + 1;
    CONFIG.BUBBLE_R = bubble; CONFIG.TARGET_R = target;
    const br=bubble*2, tr=target*2;
    levelBubble.style.width = br+'px'; levelBubble.style.height = br+'px';
    levelTarget.style.width = tr+'px'; levelTarget.style.height = tr+'px';
  }

  function computeLevelRadius(){
    const rOuter = Math.min(levelOuter.clientWidth, levelOuter.clientHeight) * 0.5;
    _levelRadius = Math.max(8, Math.floor(Math.min(rOuter - CONFIG.BUBBLE_R - 2, rOuter * 0.6)));
  }

  async function startCameraFlow(){
    stopPreviewLoop();
    _lastBlob=null; _taking=false;
    _fitOK=false; _levelOK=false; _lvlHits=0; _lvlMiss=0; _hitCount=0; _missCount=0; _lastInsideTS=0;
    _sensorLastTS=0;
    updateButtons(); setError(''); syncRadii();
    recomputeRects(); computeLevelRadius(); startObservers();

    attachIOSPermissionOneShot();

    const ok = await openCameraGUM();
    if(!ok){ try{ fileCam?.click(); }catch{} return; }

    ic = (typeof ImageCapture !== 'undefined' && S.track) ? new ImageCapture(S.track) : null;

    pv.style.opacity='0';
    showCameraUI();

    setTimeout(()=>{ if(_sensorLastTS===0) explainSensorBlock(); }, 600);
  }

  async function getPermission(){ try{ await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'environment' } }, audio:false }); }catch{} }
  async function pickBackCamera(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const prefer=[/back/i,/rear/i,/тыл/i,/задн/i,/Back Camera/i,/Wide Camera/i];
    const avoid=[/ultra/i,/tele/i,/macro/i,/сверх/i,/тел/i];
    let best=null;
    for(const d of devs){
      if(d.kind!=='videoinput') continue;
      const L=d.label||'';
      if(prefer.some(r=>r.test(L)) && !avoid.some(r=>r.test(L))){ best=d; break; }
    }
    if(!best) best = devs.find(d=> d.kind==='videoinput' && /back|rear/i.test(d.label||''));
    return best?.deviceId || devs.find(d=>d.kind==='videoinput')?.deviceId || null;
  }
  async function openLockedBackCamera(){
    await getPermission();
    const id = await pickBackCamera();
    const cons = id
      ? { video:{ deviceId:{ exact:id }, frameRate:{ ideal:30, max:30 },
                  width:{ ideal: 2160 }, height:{ ideal: 2880 }, aspectRatio:{ ideal: 3/4 },
                  focusMode:'continuous', exposureMode:'continuous', whiteBalanceMode:'continuous' }, audio:false }
      : { video:{ facingMode:{ exact:'environment' }, frameRate:{ ideal:30, max:30 },
                  width:{ ideal: 2160 }, height:{ ideal: 2880 }, aspectRatio:{ ideal: 3/4 },
                  focusMode:'continuous', exposureMode:'continuous', whiteBalanceMode:'continuous' }, audio:false };
    return navigator.mediaDevices.getUserMedia(cons);
  }

  async function openCameraGUM(){
    if(!canUseGUM()){ setError('Камера недоступна.', envHint()); return false; }
    const perm = await queryPerm('camera'); if(perm==='denied'){ setError('Доступ к камере запрещён.', envHint()); return false; }
    try{
      const s = await openLockedBackCamera();
      bindStream(s);
      const caps=S.track?.getCapabilities?.()||{};
      try{
        const adv={};
        if(caps.width?.max) adv.width=caps.width.max;
        if(caps.height?.max) adv.height=caps.height.max;
        if('focusMode' in caps) adv.focusMode='continuous';
        if('exposureMode' in caps) adv.exposureMode='continuous';
        if('whiteBalanceMode' in caps) adv.whiteBalanceMode='continuous';
        if(Object.keys(adv).length){ await S.track.applyConstraints({ advanced:[adv] }); }
      }catch{}
      S.torchCap=!!caps.torch; btnTorch.classList.toggle('hidden', !S.torchCap);
      if('zoom' in caps){
        try{ await S.track.applyConstraints({ advanced:[{ zoom: Math.min(Math.max(1, caps.zoom?.min||1), caps.zoom?.max||1) }] }); }catch{}
      }
      return true;
    }catch(e){ console.warn(e); setError('Не удалось открыть камеру.', envHint()); return false; }
  }

  function bindStream(stream){
    stopCamera();
    S.stream=stream; S.track=stream.getVideoTracks()[0];
    try{ video.srcObject=stream; video.play?.(); }catch{}
  }

  function stopCamera(){
    try{ video.pause?.(); video.srcObject=null }catch{}
    try{ S.track?.stop?.() }catch{}
    try{ S.stream?.getTracks?.()?.forEach(t=>t.stop()) }catch{}
    S.stream=null; S.track=null; S._torchOn=false; ic=null;
  }

  // ---------- PREVIEW LOOP ----------
  let _pvRun=false, _haveFirstFrame=false, _lastPvTS=0;
  const PREVIEW_HZ = 20;

  async function drawFrameToCanvas(){
    const { width: cssW, height: cssH } = camWrap.getBoundingClientRect();
    const scale = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    const tw = Math.max(1, Math.round(cssW * scale));
    const th = Math.max(1, Math.round(cssH * scale));
    if(pv.width!==tw || pv.height!==th){ pv.width=tw; pv.height=th; }

    if(ic && ic.grabFrame){
      const bmp = await ic.grabFrame();
      const r = Math.max(tw/bmp.width, th/bmp.height);
      const dw = Math.round(bmp.width*r), dh = Math.round(bmp.height*r);
      const dx = Math.floor((tw - dw)/2), dy = Math.floor((th - dh)/2);
      pvCtx.drawImage(bmp, dx, dy, dw, dh); bmp.close?.();
    }else if(video?.videoWidth>0){
      const r = Math.max(tw/video.videoWidth, th/video.videoHeight);
      const dw = Math.round(video.videoWidth*r), dh = Math.round(video.videoHeight*r);
      const dx = Math.floor((tw - dw)/2), dy = Math.floor((th - dh)/2);
      pvCtx.drawImage(video, dx, dy, dw, dh);
    }
  }

  function startPreviewLoop(){
    if(_pvRun) return; _pvRun=true; _haveFirstFrame=false; pv.style.opacity='0';
    const tick = async ()=>{
      if(!_pvRun || _view!=='camera') return;
      try{
        const now=performance.now();
        if(now - _lastPvTS >= (1000/ PREVIEW_HZ)){
          _lastPvTS = now;
          await drawFrameToCanvas();
          if(!_haveFirstFrame && pv.width>0 && pv.height>0){ _haveFirstFrame=true; pv.style.opacity='1'; }
        }
        if(now - _lastDetTS >= (1000/CONFIG.DETECT_HZ)){ detectPresenceFromCanvas(pv); _lastDetTS=now; }
      }catch(e){}
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  }
  function stopPreviewLoop(){ _pvRun=false; }

  // ---------- SHUTTER (anti-blur + post-shot card detection) ----------
  async function onShutter(){
    if(btnShot.disabled || _taking) return;
    _taking=true; updateButtons(); haptic();

    try{
      let blob=null;
      if(ic?.takePhoto){
        try{
          const caps = ic.getPhotoCapabilities ? await ic.getPhotoCapabilities() : null;
          const opts={};
          if(caps?.imageWidth?.max)  opts.imageWidth  = caps.imageWidth.max;
          if(caps?.imageHeight?.max) opts.imageHeight = caps.imageHeight.max;
          if(caps?.fillLightMode?.includes?.('flash')) opts.fillLightMode='flash';
          blob = await ic.takePhoto(opts);
        }catch{
          try{ blob = await ic.takePhoto(); }catch{ blob=null; }
        }
      }
      if(!blob){
        // Анти-шеринг: короткая серия и выбор самого резкого кадра
        blob = await captureBurstFromVideoFullRes(3, 28);
      }

      _lastBlob = blob;
      const url = URL.createObjectURL(blob);
      photo.onload = async ()=>{
        meta.textContent=`${photo.naturalWidth}×${photo.naturalHeight}`;
        URL.revokeObjectURL(url);
        await runCardDetectionOnBlob(blob, photo.naturalWidth, photo.naturalHeight); // пост-обводка
      };
      photo.src = url;
      showPhotoUI();
    }catch(e){ console.warn(e); setError('Не удалось сделать снимок.'); }
    finally{ _taking=false; updateButtons(); }
  }

  async function captureFromVideoFullRes(){
    const w = video?.videoWidth || pv.width || 0;
    const h = video?.videoHeight || pv.height || 0;
    const c = document.createElement('canvas'); c.width=w; c.height=h;
    const ctx = c.getContext('2d', { alpha:false });
    try{ ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; }catch{}
    if(video?.videoWidth){ ctx.drawImage(video, 0, 0, w, h); }
    else { ctx.drawImage(pv, 0, 0, w, h); }
    return canvasToBlob(c);
  }

  async function captureBurstFromVideoFullRes(n=3, gapMs=25){
    const items=[];
    for(let i=0;i<n;i++){
      const w = video?.videoWidth || pv.width || 0;
      const h = video?.videoHeight || pv.height || 0;
      const c = document.createElement('canvas'); c.width=w; c.height=h;
      const ctx = c.getContext('2d', { alpha:false });
      try{ ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; }catch{}
      if(video?.videoWidth){ ctx.drawImage(video, 0, 0, w, h); } else { ctx.drawImage(pv, 0, 0, w, h); }
      const score = sharpnessScore(c, Math.min(512, Math.round(w*0.25)));
      const blob = await canvasToBlob(c);
      items.push({blob, score});
      await sleep(gapMs);
    }
    items.sort((a,b)=>b.score-a.score);
    return items[0].blob;
  }

  function sharpnessScore(c, targetW=512){
    const r = Math.min(1, targetW/Math.max(1,c.width));
    const dw = Math.max(1, Math.round(c.width*r)), dh = Math.max(1, Math.round(c.height*r));
    const tmp = document.createElement('canvas'); tmp.width=dw; tmp.height=dh; const tctx=tmp.getContext('2d');
    tctx.drawImage(c,0,0,dw,dh); const {data,width,height} = tctx.getImageData(0,0,dw,dh);
    // серый + Лапласиан 3x3
    const gray=new Float32Array(dw*dh); for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j]=data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722; }
    const lap=[0,1,0,1,-4,1,0,1,0]; let sum=0, sum2=0, cnt=0;
    for(let y=1;y<dh-1;y++){
      for(let x=1;x<dw-1;x++){
        const i=y*dw+x;
        const v = lap[0]*gray[i-dw-1] + lap[1]*gray[i-dw] + lap[2]*gray[i-dw+1] + lap[3]*gray[i-1] + lap[4]*gray[i] + lap[5]*gray[i+1] + lap[6]*gray[i+dw-1] + lap[7]*gray[i+dw] + lap[8]*gray[i+dw+1];
        sum+=v; sum2+=v*v; cnt++;
      }
    }
    const mean=sum/Math.max(1,cnt); const varr = sum2/Math.max(1,cnt) - mean*mean;
    return varr; // чем больше, тем резче
  }

  function canvasToBlob(c){
    return new Promise(resolve=>{
      if(canCanvasWebP()){
        c.toBlob(b=>{ if(b) return resolve(b); c.toBlob(bb=>resolve(bb), 'image/jpeg', CONFIG.jpegQ); }, 'image/webp', CONFIG.webpQ);
      }else{
        c.toBlob(b=> resolve(b), 'image/jpeg', CONFIG.jpegQ);
      }
    });
  }

  // ---------- ГАЛЕРЕЯ ----------
  async function onFilePicked(ev){
    const file=ev.target?.files?.[0];
    if(!file) return;
    if(!file.type.startsWith('image/')){ setError('Нужен файл изображения.'); return; }
    _lastBlob=file;
    const url=URL.createObjectURL(file);
    photo.onload=async()=>{ meta.textContent = `${photo.naturalWidth}×${photo.naturalHeight} • ${file.type||'image'}`; URL.revokeObjectURL(url); await runCardDetectionOnBlob(file, photo.naturalWidth, photo.naturalHeight); };
    photo.src=url;
    showPhotoUI(); updateButtons(); ev.target.value='';
  }

  // ---------- Torch ----------
  let _torchBusy=false;
  async function toggleTorch(){
    if(!S.track || _torchBusy) return; _torchBusy=true;
    try{
      const caps=S.track.getCapabilities?.()||{}; if(!caps.torch) throw new Error('no-torch');
      S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]});
      btnTorch.classList.toggle('hidden', false);
      btnTorch.setAttribute('aria-pressed', String(S._torchOn));
      haptic();
    }catch{ S._torchOn=false; S.torchCap=false; btnTorch.classList.add('hidden'); }
    finally{ setTimeout(()=>{ _torchBusy=false; }, 200); }
  }

  // ---------- ORIENTATION ----------
  let _screenAngle=0;
  function refreshScreenAngle(){ let a = (screen.orientation?.angle ?? window.orientation ?? 0); a = ((a % 360)+360)%360; _screenAngle = a; }
  screen.orientation?.addEventListener?.('change', refreshScreenAngle);
  refreshScreenAngle();
  function getScreenAngle(){ return _screenAngle; }

  function mapTilt(pitchDeg, rollDeg){
    const a=getScreenAngle(); const s=30; const pr=clamp(pitchDeg/s, -1, 1); const rr=clamp(rollDeg /s, -1, 1);
    let nx=0, ny=0; switch(a){ case 0: nx=rr; ny=pr; break; case 90: nx=-pr; ny=rr; break; case 180: nx=-rr; ny=-pr; break; case 270: nx=pr; ny=-rr; break; } return { nx, ny };
  }

  // ---------- SENSORS ----------
  function addSensorListeners(){ try{ window.addEventListener('deviceorientation', onOrient, { capture:true, passive:true }); } catch{ window.addEventListener('deviceorientation', onOrient, true); } try{ window.addEventListener('devicemotion', onMotion, { capture:true, passive:true }); } catch{ window.addEventListener('devicemotion', onMotion, true); } }
  async function enableLevelSensors(firstTry=false){ if(S.levelOn) return true; let ok=false; try{ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function' && firstTry){ try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ addSensorListeners(); ok=true; } }catch{} } if(!ok && 'ondeviceorientation' in window){ addSensorListeners(); ok=true; } if(!ok && typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function' && firstTry){ try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ addSensorListeners(); ok=true; } }catch{} } if(!ok && 'ondevicemotion' in window){ addSensorListeners(); ok=true; } }catch{} S.levelOn=ok; return ok; }
  function removeSensorListeners(){ window.removeEventListener('deviceorientation', onOrient, true); window.removeEventListener('deviceorientation', onOrient, { capture:true }); window.removeEventListener('devicemotion', onMotion, true); window.removeEventListener('devicemotion', onMotion, { capture:true }); S.levelOn=false; }
  function rebindSensors(){ removeSensorListeners(); addSensorListeners(); S.levelOn=true; _sensorLastTS = performance.now(); }
  function inIframe(){ try{ return window.self !== window.top; } catch{ return true; } }
  function isCrossOriginFrame(){ try{ if(!inIframe()) return false; return window.top.location.origin !== window.location.origin; } catch{ return true; } }
  function policyAllows(feature){ try{ const fp = document.featurePolicy || document.permissionsPolicy || document.policy; if(!fp) return null; if(typeof fp.allowsFeature==='function') return fp.allowsFeature(feature); if(typeof fp.allowedFeatures==='function') return fp.allowedFeatures().includes(feature); if(typeof fp.features==='function') return fp.features().includes(feature); return null; }catch{ return null; } }
  function explainSensorBlock(){ const httpsHint = isSecureContext ? '' : '\n• Нужен HTTPS (или localhost).'; const iframe = inIframe(); const cross = isCrossOriginFrame(); const polyAcc = policyAllows('accelerometer'); const polyGyro = policyAllows('gyroscope'); const policyBlocks = (polyAcc===false || polyGyro===false) || (iframe && cross && (polyAcc===null && polyGyro===null)); let msg = 'Датчики ориентации пока недоступны.' + httpsHint; if(policyBlocks){ msg = 'Контейнер запретил доступ к датчикам. Если страница в <iframe>, добавьте атрибут\nallow="accelerometer; gyroscope; magnetometer"\nили заголовок Permissions-Policy на родительской странице.'; } else if (isIOS){ msg = 'iOS заблокировал «Движение и ориентация». Откройте Настройки → Safari → Доступ к движению и ориентации и включите. Затем нажмите «⬤» справа сверху.'; } chipInfo.textContent = msg; btnSensors.classList.toggle('hidden', false); }
  function attachIOSPermissionOneShot(){ if(!isIOS) return; const handler = async () => { await requestSensorPermission(); document.removeEventListener('pointerdown', handler, true); document.removeEventListener('touchstart', handler, true); document.removeEventListener('click', handler, true); }; document.addEventListener('pointerdown', handler, true); document.addEventListener('touchstart', handler, true); document.addEventListener('click', handler, true); }
  async function requestSensorPermission(){ let granted=false; try{ addSensorListeners(); if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ granted = (await DeviceOrientationEvent.requestPermission())==='granted'; }catch(e){ granted=false; } } if(!granted && typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ try{ granted = (await DeviceMotionEvent.requestPermission())==='granted' || granted; }catch(e){ granted=false; } } if(granted){ S.levelOn=true; btnSensors.classList.add('hidden'); chipInfo.textContent='Держите телефон ровно. Банковская карта не обязательна, но повысит точность модели.'; _sensorLastTS = performance.now(); } else { explainSensorBlock(); } }catch(e){ explainSensorBlock(); } }
  function onOrient(e){ if(_view!=='camera') return; _sensorLastTS = performance.now(); const pitch=e.beta??0, roll=e.gamma??0; const { nx, ny } = mapTilt(pitch, roll); _rawNx=nx; _rawNy=ny; }
  function onMotion(e){ if(_view!=='camera') return; _sensorLastTS = performance.now(); const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0; const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll =(Math.atan2( y, z)*180/Math.PI)||0; const { nx, ny } = mapTilt(pitch, roll); _rawNx=nx; _rawNy=ny; }
  function startSensorsWatchdog(){ stopSensorsWatchdog(); if(!isIOS) return; _sensorWatch = setInterval(()=>{ if(_view!=='camera') return; const stale = (performance.now() - _sensorLastTS) > SENSOR_STALE_MS; if(stale){ rebindSensors(); setTimeout(()=>{ if((performance.now()-_sensorLastTS) > 1500){ explainSensorBlock(); attachIOSPermissionOneShot(); } }, 0); } }, 1000); }
  function stopSensorsWatchdog(){ if(_sensorWatch){ clearInterval(_sensorWatch); _sensorWatch=null; } }
  window.addEventListener('pageshow', ()=>{ if(_view==='camera'){ _sensorLastTS=0; attachIOSPermissionOneShot(); }});
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && _view==='camera'){ _sensorLastTS=0; attachIOSPermissionOneShot(); ensureWakeLock(true); } else { ensureWakeLock(false); } });

  // ---------- LEVEL LOOP ----------
  function setLevelOK(next){ if(next){ _lvlHits++; _lvlMiss=0; } else { _lvlMiss++; _lvlHits=0; } const prev=_levelOK; const stable = prev ? (_lvlMiss>=LVL_OFF ? false : prev) : (_lvlHits>=LVL_ON ? true : prev); if(stable!==_levelOK){ _levelOK=stable; levelBubble.classList.toggle('ok', _levelOK); levelTarget.classList.toggle('ok', _levelOK); syncIndicators(); updateButtons(); } }
  function isInside(dx,dy){ return (Math.hypot(dx,dy) + CONFIG.BUBBLE_R) <= CONFIG.TARGET_R; }
  function startLevelLoop(){ if(_rafId) return; const step=()=>{ if(_view==='camera'){ const R=_levelRadius; const dx=clamp(_rawNx,-1,1)*R; const dy=clamp(_rawNy,-1,1)*R; levelBubble.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px) translateZ(0)`; setLevelOK(isInside(dx,dy)); } _rafId=requestAnimationFrame(step); }; _rafId=requestAnimationFrame(step); }
  function stopLevelLoop(){ if(_rafId){ cancelAnimationFrame(_rafId); _rafId=null; } }

  // ---------- PRESENCE DETECTOR (подсказка) ----------
  const DET = { c: document.createElement('canvas'), ctx:null, sW:0, sH:0, wrapRect:null, slotRect:null, g:null, gb:null, colV:null, rowH:null, allE:null };
  DET.ctx = DET.c.getContext('2d', { willReadFrequently:true, desynchronized:true });
  let _roStarted=false;
  function startObservers(){ if(_roStarted) return; const ro = new ResizeObserver(()=>{ recomputeRects(); computeLevelRadius(); }); ro.observe(camWrap); ro.observe(cardArea); ro.observe(levelOuter); _roStarted=true; }
  function recomputeRects(){ DET.wrapRect = camWrap.getBoundingClientRect(); DET.slotRect = cardArea.getBoundingClientRect(); DET.sW = CONFIG.DSCALE_W; DET.sH = Math.max(1, Math.round(DET.sW * (DET.wrapRect.height / Math.max(1, DET.wrapRect.width)))); DET.c.width = DET.sW; DET.c.height = DET.sH; DET.g = DET.gb = DET.colV = DET.rowH = DET.allE = null; }
  window.addEventListener('resize', ()=>{ recomputeRects(); computeLevelRadius(); resizeAnno(); });
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible'){ recomputeRects(); computeLevelRadius(); resizeAnno(); } });
  function meanStd(arr){ let m=0,m2=0,n=arr.length; for(let i=0;i<n;i++){ const v=arr[i]; m+=v; m2+=v*v; } m/=n; const std=Math.sqrt(Math.max(0,m2/n - m*m)); return [m,std]; }
  function detectPresenceFromCanvas(srcCanvas){
    if(!srcCanvas.width || !srcCanvas.height || !DET.wrapRect || !DET.slotRect) return;
    const sW=DET.sW, sH=DET.sH, ctx=DET.ctx; const vW=srcCanvas.width, vH=srcCanvas.height; const scale=Math.max(sW/vW, sH/vH); const sw=Math.round(sW/scale), sh=Math.round(sH/scale); const sx=Math.floor((vW - sw)/2), sy=Math.floor((vH - sh)/2); ctx.drawImage(srcCanvas, sx, sy, sw, sh, 0, 0, sW, sH);
    const wrap=DET.wrapRect, slot=DET.slotRect; const rx=Math.max(0, Math.round((slot.left - wrap.left) / wrap.width  * sW)); const ry=Math.max(0, Math.round((slot.top  - wrap.top ) / wrap.height * sH)); const rw=Math.min(sW - rx, Math.round(slot.width  / wrap.width  * sW)); const rh=Math.min(sH - ry, Math.round(slot.height / wrap.height * sH)); if(rw<20 || rh<20) return;
    const img=ctx.getImageData(rx, ry, rw, rh); const data=img.data; const N=rw*rh; if(!DET.g || DET.g.length!==N){ DET.g=new Float32Array(N); DET.gb=new Float32Array(N); DET.allE=new Float32Array(N); } if(!DET.colV || DET.colV.length!==rw){ DET.colV=new Float32Array(rw); } if(!DET.rowH || DET.rowH.length!==rh){ DET.rowH=new Float32Array(rh); } DET.colV.fill(0); DET.rowH.fill(0);
    const g=DET.g, gb=DET.gb, colV=DET.colV, rowH=DET.rowH, allE=DET.allE;
    for(let y=0,i=0,j=0;y<rh;y++){ for(let x=0;x<rw;x++,i+=4,j++){ g[j]=data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722; } }
    for(let y=0;y<rh;y++){ for(let x=0;x<rw;x++){ let s=0,cnt=0; for(let yy=y-1;yy<=y+1;yy++){ if(yy<0||yy>=rh) continue; for(let xx=x-1;xx<=x+1;xx++){ if(xx<0||xx>=rw) continue; s+=g[yy*rw+xx]; cnt++; } } gb[y*rw+x]=s/cnt; } }
    for(let y=1;y<rh-1;y++){ for(let x=1;x<rw-1;x++){ const gx=Math.abs(gb[y*rw+(x+1)] - gb[y*rw+(x-1)]); const gy=Math.abs(gb[(y+1)*rw+x] - gb[(y-1)*rw+x]); colV[x]+=gx; rowH[y]+=gy; allE[y*rw+x]=gx+gy; } }
    const a=CONFIG.BOX_ALPHA; for(let x=1;x<rw;x++){ colV[x]=colV[x-1] + a*(colV[x]-colV[x-1]); } for(let y=1;y<rh;y++){ rowH[y]=rowH[y-1] + a*(rowH[y]-rowH[y-1]); }
    const [mc,sc]=meanStd(colV); const [mr,sr]=meanStd(rowH); const tCol=mc + 1.15*sc; const tRow=mr + 1.15*sr;
    const m=CONFIG.EDGE_MARGIN_PX; let L=m; while(L<rw-m && colV[L] < tCol) L++; let R=rw-1-m; while(R>m && colV[R] < tCol) R--; let T=m; while(T<rh-m && rowH[T] < tRow) T++; let B=rh-1-m; while(B>m && rowH[B] < tRow) B--;
    if(!(R>L && B>T)){ applyPresence(false); return; }
    const width=R-L, height=B-T; const sizeOK=(width>=rw*CONFIG.MIN_SIDE_FRAC && height>=rh*CONFIG.MIN_SIDE_FRAC); const ar=height/Math.max(1,width); const arOK=(ar>=CONFIG.AR_MIN && ar<=CONFIG.AR_MAX); const inside=(L>m && T>m && R<rw-1-m && B<rh-1-m);
    const cornerEnergy=(cx,cy)=>{ const cb=CONFIG.CORNER_BOX; let s=0,cnt=0; for(let y=Math.max(T,cy); y<Math.min(B,cy+cb); y++){ for(let x=Math.max(L,cx); x<Math.min(R,cx+cb); x++){ const gx=Math.abs(gb[y*rw + Math.min(rw-1,x+1)] - gb[y*rw + Math.max(0,x-1)]); const gy=Math.abs(gb[Math.min(rh-1,y+1)*rw + x] - gb[Math.max(0,y-1)*rw + x]); s+=gx+gy; cnt++; } } return s/Math.max(1,cnt); };
    const eLT=cornerEnergy(L,T); const eRT=cornerEnergy(Math.max(L, R-CONFIG.CORNER_BOX), T); const eLB=cornerEnergy(L, Math.max(T, B-CONFIG.CORNER_BOX)); const eRB=cornerEnergy(Math.max(L, R-CONFIG.CORNER_BOX), Math.max(T, B-CONFIG.CORNER_BOX));
    const [me,se]=meanStd(allE); const eThr=me + 1.0*se; let strongCorners=0; if(eLT>eThr) strongCorners++; if(eRT>eThr) strongCorners++; if(eLB>eThr) strongCorners++; if(eRB>eThr) strongCorners++; const cornersOK=(strongCorners>=CONFIG.CORNER_MIN_N);
    applyPresence(inside && sizeOK && arOK && cornersOK);
  }
  function applyPresence(hit){ const now=performance.now(); if(hit){ _lastInsideTS=now; _hitCount++; _missCount=0; } else { _missCount++; _hitCount=0; } let ok = (_hitCount>=CONFIG.HIT_ON) ? true : (_missCount>=CONFIG.HIT_OFF ? false : _fitOK); if(!hit && ok && (now - _lastInsideTS) > CONFIG.HOLD_MAX_MS){ ok=false; } if(ok!==_fitOK){ _fitOK=ok; cardArea.classList.toggle('ok', ok); /* только визуально */ } }

  // ---------- Card detection after SHOT (OpenCV.js) ----------
  function resizeAnno(){ const { width:w, height:h } = camWrap.getBoundingClientRect(); const dpr=Math.min(2, window.devicePixelRatio||1); anno.width = Math.max(1, Math.round(w*dpr)); anno.height=Math.max(1, Math.round(h*dpr)); anno.style.width=w+'px'; anno.style.height=h+'px'; }
  function clearAnno(){ annoCtx.clearRect(0,0,anno.width,anno.height); }
  function containRect(imgW,imgH, boxW, boxH){ const r=Math.min(boxW/imgW, boxH/imgH); const dw=imgW*r, dh=imgH*r; const dx=(boxW-dw)/2, dy=(boxH-dh)/2; return {dx,dy,dw,dh,r}; }
  function drawQuadOnAnno(quad, imgW, imgH){ resizeAnno(); clearAnno(); anno.classList.remove('hidden'); const box = camWrap.getBoundingClientRect(); const fit = containRect(imgW, imgH, box.width, box.height); const dpr = Math.min(2, window.devicePixelRatio||1); annoCtx.lineWidth = 3*dpr; annoCtx.strokeStyle = '#22c55e'; annoCtx.fillStyle = 'rgba(34,197,94,.15)'; annoCtx.beginPath(); for(let i=0;i<4;i++){ const p=quad[i]; const x = (fit.dx + p.x*fit.r)*dpr; const y = (fit.dy + p.y*fit.r)*dpr; if(i===0) annoCtx.moveTo(x,y); else annoCtx.lineTo(x,y); } annoCtx.closePath(); annoCtx.stroke(); annoCtx.fill(); }

  function within10(val, ref){ return Math.abs(val-ref)/ref <= CARD_MM.AR_TOL; }

  async function runCardDetectionOnBlob(blob, natW, natH){
    const okCV = await loadOpenCV(); if(!okCV){ meta.textContent += ' • детектор недоступен'; return; }
    const bmp = await createImageBitmap(blob);
    const maxSide = 1600; const scale = Math.min(1, maxSide/Math.max(bmp.width,bmp.height));
    const aw = Math.max(1, Math.round(bmp.width*scale)); const ah = Math.max(1, Math.round(bmp.height*scale));
    const ac = document.createElement('canvas'); ac.width=aw; ac.height=ah; const actx=ac.getContext('2d'); actx.drawImage(bmp,0,0,aw,ah); bmp.close?.();
    let src=null, gray=null, blur=null, edges=null, cnts=new cv.MatVector(), hier=new cv.Mat();
    try{
      src=cv.imread(ac); gray=new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      try{ const clahe = new cv.CLAHE(2.0, new cv.Size(8,8)); const tmp=new cv.Mat(); clahe.apply(gray, tmp); gray.delete(); gray=tmp; clahe.delete(); }catch{}
      blur=new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);
      edges=new cv.Mat(); cv.Canny(blur, edges, 50, 150);
      cv.findContours(edges, cnts, hier, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
      let best=null; let bestScore=-1;
      for(let i=0;i<cnts.size();i++){
        const c=cnts.get(i); const peri = cv.arcLength(c, true); const approx = new cv.Mat(); cv.approxPolyDP(c, approx, 0.02*peri, true);
        if(approx.rows===4 && cv.isContourConvex(approx)){
          const pts=[]; for(let j=0;j<4;j++){ const p=approx.intPtr(j); pts.push({x:p[0], y:p[1]}); }
          const ord = orderQuad(pts);
          const s01=dist(ord[0],ord[1]), s12=dist(ord[1],ord[2]), s23=dist(ord[2],ord[3]), s30=dist(ord[3],ord[0]);
          const w = (Math.max(s01,s23));
          const h = (Math.max(s12,s30));
          const ratio = (Math.max(w,h)/Math.max(1,Math.min(w,h)));
          if(!within10(ratio, CARD_MM.AR)) { approx.delete(); continue; }
          const ang = rectness(ord);
          const area = cv.contourArea(c);
          // приоритет: соответствие AR, прямоугольность, площадь
          const arScore = 1 - Math.min(1, Math.abs(ratio - CARD_MM.AR)/CARD_MM.AR);
          const score = arScore*0.6 + ang*0.3 + Math.min(1, area/(aw*ah*0.08))*0.1;
          if(score>bestScore){ bestScore=score; best={ quad:ord, w,h, area, score }; }
        }
        approx.delete();
      }
      if(best){
        const quadOrig = best.quad.map(p=>({ x: p.x/scale, y: p.y/scale }));
        drawQuadOnAnno(quadOrig, natW, natH);
        meta.textContent += ' • карта: ок';
      } else {
        anno.classList.add('hidden');
        meta.textContent += ' • карта не найдена';
      }
    }catch(e){ console.warn('detectCard error', e); anno.classList.add('hidden'); }
    finally{ try{ src?.delete(); gray?.delete(); blur?.delete(); edges?.delete(); cnts?.delete(); hier?.delete(); }catch{} }
  }

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function rectness(pts){ const a=angleCos(pts[0],pts[1],pts[2]); const b=angleCos(pts[1],pts[2],pts[3]); const c=angleCos(pts[2],pts[3],pts[0]); const d=angleCos(pts[3],pts[0],pts[1]); const coses=[a,b,c,d].map(v=>Math.abs(v)); const mean=coses.reduce((s,v)=>s+v,0)/4; return 1-Math.min(1, mean); }
  function angleCos(p0,p1,p2){ const ux=p0.x-p1.x, uy=p0.y-p1.y, vx=p2.x-p1.x, vy=p2.y-p1.y; const dot=ux*vx+uy*vy; const nu=Math.hypot(ux,uy), nv=Math.hypot(vx,vy); if(nu*nv===0) return 1; return dot/(nu*nv); }
  function orderQuad(pts){ const cx = pts.reduce((s,p)=>s+p.x,0)/4; const cy = pts.reduce((s,p)=>s+p.y,0)/4; const arr = pts.map(p=>({p, a:Math.atan2(p.y-cy, p.x-cx)})).sort((u,v)=>u.a-v.a); let idx=0, best=Infinity; for(let i=0;i<4;i++){ const s=arr[i].p.x+arr[i].p.y; if(s<best){ best=s; idx=i; } } return [arr[idx].p, arr[(idx+1)%4].p, arr[(idx+2)%4].p, arr[(idx+3)%4].p]; }

  // ---------- ГАЛЕРЕЯ / SEND ----------
  async function onSend(){ const safeText=sanitizeComment(commentEl.value); if(!_lastBlob && !safeText){ setError('Пусто. Добавьте фото или комментарий.'); return; } console.log('DEBUG: отправка отключена.', { hasImage: !!_lastBlob, comment: safeText }); setError('Отправка пока отключена. Подключим бэкенд/бота позже.'); }
  btnSend.addEventListener('click', onSend);

  function envHint(){ const https = !isSecureContext ? "\n• Нужен HTTPS (или localhost)." : ""; return `Камера требует разрешений.${https}\n• Если камера не открывается — используйте галерею.`; }

  // TEARDOWN
  window.addEventListener('beforeunload', ()=>stopAll());
  function stopAll(){ stopPreviewLoop(); stopCamera(); stopDetection(); stopLevelLoop(); stopSensorsWatchdog(); removeSensorListeners(); ensureWakeLock(false); }

  function startDetection(){ stopDetection(); /* детектор вызывается внутри preview-loop */ }
  function stopDetection(){ const cic = window.cancelIdleCallback || clearTimeout; if(_detIdle){ cic(_detIdle); _detIdle=null; } }

  // ===================== TESTS =====================
  (function testRadii(){ syncRadii(); console.assert(CONFIG.TARGET_R > CONFIG.BUBBLE_R || !CONFIG.ENFORCE_GEOMETRY, 'target > bubble (when enforced)'); console.assert(CONFIG.BUBBLE_R>0 && CONFIG.TARGET_R>0, 'radii positive'); })();
  (function testInsideMath(){ const T=CONFIG.TARGET_R-CONFIG.BUBBLE_R; console.assert(T>0,'T>0'); console.assert(isInside(0,0),'center'); console.assert(isInside(T,0),'boundary'); console.assert(!isInside(T+0.01,0),'outside'); })();
  (function testAPIs(){ console.assert(typeof startCameraFlow==='function','startCameraFlow exists'); console.assert(typeof startPreviewLoop==='function','startPreviewLoop exists'); console.assert(typeof onShutter==='function','onShutter exists'); console.assert(typeof detectPresenceFromCanvas==='function','detectPresenceFromCanvas exists'); console.assert(typeof pvCtx==='object' && pvCtx,'pv context ok'); console.assert(typeof canCanvasWebP()==='boolean','canCanvasWebP returns boolean'); console.assert(typeof sanitizeComment('x')==='string','sanitizeComment returns string'); })();
  (function testCardRatio(){ const r=CARD_MM.AR; console.assert(within10(r*1.09,r),'ratio +9% ok'); console.assert(!within10(r*1.12,r),'ratio +12% rejected'); })();

  </script>
</body>
</html>
