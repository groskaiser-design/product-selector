<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam — камера (точнее распознавание карты)</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* CAMERA */
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4;contain:layout paint;}
    .cam-video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .2s ease;transform:translateZ(0);backface-visibility:hidden}
    .cam-photo{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000}

    .cam-overlay{position:absolute;inset:0;pointer-events:none}

    .topbar{position:absolute;left:0;right:0;top:16px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}

    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}
    .btn-cal{position:absolute;right:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}

    /* Level (target + dot) */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;}
    .level-outer{position:relative;width:160px;height:160px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.7);background:rgba(0,0,0,.18)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;transform: translate(calc(-50% + var(--dx,0px)), calc(-50% + var(--dy,0px))) translateZ(0);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);will-change:transform;transition: background-color .12s}
    .level-bubble.ok{background:#22c55e}

    /* bottom controls */
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    .meta{color:var(--muted);font-size:12px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px;margin-top:10px}
    .textarea{width:100%;min-height:68px;resize:vertical;padding:10px 12px;border:1px solid var(--ring);border-radius:12px;font:inherit;line-height:1.35}
    .helper{color:var(--muted);font-size:12px}

    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}

    /* Card ROI */
    .card-area{position:absolute; right:12px; top:50%; transform:translateY(-50%); width:115px; height:183px; border-radius:14px; border:2px solid rgba(255,255,255,.95); background:repeating-linear-gradient(45deg, rgba(255,255,255,.18) 0 10px, rgba(255,255,255,0) 10px 20px); box-shadow:0 0 0 1px rgba(0,0,0,.15) inset; pointer-events:none;}
    .card-area.ok{ border-color:#22c55e; box-shadow:0 0 0 2px rgba(34,197,94,.45) inset }

    .indicators{position:absolute;left:0;right:0;bottom:88px;display:flex;gap:10px;justify-content:center;z-index:9;}
    .ind{display:flex;align-items:center;gap:8px;padding:6px 8px;border-radius:12px;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);color:#fff}
    .ind .bulb{width:10px;height:10px;border-radius:50%;background:var(--warn);box-shadow:0 0 0 2px rgba(0,0,0,.25) inset}
    .ind.ok .bulb{background:var(--ok)}
    .ind .label{font-size:12px;opacity:.95}
  </style>
</head>
<body>
  <main class="container">
    <div id="err" class="error hidden"></div>

    <section id="sec-main">
      <input id="file-cam" type="file" accept="image/*" capture="environment" class="hidden" />
      <input id="file-gallery" type="file" accept="image/*" class="hidden" />

      <div class="cam-wrap" id="camWrap" aria-label="Камера и/или снимок">
        <video id="video" class="cam-video" playsinline muted></video>
        <img id="photo" class="cam-photo hidden" alt="Снимок" />

        <div id="overlay" class="cam-overlay">
          <div class="topbar">
            <div id="chipInfo" class="chip" role="status" aria-live="polite">Выровняйте телефон, положите карту в правую зону</div>
          </div>
          <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>
          <button id="btnCal" class="btn-cal" aria-label="Калибровать">⚙️</button>

          <div class="center-level">
            <div class="level-outer">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>

          <div id="cardArea" class="card-area" aria-label="Область для карты (портрет)"></div>

          <div class="indicators">
            <div id="indLevel" class="ind"><span class="bulb"></span><span class="label">Ровно</span></div>
            <div id="indCard" class="ind"><span class="bulb"></span><span class="label">Карта</span></div>
          </div>
        </div>

        <div id="controls" class="controls">
          <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
        </div>
      </div>

      <div id="meta" class="meta"></div>

      <div class="field">
        <label for="comment" class="helper">Комментарий (необязательно)</label>
        <textarea id="comment" class="textarea" maxlength="200" placeholder="Треска 150 гр и рис 200 гр"></textarea>
        <div id="commentWarn" class="helper hidden"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnRetake" class="btn" disabled>Переснять</button>
        <button id="btnGallery" class="btn">Галерея</button>
        <button id="btnSend" class="btn primary" disabled>Отправить</button>
      </div>
    </section>
  </main>

  <script>
  // ==== CONFIG / STATE (детектор усилен, точка — как была плавной) ====
  const CONFIG = {
    maxSide: 4096, jpegQ: 0.95, webpQ: 0.95,
    // Level
    BUBBLE_R: 12, TARGET_R: 16, ENFORCE_GEOMETRY: true,
    LEVEL_GAIN: 1.15, ORIENT_RANGE: 24, // чувствительнее, чем 30°
    SMOOTH2_ALPHA1: 0.26, SMOOTH2_ALPHA2: 0.17, SMOOTH_DEADZONE: 0.008,
    BASELINE_TRIM_ALPHA: 0.004, ZERO_THRESH: 0.035,
    // Presence (скорость + точность)
    DETECT_HZ: 12, EDGE_MARGIN_PX: 3, MIN_SIDE_FRAC: 0.25, BOX_ALPHA: 0.18,
    HOLD_MAX_MS: 220, HIT_ON: 1, HIT_OFF: 2,
    // Ужали коридор AR ближе к 1.586 (портрет карты)
    AR_MIN: 1.50, AR_MAX: 1.72,
    DSCALE_SLOT_W: 192 // ROI-ширина (адаптируем в adaptPerf)
  };

  const S = { stream:null, track:null, torchCap:false, _torchOn:false, levelOn:false };
  let _lastBlob=null, _view='camera', _taking=false;

  // Level
  let _rawNx=0,_rawNy=0,_fx1=0,_fy1=0,_fx2=0,_fy2=0,_bx=0,_by=0,_initF=false,_rafId=null;
  let _levelOK=false, _lvlHits=0, _lvlMiss=0; const LVL_ON=2, LVL_OFF=3;

  // Presence
  let _detIdle=null,_lastDetTS=0,_fitOK=false,_hitCount=0,_missCount=0,_lastInsideTS=0;

  // Axis
  let _axis={sx:1,sy:1};

  // ==== DOM ====
  const $=id=>document.getElementById(id);
  const err=$('err'); const video=$('video'), photo=$('photo'), overlay=$('overlay'), controls=$('controls');
  const btnShot=$('btnShot'), btnTorch=$('btnTorch'), btnCal=$('btnCal'), chipInfo=$('chipInfo');
  const fileCam=$('file-cam'), fileGallery=$('file-gallery');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget');
  const cardArea=$('cardArea'); const camWrap=$('camWrap');
  const indLevel=$('indLevel'), indCard=$('indCard'); const meta=$('meta');
  const btnRetake=$('btnRetake'), btnGallery=$('btnGallery'), btnSend=$('btnSend');
  const commentEl=$('comment'), commentWarn=$('commentWarn');

  // ==== Utils ====
  const sleep=ms=>new Promise(r=>setTimeout(r,ms));
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const canUseGUM=()=>!!(navigator.mediaDevices?.getUserMedia)&&isSecureContext;
  const setError=(m,h)=>{ if(!m){ err.classList.add('hidden'); err.innerHTML=''; return;} err.innerHTML=m+(h?`<div class="meta" style="white-space:pre-line;margin-top:6px">${h}</div>`:''); err.classList.remove('hidden'); };

  // ==== UI wiring ====
  window.addEventListener('DOMContentLoaded',()=>{ start(); });
  btnShot.addEventListener('click', onShutter);
  btnTorch.addEventListener('click', toggleTorch);
  btnCal.addEventListener('click', ()=>{ _bx=_rawNx; _by=_rawNy; });
  btnRetake.addEventListener('click',()=>{ if(btnRetake.disabled) return; start(true); });
  btnGallery.addEventListener('click',()=>fileGallery?.click());
  fileGallery.addEventListener('change', onFilePicked);
  fileCam.addEventListener('change', onFilePicked);
  commentEl.addEventListener('input',()=>{ btnSend.disabled=!(_lastBlob || (commentEl.value||'').trim()); });
  window.addEventListener('orientationchange', ()=>{ computeAxis(); });
  window.addEventListener('resize', recomputeRects);

  function start(){
    adaptPerf();
    _lastBlob=null; _taking=false; _fitOK=_levelOK=false; _lvlHits=_lvlMiss=0; _hitCount=_missCount=0; _lastInsideTS=0; _bx=_by=0; _initF=false;
    btnRetake.disabled=true; btnSend.disabled=true; btnShot.disabled=true; setError('');
    computeAxis(); syncRadii(); recomputeRects();
    showCamera(); enableLevelSensors(); openCameraGUM();
  }

  function showCamera(){ _view='camera'; video.classList.remove('hidden'); overlay.classList.remove('hidden'); controls.classList.remove('hidden'); photo.classList.add('hidden'); startDetection(); startLevelLoop(); syncIndicators(); }
  function showPhoto(){ _view='photo'; video.classList.add('hidden'); overlay.classList.add('hidden'); controls.classList.add('hidden'); photo.classList.remove('hidden'); stopDetection(); stopLevelLoop(); btnRetake.disabled=false; }

  function syncRadii(){ const br=CONFIG.BUBBLE_R*2, tr=CONFIG.TARGET_R*2; levelBubble.style.width=br+'px'; levelBubble.style.height=br+'px'; levelTarget.style.width=tr+'px'; levelTarget.style.height=tr+'px'; }

  // ==== Camera open, lock back camera & avoid reconfig ====
  async function getPermission(){ try{ await navigator.mediaDevices.getUserMedia({video:{facingMode:{ideal:'environment'}},audio:false}); }catch{} }
  async function pickBackCamera(){ const devs=await navigator.mediaDevices.enumerateDevices(); const prefer=[/back/i,/rear/i,/Back Camera/i,/Wide Camera/i,/задн/i]; const avoid=[/ultra/i,/macro/i,/tele/i,/сверх/i,/тел/i]; let best=null; for(const d of devs){ if(d.kind!=='videoinput') continue; const L=d.label||''; if(prefer.some(r=>r.test(L)) && !avoid.some(r=>r.test(L))){ best=d; break; } } if(!best) best=devs.find(d=>d.kind==='videoinput' && /back|rear/i.test(d.label||'')); return best?.deviceId || devs.find(d=>d.kind==='videoinput')?.deviceId || null; }
  async function openLockedBackCamera(){ await getPermission(); const id=await pickBackCamera(); const cons=id?{video:{deviceId:{exact:id},frameRate:{ideal:30,max:30}},audio:false}:{video:{facingMode:{exact:'environment'},frameRate:{ideal:30,max:30}},audio:false}; return navigator.mediaDevices.getUserMedia(cons); }

  async function openCameraGUM(){ if(!canUseGUM()){ setError('Камера недоступна.', envHint()); return; } try{ const s=await openLockedBackCamera(); stopCamera(); S.stream=s; S.track=s.getVideoTracks()[0]; video.style.opacity='0'; video.srcObject=s; await video.play(); await stabilizeVideo(300,1200); video.style.opacity='1'; const caps=S.track?.getCapabilities?.()||{}; S.torchCap=!!caps.torch; btnTorch.classList.toggle('hidden',!S.torchCap); if('zoom' in caps){ try{ await S.track.applyConstraints({advanced:[{zoom: Math.min(Math.max(1,caps.zoom?.min||1), caps.zoom?.max||1)}]}); }catch{} } }catch(e){ console.warn(e); setError('Не удалось открыть камеру.', envHint()); }
  }
  function stopCamera(){ try{ video.pause(); video.srcObject=null; }catch{} try{ S.track?.stop(); }catch{} try{ S.stream?.getTracks()?.forEach(t=>t.stop()); }catch{} S.stream=null; S.track=null; S._torchOn=false; }

  async function stabilizeVideo(win=250,timeout=1500){ let pw=0,ph=0,st=0,t=0; while(t<timeout){ const w=video.videoWidth,h=video.videoHeight; if(w>0&&h>0&&w===pw&&h===ph){ st+=50; if(st>=win) break; } else { st=0; pw=w; ph=h; } await sleep(50); t+=50; } }

  // ==== Shutter ====
  async function onShutter(){ if(btnShot.disabled||_taking) return; _taking=true; const c=snapshot(); try{ photo.src=c.toDataURL('image/webp',CONFIG.webpQ); meta.textContent=`${c.width}×${c.height}`; showPhoto(); }catch{} try{ _lastBlob=await new Promise(r=>c.toBlob(b=>r(b),'image/webp',CONFIG.webpQ)); } finally { stopCamera(); _taking=false; } }
  function snapshot(){ const w=video.videoWidth,h=video.videoHeight; const scale=Math.min(1, CONFIG.maxSide/Math.max(w,h)); const cw=Math.max(1,Math.round(w*scale)), ch=Math.max(1,Math.round(h*scale)); const c=document.createElement('canvas'); c.width=cw; c.height=ch; const ctx=c.getContext('2d',{alpha:false,desynchronized:true,willReadFrequently:true}); ctx.drawImage(video,0,0,cw,ch); return c; }

  // ==== Gallery ====
  async function onFilePicked(ev){ const file=ev.target?.files?.[0]; if(!file) return; if(!file.type.startsWith('image/')){ setError('Нужен файл изображения.'); return; } _lastBlob=file; const url=URL.createObjectURL(file); photo.onload=()=>{ meta.textContent=`${photo.naturalWidth}×${photo.naturalHeight} • ${file.type||'image'}`; }; photo.src=url; stopCamera(); showPhoto(); ev.target.value=''; }

  // ==== Torch ====
  let _torchBusy=false; async function toggleTorch(){ if(!S.track||!S.torchCap||_torchBusy) return; _torchBusy=true; try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); }catch{ btnTorch.classList.add('hidden'); } finally{ setTimeout(()=>_torchBusy=false,200); } }

  // ==== Level (sensors) ====
  function getScreenAngle(){ let a=(screen.orientation?.angle ?? window.orientation ?? 0); a%=360; if(a<0) a+=360; return a; }
  function computeAxis(){ const angle=getScreenAngle(); const flip=(angle===180)?-1:1; const sx=flip; const sy=flip*(1); _axis={sx,sy}; }

  async function enableLevelSensors(){ if(S.levelOn) return; let ok=false; try{ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{} } if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } if(!ok){ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{} } else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; } } }catch{} S.levelOn=ok; }

  function onOrient(e){ if(_view!=='camera') return; const pitch=e.beta??0, roll=e.gamma??0; const k=CONFIG.ORIENT_RANGE; _rawNx=clamp(roll/k,-1,1); _rawNy=clamp(pitch/k,-1,1); }
  function onMotion(e){ if(_view!=='camera') return; const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0; const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; const k=CONFIG.ORIENT_RANGE; _rawNx=clamp(roll/k,-1,1); _rawNy=clamp(pitch/k,-1,1); }

  function startLevelLoop(){ if(_rafId) return; const step=()=>{ if(_view==='camera'){ const near=(Math.abs(_fx2)<CONFIG.ZERO_THRESH && Math.abs(_fy2)<CONFIG.ZERO_THRESH); if(near){ _bx=_bx+CONFIG.BASELINE_TRIM_ALPHA*(_rawNx-_bx); _by=_by+CONFIG.BASELINE_TRIM_ALPHA*(_rawNy-_by); }
      const rx=_rawNx-_bx, ry=_rawNy-_by; const a1=CONFIG.SMOOTH2_ALPHA1, a2=CONFIG.SMOOTH2_ALPHA2, dz=CONFIG.SMOOTH_DEADZONE; if(!_initF){ _fx1=rx; _fy1=ry; _fx2=rx; _fy2=ry; _initF=true; } else {
        _fx1=_fx1+a1*(rx-_fx1); _fy1=_fy1+a1*(ry-_fy1); let nx2=_fx2+a2*(_fx1-_fx2); let ny2=_fy2+a2*(_fy1-_fy2); if(Math.abs(nx2-_fx2)<dz) nx2=_fx2; if(Math.abs(ny2-_fy2)<dz) ny2=_fy2; _fx2=nx2; _fy2=ny2; }
      const {sx,sy}=_axis; const R=70*0.45*CONFIG.LEVEL_GAIN; const dx=sx*_fx2*R, dy=sy*_fy2*R; levelBubble.style.setProperty('--dx',`${dx}px`); levelBubble.style.setProperty('--dy',`${dy}px`);
      const inside=(Math.hypot(dx,dy)+CONFIG.BUBBLE_R)<=CONFIG.TARGET_R; if(inside){ _lvlHits++; _lvlMiss=0;} else { _lvlMiss++; _lvlHits=0;} const prev=_levelOK; const stable=prev?(_lvlMiss>=LVL_OFF?false:prev):(_lvlHits>=LVL_ON?true:prev); if(stable!==_levelOK){ _levelOK=stable; levelBubble.classList.toggle('ok',_levelOK); levelTarget.classList.toggle('ok',_levelOK); syncIndicators(); }
      btnShot.disabled=!(_levelOK && _fitOK);
    } _rafId=requestAnimationFrame(step); }; _rafId=requestAnimationFrame(step); }
  function stopLevelLoop(){ if(_rafId){ cancelAnimationFrame(_rafId); _rafId=null; } }

  function syncIndicators(){ indLevel.classList.toggle('ok',_levelOK); indCard.classList.toggle('ok',_fitOK); }

  // ==== Presence (ROI-only, усилено: контраст-стретч + Sobel + робастные пороги + медиана рамки) ====
  const DET={ c:document.createElement('canvas'), ctx:null, slotRect:null, wrapRect:null, g:null, colV:null, rowH:null, lastBoxes:[] };
  DET.ctx=DET.c.getContext('2d',{willReadFrequently:true,desynchronized:true});

  function adaptPerf(){ const mem=(navigator.deviceMemory||8); if(mem<=4){ CONFIG.DETECT_HZ=9; CONFIG.DSCALE_SLOT_W=160; } else if(mem>=6){ CONFIG.DETECT_HZ=15; CONFIG.DSCALE_SLOT_W=208; } }

  function recomputeRects(){ DET.wrapRect=camWrap.getBoundingClientRect(); DET.slotRect=cardArea.getBoundingClientRect(); }

  function startDetection(){ stopDetection(); const ric=window.requestIdleCallback||function(cb,o){return setTimeout(cb,(o&&o.timeout)||120)}; const loop=()=>{ if(_view==='camera'){ const now=performance.now(); if(now-_lastDetTS>=(1000/CONFIG.DETECT_HZ)){ detectPresence(); _lastDetTS=now;} _detIdle=ric(loop,{timeout:120}); } }; _detIdle=ric(loop,{timeout:120}); }
  function stopDetection(){ const cic=window.cancelIdleCallback||clearTimeout; if(_detIdle){ cic(_detIdle); _detIdle=null; } }

  function mapSlotToVideoRect(){ if(!video.videoWidth||!video.videoHeight||!DET.wrapRect||!DET.slotRect) return null; const vW=video.videoWidth,vH=video.videoHeight; const wW=DET.wrapRect.width,wH=DET.wrapRect.height; const scale=Math.max(wW/vW, wH/vH); const cropX=(vW*scale - wW)/2; const cropY=(vH*scale - wH)/2; const x=(DET.slotRect.left-DET.wrapRect.left + cropX)/scale; const y=(DET.slotRect.top -DET.wrapRect.top  + cropY)/scale; const w=DET.slotRect.width/scale; const h=DET.slotRect.height/scale; return {x:Math.max(0,x), y:Math.max(0,y), w:Math.max(1,Math.min(vW-x,w)), h:Math.max(1,Math.min(vH-y,h))}; }

  function robustThreshold(arr){ // max(80-й перцентиль, mean+0.6*std)
    const n=arr.length; let m=0,m2=0; for(let i=0;i<n;i++){ const v=arr[i]; m+=v; m2+=v*v; } m/=n; const s=Math.sqrt(Math.max(0,m2/n - m*m));
    const copy=Array.from(arr); copy.sort((a,b)=>a-b); const p80=copy[Math.min(n-1,Math.floor(0.8*n))];
    return Math.max(p80, m+0.6*s);
  }
  function smooth1D(a, alpha){ for(let i=1;i<a.length;i++){ a[i]=a[i-1]+alpha*(a[i]-a[i-1]); } return a; }
  function close1D(a){ // морф. «закрытие» 3-окном: дилатация ≈ local max, затем сглаживание
    const n=a.length, out=new Float32Array(n);
    for(let i=0;i<n;i++){ let mx=a[i]; if(i>0) mx=Math.max(mx,a[i-1]); if(i<n-1) mx=Math.max(mx,a[i+1]); out[i]=mx; }
    return out;
  }
  function pushBox(L,R,T,B, rw,rh){ DET.lastBoxes.push([L/rw,R/rw,T/rh,B/rh]); if(DET.lastBoxes.length>3) DET.lastBoxes.shift(); const med=v=>{ const b=[...v].sort((x,y)=>x-y); const k=Math.floor(b.length/2); return b.length%2?b[k]:(b[k-1]+b[k])/2; }; const Ls=DET.lastBoxes.map(v=>v[0]), Rs=DET.lastBoxes.map(v=>v[1]), Ts=DET.lastBoxes.map(v=>v[2]), Bs=DET.lastBoxes.map(v=>v[3]); return [med(Ls)*rw, med(Rs)*rw, med(Ts)*rh, med(Bs)*rh]; }

  function detectPresence(){ const vr=mapSlotToVideoRect(); if(!vr) return; // вырезаем ROI из видеокадра
    const dW=CONFIG.DSCALE_SLOT_W, dH=Math.max(1,Math.round(dW*(vr.h/Math.max(1,vr.w)))); DET.c.width=dW; DET.c.height=dH;
    DET.ctx.drawImage(video, vr.x,vr.y,vr.w,vr.h, 0,0,dW,dH);

    // --- luminance + контраст-стретч (робастный) ---
    const img=DET.ctx.getImageData(0,0,dW,dH); const data=img.data; const N=dW*dH; if(!DET.g||DET.g.length!==N){ DET.g=new Float32Array(N); DET.colV=new Float32Array(dW); DET.rowH=new Float32Array(dH); }
    const g=DET.g, colV=DET.colV, rowH=DET.rowH; colV.fill(0); rowH.fill(0);
    for(let i=0,j=0;i<data.length;i+=4,j++){ g[j]=data[i]*0.2126+data[i+1]*0.7152+data[i+2]*0.0722; }
    // контраст: линейный стретч по [p5..p95]
    const sorted=Array.from(g).sort((a,b)=>a-b); const p5=sorted[Math.floor(0.05*N)], p95=sorted[Math.floor(0.95*N)]||1; const rng=Math.max(1, p95-p5);
    for(let i=0;i<N;i++){ g[i]=(g[i]-p5)/rng; if(g[i]<0) g[i]=0; if(g[i]>1) g[i]=1; }

    // --- Sobel + проекции ---
    for(let y=1;y<dH-1;y++){
      const y0=(y-1)*dW, y1=y*dW, y2=(y+1)*dW;
      for(let x=1;x<dW-1;x++){
        const i=y1+x;
        const gx = -g[y0+x-1]-2*g[y1+x-1]-g[y2+x-1] + g[y0+x+1]+2*g[y1+x+1]+g[y2+x+1];
        const gy = -g[y0+x-1]-2*g[y0+x]-g[y0+x+1] + g[y2+x-1]+2*g[y2+x]+g[y2+x+1];
        const ax=Math.abs(gx), ay=Math.abs(gy);
        colV[x]+=ax; rowH[y]+=ay;
      }
    }
    // сглаживание + морф. закрытие
    smooth1D(colV, CONFIG.BOX_ALPHA); smooth1D(rowH, CONFIG.BOX_ALPHA);
    const colC=close1D(colV), rowC=close1D(rowH);

    // робастные пороги
    const tCol=robustThreshold(colC), tRow=robustThreshold(rowC);

    const m=CONFIG.EDGE_MARGIN_PX; let L=m; while(L<dW-m && colC[L]<tCol) L++; let R=dW-1-m; while(R>m && colC[R]<tCol) R--; let T=m; while(T<dH-m && rowC[T]<tRow) T++; let B=dH-1-m; while(B>m && rowC[B]<tRow) B--;
    if(!(R>L && B>T)){ applyPresence(false); return; }

    // медиана по последним 3 рамкам (субпиксельные дрожания гасим)
    [L,R,T,B]=pushBox(L,R,T,B,dW,dH);

    // геометрические проверки
    const width=R-L, height=B-T; const sizeOK=(width>=dW*CONFIG.MIN_SIDE_FRAC && height>=dH*CONFIG.MIN_SIDE_FRAC);
    const ar=height/Math.max(1,width); const arOK=(ar>=CONFIG.AR_MIN && ar<=CONFIG.AR_MAX);
    const inside=(L>m&&T>m&&R<dW-1-m&&B<dH-1-m);

    // углы: окно пропорционально масштабу
    const cb=Math.max(4, Math.round(Math.min(width,height)*0.08));
    function cornerE(cx,cy){ let s=0,c=0; for(let yy=cy; yy<Math.min(B,cy+cb); yy++){ for(let xx=cx; xx<Math.min(R,cx+cb); xx++){ const i=yy*dW+xx;
      const gx = -g[i-dW-1]-2*g[i-1]-g[i+dW-1] + g[i-dW+1]+2*g[i+1]+g[i+dW+1];
      const gy = -g[i-dW-1]-2*g[i-dW]-g[i-dW+1] + g[i+dW-1]+2*g[i+dW]+g[i+dW+1]; s+=Math.abs(gx)+Math.abs(gy); c++; } } return s/Math.max(1,c); }
    const eLT=cornerE(L,T), eRT=cornerE(Math.max(L,R-cb),T), eLB=cornerE(L,Math.max(T,B-cb)), eRB=cornerE(Math.max(L,R-cb),Math.max(T,B-cb));
    const meanCorner=(eLT+eRT+eLB+eRB)/4; let strong=0; if(eLT>meanCorner*1.05) strong++; if(eRT>meanCorner*1.05) strong++; if(eLB>meanCorner*1.05) strong++; if(eRB>meanCorner*1.05) strong++;

    applyPresence(inside && sizeOK && arOK && strong>=2);
  }

  function applyPresence(hit){ const now=performance.now(); if(hit){ _lastInsideTS=now; _hitCount++; _missCount=0;} else { _missCount++; _hitCount=0;} let ok=(_hitCount>=CONFIG.HIT_ON)?true:(_missCount>=CONFIG.HIT_OFF?false:_fitOK); if(!hit && ok && (now-_lastInsideTS)>CONFIG.HOLD_MAX_MS){ ok=false; } if(ok!==_fitOK){ _fitOK=ok; cardArea.classList.toggle('ok',ok); syncIndicators(); } btnShot.disabled=!(_levelOK && _fitOK); }

  // ==== Send (заглушка) ====
  btnSend.addEventListener('click',()=>{ const t=(commentEl.value||'').trim(); if(!_lastBlob && !t){ setError('Пусто. Добавьте фото или комментарий.'); return;} setError('Отправка пока отключена.'); });

  // FIX: строковые литералы без сырых переносов в кавычках
  function envHint(){
    const https = !isSecureContext ? "\n• Нужен HTTPS (или localhost)." : "";
    return "Камера требует разрешений." + https + "\n• Если камера не открывается — используйте галерею.";
  }

  window.addEventListener('beforeunload',()=>{ stopCamera(); stopDetection(); stopLevelLoop(); });

  // ==== TESTS (не меняем существующие, добавлены базовые проверки) ====
  (function tests(){
    try {
      const e = envHint();
      console.assert(typeof e === 'string' && e.length > 0, 'envHint returns non-empty string');
      console.assert(e.includes('Камера требует разрешений.'), 'envHint contains base message');
      console.assert(robustThreshold([0,1,2,100]) >= 1, 'robustThreshold works on sample');
      console.assert(typeof mapSlotToVideoRect === 'function', 'mapSlotToVideoRect exists');
    } catch(err){ console.warn('Tests failed:', err); }
  })();
  </script>
</body>
</html>
