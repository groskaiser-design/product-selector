<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam — одна камера с уровнем (без звука)</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:0 0 6px}
    .muted{color:var(--muted);font-size:14px;margin:0 0 12px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    /* Buttons */
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px; border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* CAMERA */
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
    .cam-video{width:100%;height:100%;object-fit:cover;display:block}
    .cam-overlay{position:absolute;inset:0;pointer-events:none}

    /* grid */
    .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    /* top info bar — ниже фонаря */
    .topbar{position:absolute;left:0;right:0;top:64px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}
    .chip.ok{background:rgba(22,163,74,.9)} .chip.warn{background:rgba(245,158,11,.95)}

    /* Torch */
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}

    /* Level (one target + dot) */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:160px;height:160px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.75);background:rgba(0,0,0,.15);backdrop-filter:blur(3px)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
    .level-bubble.ok{background:#22c55e}

    /* bottom controls */
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    /* preview */
    .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
    .pad{padding:14px}
    .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    .badge{font-size:12px;color:#64748b}
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>Камера с уровнем (без звука)</h1>
      <p class="muted">Снимок разрешён только когда <b>точка полностью внутри</b> круга. Качество фото повышено.</p>
    </header>

    <div id="err" class="error hidden"></div>

    <!-- CAMERA -->
    <section id="sec-camera">
      <div class="row" style="margin-bottom:10px">
        <button id="btnOpen" class="btn primary">Открыть камеру</button>
        <button id="btnStop" class="btn">Закрыть</button>
        <span id="permHint" class="badge">Разрешите «Ориентация и движение»</span>
        <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden" />
      </div>

      <div class="cam-wrap" id="camWrap" aria-label="Живое превью камеры">
        <video id="video" class="cam-video" playsinline muted></video>

        <div class="cam-overlay">
          <div class="grid"></div>

          <!-- top info -->
          <div class="topbar">
            <div id="chipInfo" class="chip">Наведите сверху • выравнивайте…</div>
          </div>

          <!-- torch -->
          <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

          <!-- level: only one target circle + dot -->
          <div class="center-level">
            <div class="level-outer">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>
        </div>

        <div class="controls">
          <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
        </div>
      </div>
    </section>

    <!-- PREVIEW -->
    <section id="sec-preview" class="hidden" style="margin-top:12px">
      <div class="card pad">
        <img id="photo" class="preview-img" alt="Снимок" />
        <div id="meta" class="meta"></div>
        <div class="row" style="margin-top:10px">
          <button id="btnRetake" class="btn">Переснять</button>
          <button id="btnSave" class="btn primary">Скачать снимок</button>
        </div>
      </div>
    </section>
  </main>

  <script>
  // ===================== CONFIG / STATE =====================
  const CONFIG = {
    // Камера
    idealFacing: { facingMode: { ideal: 'environment' }, width: { ideal: 1920 }, height: { ideal: 1080 } },
    maxSide: 4096,
    jpegQ: 0.95,
    webpQ: 0.95,

    // === РАЗМЕРЫ МИШЕНИ (меняй тут!) ===
    // Радиус точки (px):
    BUBBLE_R: 12,
    // Радиус мишени (px):
    TARGET_R: 15,
    // Авто-правка: если включено — гарантирует, что TARGET_R ≥ BUBBLE_R+1
    ENFORCE_GEOMETRY: true,
  };

  const S = { stream:null, track:null, torchCap:false, _torchOn:false, levelOn:false };

  // ===================== DOM =====================
  const $ = id => document.getElementById(id);
  const err=$('err'), video=$('video');
  const btnOpen=$('btnOpen'), btnStop=$('btnStop'), btnTorch=$('btnTorch'), btnShot=$('btnShot'), fileSystem=$('file-system');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget');
  const chipInfo=$('chipInfo');
  const secCam=$('sec-camera'), secPrev=$('sec-preview'), photo=$('photo'), meta=$('meta');
  const btnRetake=$('btnRetake'), btnSave=$('btnSave'), permHint=$('permHint');

  // ===================== UTILS =====================
  function setError(msg,hint){ if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; } const extra = hint?`<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>`:''; err.innerHTML = msg + extra; err.classList.remove('hidden'); }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
  function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
  async function queryPerm(name){ try{ const p=await navigator.permissions?.query?.({name}); return p?.state??null }catch{return null} }

  // ===================== CAMERA FLOW =====================
  btnOpen.addEventListener('click', openFlow);
  btnStop.addEventListener('click', ()=>stopAll());
  btnTorch.addEventListener('click', toggleTorch);
  btnShot.addEventListener('click', onShutter);
  btnSave.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=photo.src; a.download='photo.jpg'; document.body.appendChild(a); a.click(); a.remove(); });
  btnRetake.addEventListener('click', ()=>{ secPrev.classList.add('hidden'); secCam.classList.remove('hidden'); openFlow(); });

  function syncRadii(){
    let bubble = Number(CONFIG.BUBBLE_R)||0;
    let target = Number(CONFIG.TARGET_R)||0;
    if (CONFIG.ENFORCE_GEOMETRY && target < bubble + 1) target = bubble + 1;
    // применяем
    CONFIG.BUBBLE_R = bubble; CONFIG.TARGET_R = target;
    const br = bubble * 2, tr = target * 2;
    levelBubble.style.width = br + 'px'; levelBubble.style.height = br + 'px';
    levelTarget.style.width = tr + 'px'; levelTarget.style.height = tr + 'px';
  }

  async function openFlow(){ setError(''); syncRadii(); await enableLevelSensors(); const camOk = await openCameraGUM(); if(!camOk){ try{ fileSystem?.click(); }catch{} } }

  async function openCameraGUM(){
    if(!canUseGUM()){ setError('Камера недоступна.', envHint()); return false; }
    const perm = await queryPerm('camera'); if(perm==='denied'){ setError('Доступ к камере запрещён.', envHint()); return false; }
    try{
      const s = await navigator.mediaDevices.getUserMedia({video: CONFIG.idealFacing, audio:false});
      await bindStream(s);
      await upgradeResolution();
      const caps=S.track?.getCapabilities?.()||{}; btnTorch.classList.toggle('hidden', !caps.torch); S.torchCap=!!caps.torch; return true;
    }catch(e){ console.warn(e); setError('Не удалось открыть камеру.', envHint()); return false; }
  }

  async function bindStream(stream){ stopCamera(); S.stream=stream; S.track=stream.getVideoTracks()[0]; video.srcObject=stream; try{ await video.play(); }catch{}; secCam.classList.remove('hidden'); secPrev.classList.add('hidden'); }

  async function upgradeResolution(){
    try{
      const caps = S.track.getCapabilities?.() || {};
      const wants = {};
      if(caps.width && caps.width.max) wants.width = caps.width.max;
      if(caps.height && caps.height.max) wants.height = caps.height.max;
      if(Object.keys(wants).length){ try{ await S.track.applyConstraints(wants); }catch(e){ console.warn('applyConstraints(max) failed', e); }
      }
      const st = S.track.getSettings?.() || {}; console.log('Video settings:', st);
    }catch(e){ console.warn('upgradeResolution failed', e); }
  }

  function stopCamera(){ try{ video.pause(); video.srcObject=null }catch{}; try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}; S.stream=null; S.track=null; }
  async function toggleTorch(){ if(!S.track || !S.torchCap) return; try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }catch{ btnTorch.classList.add('hidden'); } }

  async function onShutter(){ if(btnShot.disabled) return; haptic(); await takeShot(); }

  async function takeShot(){
    if(!video.videoWidth || !video.videoHeight) return;
    if('ImageCapture' in window && S.track){
      try{
        const ic = new ImageCapture(S.track);
        const blob = await ic.takePhoto();
        const url = URL.createObjectURL(blob);
        photo.onload = ()=>{ meta.textContent = `${photo.naturalWidth}×${photo.naturalHeight} • ${blob.type||'image'}`; };
        photo.src = url; secCam.classList.add('hidden'); secPrev.classList.remove('hidden'); return;
      }catch(e){ console.warn('ImageCapture failed, fallback to canvas', e); }
    }
    const srcW=video.videoWidth, srcH=video.videoHeight;
    const scale = Math.min(1,  CONFIG.maxSide/Math.max(srcW,srcH));
    const w=Math.max(1,Math.round(srcW*scale)), h=Math.max(1,Math.round(srcH*scale));
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d');
    try{ ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; }catch{}
    ctx.drawImage(video,0,0,w,h);
    let url = '';
    try{ url = c.toDataURL('image/webp', CONFIG.webpQ); }catch{}
    if(!url || !/^data:image\/webp/.test(url)){
      try{ url = c.toDataURL('image/jpeg', CONFIG.jpegQ); }catch{}
    }
    if(!url){ url = c.toDataURL(); }
    photo.src=url; meta.textContent = `${w}×${h}`; secCam.classList.add('hidden'); secPrev.classList.remove('hidden');
  }

  // ===================== LEVEL SENSORS =====================
  function isInside(dx,dy){
    // полностью внутри: расстояние центра + радиус точки ≤ радиус мишени
    return (Math.hypot(dx,dy) + CONFIG.BUBBLE_R) <= CONFIG.TARGET_R;
  }

  async function enableLevelSensors(){ if(S.levelOn) return; let ok=false; try{ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{} } if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } if(!ok){ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{} } else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; } } }catch{} S.levelOn=ok; permHint.classList.toggle('hidden', ok); }
  function onOrient(e){ const pitch=e.beta??0, roll=e.gamma??0; paintLevel(pitch,roll) }
  function onMotion(e){ const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0; const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; paintLevel(pitch,roll); }
  function paintLevel(pitch, roll){
    const R=70; // рабочая зона движения
    const nx=clamp(roll/30,-1,1), ny=clamp(pitch/30,-1,1);
    const dx=nx*R*0.45, dy=-ny*R*0.45;
    levelBubble.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

    const okFully = isInside(dx,dy);
    levelBubble.classList.toggle('ok', okFully);
    levelTarget.classList.toggle('ok', okFully);

    chipInfo.textContent = okFully ? 'Ровно — можно снимать' : 'Выравнивайте… (кнопка заблокирована)';
    chipInfo.className = 'chip ' + (okFully ? 'ok' : 'warn');
    btnShot.disabled = !okFully;
  }

  // ===================== ENV HINT =====================
  function envHint(){
    const https = !isSecureContext ? "• Нужен HTTPS (или localhost)." : "";
    return `Камера требует разрешений.${https}\n• Если камера не открывается — проверьте права и попробуйте системную кнопку «Открыть во внешнем браузере».`;
  }

  // ===================== TEARDOWN =====================
  window.addEventListener('beforeunload', ()=>stopAll());
  function stopAll(){ stopCamera(); }

  // ===================== TESTS (console) =====================
  (function testRadii(){
    syncRadii();
    console.assert(CONFIG.TARGET_R > CONFIG.BUBBLE_R || !CONFIG.ENFORCE_GEOMETRY, 'target > bubble (when enforced)');
    console.assert(CONFIG.BUBBLE_R>0 && CONFIG.TARGET_R>0, 'radii positive');
  })();
  (function testInsideMath(){ const T=CONFIG.TARGET_R-CONFIG.BUBBLE_R; console.assert(T>0,'T>0'); console.assert(isInside(0,0),'center'); console.assert(isInside(T,0),'boundary'); console.assert(!isInside(T+0.01,0),'outside'); })();
  (function testEnvHint(){ const h=envHint(); console.assert(typeof h==='string' && h.includes('Камера требует разрешений.'), 'envHint string content'); })();
  </script>
</body>
</html>
