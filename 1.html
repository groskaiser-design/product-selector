<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>FoodCam — Distance Coach 30 см ±5 см + Площадь</title>
  <meta name="theme-color" content="#0a7cff"/>
  <style>
    :root{--bg:#fff;--text:#111827;--muted:#6b7280;--ring:#e5e7eb;--primary:#2563eb;--ok:#16a34a}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);
      font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .container{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:0 0 6px}.muted{color:var(--muted);font-size:14px;margin:0 0 12px}
    .row{display:flex;gap:10px;flex-wrap:wrap}.hidden{display:none!important}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;
      border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
    .cam-video{width:100%;height:100%;object-fit:cover;display:block}
    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}
    /* top hint (перенесена вверх) */
    .top-hint{position:absolute;left:50%;top:12px;transform:translateX(-50%);z-index:9;
      background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.25);
      border-radius:12px;padding:8px 12px;font-size:14px;pointer-events:auto}
    .top-hint.ok{background:rgba(22,163,74,.85)}
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;
      background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}
    /* level */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:140px;height:140px;border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.2);backdrop-filter:blur(4px)}
    .level-target{position:absolute;left:50%;top:50%;width:36px;height:36px;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.55)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;width:22px;height:22px;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
    .level-bubble.ok{background:#22c55e}
    /* preview + tools */
    .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
    .pad{padding:14px}
    .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid var(--ring);font-size:14px;cursor:pointer}
    .chip.primary{background:#e0e7ff;border-color:#c7d2fe}
    /* manual polygon overlay */
    .poly-canvas{position:absolute;inset:0;pointer-events:none}
    .badge{font-size:12px;color:#64748b}
  </style>
</head>
<body>
<main class="container">
  <header>
    <h1>Distance Coach — 30 см ± 5 см → Площадь тарелки</h1>
    <p class="muted">Наведи камеру строго сверху (по уровню). Попади на дистанцию <b>30 см ± 5 см</b>. Сделай снимок — вычислим площадь.</p>
  </header>

  <div id="err" class="error hidden"></div>

  <!-- CAMERA -->
  <section id="sec-camera">
    <div class="row" style="margin-bottom:10px">
      <button id="btnOpen" class="btn primary">Открыть камеру</button>
      <button id="btnStop" class="btn">Закрыть</button>
      <span id="permHint" class="badge">iOS: разрешите «Ориентацию и движение»</span>
      <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden"/>
    </div>

    <div class="cam-wrap" id="camWrap" aria-label="Живое превью камеры">
      <video id="video" class="cam-video" playsinline muted></video>

      <div class="cam-overlay">
        <div class="grid"></div>

        <!-- верхняя подсказка состояния -->
        <div id="topHint" class="top-hint">Пробуем AR для замера дистанции…</div>

        <!-- фонарь -->
        <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

        <!-- центральный уровень -->
        <div class="center-level">
          <div class="level-outer">
            <div id="levelTarget" class="level-target"></div>
            <div id="levelBubble" class="level-bubble"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
      </div>
    </div>
  </section>

  <!-- PREVIEW + AREA -->
  <section id="sec-preview" class="hidden" style="margin-top:12px">
    <div class="card pad">
      <div style="position:relative">
        <img id="photo" class="preview-img" alt="Снимок"/>
        <canvas id="polyCanvas" class="poly-canvas"></canvas>
      </div>
      <div id="meta" class="meta"></div>
      <div id="areaBox" class="muted" style="margin-top:8px"></div>

      <div class="tools">
        <button id="btnDetectCircle" class="chip primary">Авто: круг</button>
        <button id="btnManualPoly" class="chip">Контур вручную</button>
        <button id="btnClearPoly" class="chip">Сбросить контур</button>
        <button id="btnRetake" class="btn">Переснять</button>
        <button id="btnSave" class="btn primary">Скачать снимок</button>
      </div>
      <div class="badge">Режим масштабирования: <span id="scaleMode">—</span></div>
    </div>
  </section>
</main>

<script>
/* ===================== CONFIG/STATE ===================== */
const CONFIG = {
  idealFacing: { facingMode: { ideal: 'environment' } },
  maxSide: 2000,
  distTargetCm: 30, distTolCm: 5,             // 30 ± 5 см
  detectEveryMs: 350,
  downscaleW: 256,
};
const S = {
  stream:null, track:null, torchCap:false, _torchOn:false,
  levelOn:false, emaR:null,
  xr:null, xrSession:null, xrRefSpace:null, xrHitSource:null,
  lastDistanceM:null, lastProj:null, lastFov:{x:null,y:null},
  allowShot:false,
  scaleCmPerPx:null,          // после замера расстояния/калибровки
  polygon:[],                 // [{x,y},...]
};

/* ===================== DOM REFS ===================== */
const $ = id => document.getElementById(id);
const err=$('err'), camWrap=$('camWrap'), video=$('video');
const btnOpen=$('btnOpen'), btnStop=$('btnStop'), btnTorch=$('btnTorch'), btnShot=$('btnShot'), fileSystem=$('file-system');
const levelBubble=$('levelBubble'), levelTarget=$('levelTarget'), topHint=$('topHint');
const secCam=$('sec-camera'), secPrev=$('sec-preview'), photo=$('photo'), meta=$('meta'), areaBox=$('areaBox');
const btnRetake=$('btnRetake'), btnSave=$('btnSave'), permHint=$('permHint');
const btnDetectCircle=$('btnDetectCircle'), btnManualPoly=$('btnManualPoly'), btnClearPoly=$('btnClearPoly');
const polyCanvas=$('polyCanvas');
let polyCtx=null;

/* ===================== UTILS ===================== */
function setError(msg,hint){
  if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; }
  const extra = hint ? `<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>` : '';
  err.innerHTML = msg + extra; err.classList.remove('hidden');
}
function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
async function queryCamPerm(){ try{ const p=await navigator.permissions?.query?.({name:'camera'}); return p?.state??null }catch{return null}}

/* ===================== OPEN CAMERA (with AR attempt) ===================== */
btnOpen.addEventListener('click', openFlow);
btnStop.addEventListener('click', ()=>stopAll());
btnTorch.addEventListener('click', toggleTorch);
btnShot.addEventListener('click', onShutter);

async function openFlow(){
  setError(''); S.allowShot=false; btnShot.disabled=true; topHint.classList.remove('ok');
  topHint.textContent = 'Пробуем AR для замера дистанции…';
  await enableLevelSensors();

  const xrOk = await tryStartAR();
  if(!xrOk){
    // fallback: обычная камера + режим карточки для масштаба
    topHint.textContent = 'Режим карточки: протяните отрезок по ширине карты (85.6 мм) после снимка';
    await openCameraGUM();
  }
}

/* ===================== AR (WebXR) ===================== */
async function tryStartAR(){
  try{
    if(!('xr' in navigator)) return false;
    S.xr = navigator.xr;
    const ok = await S.xr.isSessionSupported?.('immersive-ar');
    if(!ok) return false;

    const glCanvas = document.createElement('canvas');
    const gl = glCanvas.getContext('webgl', {xrCompatible:true});
    const session = await S.xr.requestSession('immersive-ar', {
      requiredFeatures:['hit-test','local'],
      optionalFeatures:['dom-overlay','depth-sensing'],
      domOverlay:{root:document.body},
      depthSensing:{usagePreference:['cpu-optimized'], dataFormat:['luminance-alpha']}
    });
    S.xrSession=session;
    await gl.makeXRCompatible?.();
    const layer = new XRWebGLLayer(session, gl);
    session.updateRenderState({baseLayer: layer});
    S.xrRefSpace = await session.requestReferenceSpace('local');

    const viewerSpace = await session.requestReferenceSpace('viewer');
    S.xrHitSource = await session.requestHitTestSource({space: viewerSpace});

    const onXRFrame = (time, frame)=>{
      session.requestAnimationFrame(onXRFrame);
      const pose = frame.getViewerPose(S.xrRefSpace);
      if(!pose) return;
      const view = pose.views[0];
      S.lastProj = view.projectionMatrix; // 4x4
      S.lastFov.x = 2*Math.atan(1/(S.lastProj[0]))   // rad
      S.lastFov.y = 2*Math.atan(1/(S.lastProj[5]))   // rad

      const hits = frame.getHitTestResults(S.xrHitSource);
      if(hits.length){
        const hitPose = hits[0].getPose(S.xrRefSpace);
        const camPos = pose.transform.position;
        const h = hitPose.transform.position;
        const dx=h.x-camPos.x, dy=h.y-camPos.y, dz=h.z-camPos.z;
        const distM = Math.hypot(dx,dy,dz);
        S.lastDistanceM = distM;
        const cm = Math.round(distM*100);
        const inBand = Math.abs(cm - CONFIG.distTargetCm) <= CONFIG.distTolCm;
        topHint.textContent = `Дистанция: ${cm} см ${inBand ? '— ОК' : '(цель 30±5 см)'}`;
        topHint.classList.toggle('ok', inBand);
        S.allowShot = inBand;
        btnShot.disabled = !inBand;
      }else{
        topHint.textContent = 'Ищем горизонтальную плоскость… медленно двигайте телефон';
        topHint.classList.remove('ok'); S.allowShot=false; btnShot.disabled=true;
      }
    };
    session.requestAnimationFrame(onXRFrame);
    // Параллельно поднимаем обычную камеру, чтобы после AR сразу снять
    await openCameraGUM();
    return true;
  }catch(e){
    console.warn('AR failed', e);
    return false;
  }
}

async function onShutter(){
  if(!S.allowShot){ haptic(); return; }
  haptic();
  // Сохраняем масштаб по AR (если есть), иначе масштаб зададим позже из карточки
  if(S.lastDistanceM && S.lastFov.y){
    // cm per pixel по высоте кадра
    const H = video.videoHeight || video.videoWidth || 1080; // перестраховка
    const sceneHeightM = 2*S.lastDistanceM*Math.tan(S.lastFov.y/2);
    S.scaleCmPerPx = (sceneHeightM*100)/H; // см/пикс
    $('scaleMode').textContent = `AR: ${S.scaleCmPerPx.toFixed(3)} см/пикс при ${Math.round(S.lastDistanceM*100)} см`;
  }else{
    S.scaleCmPerPx = null;
    $('scaleMode').textContent = 'Карта (после снимка)';
  }
  await takeShot(); // снимок с обычной камеры
}

/* ===================== getUserMedia camera ===================== */
async function openCameraGUM(){
  if(!canUseGUM()){
    setError('Камера недоступна.', envHint()); try{ fileSystem?.click(); }catch{}; return false;
  }
  const perm = await queryCamPerm();
  if(perm==='denied'){ setError('Доступ к камере запрещён.', envHint()); return false; }
  try{
    const s = await navigator.mediaDevices.getUserMedia({video: CONFIG.idealFacing, audio:false});
    await bindStream(s);
    // Torch capability
    const caps = S.track?.getCapabilities?.() || {};
    S.torchCap = !!caps.torch;
    btnTorch.classList.toggle('hidden', !S.torchCap);
    return true;
  }catch(e){
    console.warn(e); setError('Не удалось открыть камеру.', envHint()); return false;
  }
}
async function bindStream(stream){
  stopCamera();
  S.stream=stream; S.track=stream.getVideoTracks()[0];
  video.srcObject=stream; try{ await video.play(); }catch{}
  secCam.classList.remove('hidden'); secPrev.classList.add('hidden');
}
function stopCamera(){
  try{ video.pause(); video.srcObject=null }catch{}
  try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}
  S.stream=null; S.track=null;
}
async function toggleTorch(){
  if(!S.track || !S.torchCap) return;
  try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }
  catch{ btnTorch.classList.add('hidden'); }
}
async function takeShot(){
  if(!video.videoWidth || !video.videoHeight) return;
  const srcW=video.videoWidth, srcH=video.videoHeight;
  const scale = Math.min(1, CONFIG.maxSide/Math.max(srcW,srcH));
  const w=Math.max(1,Math.round(srcW*scale)), h=Math.max(1,Math.round(srcH*scale));
  const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(video,0,0,w,h);
  let url = c.toDataURL('image/webp',0.85), type='image/webp';
  if(!/^data:image\/webp/.test(url)){ url=c.toDataURL('image/jpeg',0.85); type='image/jpeg'; }
  showPreview(url,w,h,type);
  stopCamera();
}

/* ===================== PREVIEW + AREA ===================== */
function showPreview(dataUrl,w,h,type){
  photo.src=dataUrl; meta.textContent = `${w}×${h} • ${type}`;
  secCam.classList.add('hidden'); secPrev.classList.remove('hidden');
  // подготовка холста для полигона
  polyCanvas.width = photo.clientWidth; polyCanvas.height = photo.clientHeight;
  polyCtx = polyCanvas.getContext('2d');
  S.polygon = []; drawPoly();
  areaBox.textContent = S.scaleCmPerPx ? `Масштаб: ${S.scaleCmPerPx.toFixed(3)} см/пикс` :
    `Масштаб неизвестен: воспользуйтесь «карточкой» — кнопка «Контур вручную», затем «Указать карту».`;
}

btnSave.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=photo.src; a.download='photo.jpg'; document.body.appendChild(a); a.click(); a.remove(); });
btnRetake.addEventListener('click', ()=>{ secPrev.classList.add('hidden'); secCam.classList.remove('hidden'); openFlow(); });

/* ====== Авто: круг ====== */
btnDetectCircle.addEventListener('click', async ()=>{
  const img = await imgToCanvas(photo);
  const res = detectPlateCircle(img.canvas, CONFIG.downscaleW);
  if(!res || res.conf < 0.2){ areaBox.textContent='Круг не найден. Попробуйте «Контур вручную».'; return; }
  const scale = await ensureScaleViaCardIfNeeded();
  if(!scale){ areaBox.textContent='Нужен масштаб: укажите ширину карты.'; return; }
  const rPx = res.r * (img.scale); // back to preview pixel space
  const areaCm2 = Math.PI * Math.pow(rPx* S.scaleCmPerPx, 2);
  areaBox.textContent = `Площадь (круг): ${areaCm2.toFixed(0)} см²  — r≈${(rPx*S.scaleCmPerPx).toFixed(1)} см`;
});

/* ====== Контур вручную ====== */
let polyActive=false, cardMode=false, cardLine=null;
btnManualPoly.addEventListener('click', ()=>{
  polyActive = !polyActive;
  btnManualPoly.classList.toggle('primary', polyActive);
  if(polyActive){ areaBox.textContent='Тапайте по контуру тарелки (2+ точек). Двойной тап замыкает контур. Долгий тап — «карточка».'; }
});
btnClearPoly.addEventListener('click', ()=>{ S.polygon=[]; cardMode=false; cardLine=null; drawPoly(); });

polyCanvas.addEventListener('pointerdown', (e)=>{
  if(!polyActive) return;
  const {x,y} = canvasPoint(e);
  const now = performance.now();
  // длинный тап = режим карточки (масштаб)
  let long=false; const t=setTimeout(()=>{ long=true; cardMode=true; cardLine={a:{x,y},b:{x,y}}; drawPoly(); }, 420);
  const up = ()=>{
    clearTimeout(t);
    polyCanvas.removeEventListener('pointerup', up);
    if(cardMode && cardLine){ /* остаёмся в режиме перетаскивания второй точки */ }
    else if(!long){
      // обычная точка полигона
      const last=S._lastTap||0; if(now-last<280 && S.polygon.length>=2){ /* двойной тап */ closePoly(); }
      else { S.polygon.push({x,y}); drawPoly(); }
      S._lastTap=now;
    }
  };
  polyCanvas.addEventListener('pointerup', up);
});
polyCanvas.addEventListener('pointermove', (e)=>{
  if(cardMode && cardLine){ cardLine.b = canvasPoint(e); drawPoly(); }
});
polyCanvas.addEventListener('pointerup', async ()=>{
  if(cardMode && cardLine){
    const px = Math.hypot(cardLine.a.x-cardLine.b.x, cardLine.a.y-cardLine.b.y);
    if(px<10){ areaBox.textContent='Линия слишком короткая для калибровки.'; cardMode=false; cardLine=null; drawPoly(); return; }
    const cm = 8.56; S.scaleCmPerPx = cm/px;
    $('scaleMode').textContent = `Карта: ${S.scaleCmPerPx.toFixed(3)} см/пикс`;
    areaBox.textContent = `Масштаб по карте: ${S.scaleCmPerPx.toFixed(3)} см/пикс`;
    cardMode=false; cardLine=null; drawPoly();
  }
});

function closePoly(){
  if(S.polygon.length<3){ areaBox.textContent='Нужно ≥3 точки.'; return; }
  ensureScaleViaCardIfNeeded().then(ok=>{
    if(!ok){ areaBox.textContent='Нужен масштаб (карточка): долгий тап на изображении — протяни по ширине карты.'; return; }
    const areaPx2 = polygonArea(S.polygon);
    const areaCm2 = areaPx2 * Math.pow(S.scaleCmPerPx,2);
    areaBox.textContent = `Площадь (контур): ${areaCm2.toFixed(0)} см²`;
  });
  drawPoly(true);
}

function drawPoly(closed=false){
  if(!polyCtx){ polyCtx = polyCanvas.getContext('2d'); }
  polyCtx.clearRect(0,0,polyCanvas.width, polyCanvas.height);
  // polygon
  if(S.polygon.length){
    polyCtx.strokeStyle='#2563eb'; polyCtx.lineWidth=2; polyCtx.beginPath();
    S.polygon.forEach((p,i)=>{ if(i===0) polyCtx.moveTo(p.x,p.y); else polyCtx.lineTo(p.x,p.y); });
    if(closed) polyCtx.closePath();
    polyCtx.stroke();
    // points
    for(const p of S.polygon){ polyCtx.fillStyle='#2563eb'; polyCtx.beginPath(); polyCtx.arc(p.x,p.y,3,0,Math.PI*2); polyCtx.fill(); }
  }
  // card line
  if(cardLine){
    polyCtx.strokeStyle='#10b981'; polyCtx.lineWidth=3; polyCtx.beginPath();
    polyCtx.moveTo(cardLine.a.x, cardLine.a.y); polyCtx.lineTo(cardLine.b.x, cardLine.b.y); polyCtx.stroke();
  }
}

/* ===================== HELPERS (img + geometry) ===================== */
async function imgToCanvas(imgEl){
  // вернём канву исходного разрешения превью
  const w = imgEl.naturalWidth, h=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=w; c.height=h; const ctx=c.getContext('2d'); ctx.drawImage(imgEl,0,0,w,h);
  // для детектора мы даунскейлим до downscaleW по ширине
  const scale = (imgEl.clientWidth? (imgEl.clientWidth / w) : 1); // перевод радиуса из даунскейла обратно в пиксели превью
  return {canvas:c, scale: (imgEl.clientWidth? (imgEl.clientWidth / (CONFIG.downscaleW)) : 1) };
}
function polygonArea(pts){
  let s=0; for(let i=0;i<pts.length;i++){ const a=pts[i], b=pts[(i+1)%pts.length]; s+=a.x*b.y-b.x*a.y; } return Math.abs(s)/2;
}
function canvasPoint(e){
  const r = polyCanvas.getBoundingClientRect();
  return { x: (e.clientX - r.left), y:(e.clientY - r.top) };
}

/* ===================== CIRCLE DETECTOR (as before) ===================== */
function detectPlateCircle(sourceCanvas, outW){
  const vw=sourceCanvas.width, vh=sourceCanvas.height;
  const scale=outW/vw; const ow=Math.max(64,Math.round(vw*scale)), oh=Math.max(64,Math.round(vh*scale));
  const c=document.createElement('canvas'); c.width=ow; c.height=oh; const ctx=c.getContext('2d');
  ctx.drawImage(sourceCanvas,0,0,ow,oh);
  const img = ctx.getImageData(0,0,ow,oh); const data=img.data;
  const gray=new Uint8ClampedArray(ow*oh);
  for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j]=(data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114)|0; }
  const mag=new Float32Array(ow*oh);
  const idx=(x,y)=>y*ow+x;
  for(let y=1;y<oh-1;y++){
    for(let x=1;x<ow-1;x++){
      const gxm = -gray[idx(x-1,y-1)] -2*gray[idx(x-1,y)] -gray[idx(x-1,y+1)] + gray[idx(x+1,y-1)] +2*gray[idx(x+1,y)] + gray[idx(x+1,y+1)];
      const gym = -gray[idx(x-1,y-1)] -2*gray[idx(x,y-1)] -gray[idx(x+1,y-1)] + gray[idx(x-1,y+1)] +2*gray[idx(x,y+1)] + gray[idx(x+1,y+1)];
      mag[idx(x,y)] = Math.abs(gxm)+Math.abs(gym);
    }
  }
  let maxM=1; for(let i=0;i<mag.length;i++) if(mag[i]>maxM) maxM=mag[i];
  const cx=ow/2, cy=oh/2, minSide=Math.min(ow,oh);
  const rMin=Math.max(12,Math.round(minSide*0.18)), rMax=Math.round(minSide*0.48);
  const step=2, samples=48; let best={r:0,score:-1}; const twoPi=Math.PI*2;
  for(let r=rMin;r<=rMax;r+=step){
    let s=0; for(let k=0;k<samples;k++){ const a=twoPi*k/samples; const x=(cx+r*Math.cos(a))|0, y=(cy+r*Math.sin(a))|0; s+=mag[idx(x,y)]; }
    const sc = s/(samples*maxM+1e-6); if(sc>best.score) best={r,score:sc};
  }
  return {r:best.r, conf:best.score, w:ow, h:oh};
}

/* ===================== LEVEL SENSORS ===================== */
async function enableLevelSensors(){
  if(S.levelOn) return; let ok=false;
  try{
    if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{}
    }
    if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; }
    if(!ok){
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{}
      }else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; }
    }
  }catch{}
  S.levelOn=ok; permHint.classList.toggle('hidden', ok);
}
function onOrient(e){ const pitch=e.beta??0, roll=e.gamma??0; paintLevel(pitch,roll) }
function onMotion(e){ const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0;
  const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; paintLevel(pitch,roll);
}
function paintLevel(pitch, roll){
  const R=70, T=18, nx=clamp(roll/30,-1,1), ny=clamp(pitch/30,-1,1);
  const dx=nx*R*0.45, dy=-ny*R*0.45;
  levelBubble.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  const ok = Math.hypot(dx,dy)<=T; levelBubble.classList.toggle('ok',ok); levelTarget.classList.toggle('ok',ok);
}

/* ===================== MISC ===================== */
function envHint(){
  const https = !isSecureContext ? '\n• Нужен HTTPS (или localhost).' : '';
  return 'Проверьте разрешения на камеру.'+https+'\n• WebXR работает в Chrome Android с ARCore.\n• В остальных средах используйте режим «карточки».';
}
window.addEventListener('beforeunload', ()=>stopAll());
function stopAll(){
  try{ S.xrSession?.end?.() }catch{}; S.xrSession=null; S.xrRefSpace=null; S.xrHitSource=null;
  stopCamera();
}

/* ===================== SCALE FALLBACK (card) ===================== */
async function ensureScaleViaCardIfNeeded(){
  if(S.scaleCmPerPx) return true;
  areaBox.textContent='Долгий тап — протяните линию по ширине банковской карты (85.6 мм).';
  return false;
}

/* ===================== TESTS ===================== */
(function testFov(){
  const f = 2*Math.atan(1/1.2); console.log('[fov test rad≈]', f.toFixed(3));
})();
(function testShoelace(){
  const sq=[{x:0,y:0},{x:10,y:0},{x:10,y:10},{x:0,y:10}]; const a=polygonArea(sq);
  console.log('[shoelace 10x10]', a===100?'OK':'CHK '+a);
})();
</script>
</body>
</html>
