<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam ‚Äî –∞–∫—É—Å—Ç–∏—á–µ—Å–∫–∏–π –¥–∞–ª—å–Ω–æ–º–µ—Ä (BOOST, –±–µ–∑ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ñ–æ–ª–±—ç–∫–∞)</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:0 0 6px}
    .muted{color:var(--muted);font-size:14px;margin:0 0 12px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    /* Buttons */
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px; border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn.ghost{background:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* CAMERA */
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
    .cam-video{width:100%;height:100%;object-fit:cover;display:block}
    .cam-overlay{position:absolute;inset:0;pointer-events:none}

    /* grid */
    .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    /* top info bar */
    .topbar{position:absolute;left:0;right:0;top:10px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}
    .chip.ok{background:rgba(22,163,74,.9)} .chip.warn{background:rgba(245,158,11,.95)} .chip.bad{background:rgba(239,68,68,.95)}

    /* Torch */
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}

    /* Level (center) */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:140px;height:140px;border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.2);backdrop-filter:blur(4px)}
    .level-target{position:absolute;left:50%;top:50%;width:36px;height:36px;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.55)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;width:22px;height:22px;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
    .level-bubble.ok{background:#22c55e}

    /* bottom controls */
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    /* settings panel */
    .panel{border:1px solid var(--ring);border-radius:16px;padding:12px;background:#fff;margin:12px 0}
    .panel h3{margin:0 0 8px;font-size:16px}
    .field{display:flex;align-items:center;gap:10px;margin:8px 0}
    .field label{min-width:140px;color:#374151}
    input[type="range"]{width:220px}

    /* preview */
    .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
    .pad{padding:14px}
    .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    .badge{font-size:12px;color:#64748b}
  </style>
</head>
<body>
  <main class="container">
    <header>
      <h1>–ö–∞–º–µ—Ä–∞ —Å —É—Ä–æ–≤–Ω–µ–º + –∞–∫—É—Å—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–º–µ—Ä –≤—ã—Å–æ—Ç—ã (25‚Äì35 —Å–º)</h1>
      <p class="muted">–ï—Å–ª–∏ —ç—Ö–æ –Ω–µ —Å–ª—ã—à–Ω–æ ‚Äî –≤–∫–ª—é—á–∏ <b>BOOST</b>. –ê–ª–≥–æ—Ä–∏—Ç–º —Å–∞–º –ø–æ–¥–±–µ—Ä—ë—Ç –ø–æ–ª–æ—Å—É/–≥—Ä–æ–º–∫–æ—Å—Ç—å, –ø—Ä–∏–º–µ–Ω–∏—Ç —Ñ–∏–ª—å—Ç—Ä –∏ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ. –ù–∏—á–µ–≥–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è ‚Äî –≤—Å—ë –ª–æ–∫–∞–ª—å–Ω–æ.</p>
    </header>

    <div id="err" class="error hidden"></div>

    <!-- SETTINGS (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏/–ø–æ–¥–±–æ—Ä–∞ –∞–∫—É—Å—Ç–∏–∫–∏) -->
    <section class="panel" id="panel">
      <h3>–ê–∫—É—Å—Ç–∏–∫–∞ ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏/BOOST</h3>
      <div class="field"><label>–ê–≤—Ç–æ–Ω–∞—Å—Ç—Ä–æ–π–∫–∞ (BOOST)</label><input id="boost" type="checkbox" checked><span class="badge">—Å–∫–∞–Ω –ø–æ–ª–æ—Å + BPF + –º—É–ª—å—Ç–∏-—á–∏—Ä–ø</span></div>
      <div class="field"><label>–ì—Ä–æ–º–∫–æ—Å—Ç—å</label><input id="gain" type="range" min="0.02" max="0.12" step="0.005" value="0.06"><span class="badge" id="gainVal">0.06</span></div>
      <div class="field"><label>–î–∏–∞–ø–∞–∑–æ–Ω (–∫–ì—Ü)</label>
        <select id="band">
          <option value="10000-12000">10‚Äì12</option>
          <option value="12000-14000">12‚Äì14</option>
          <option value="13000-16000" selected>13‚Äì16</option>
        </select>
      </div>
      <div class="field"><label>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —á–∏—Ä–ø–∞ (–º—Å)</label><input id="chirpMs" type="range" min="120" max="360" step="20" value="160"><span class="badge" id="chirpVal">160</span></div>
      <div class="field"><label>–¢–µ—Å—Ç–æ–≤—ã–π –ø–∏–Ω–≥</label><button id="btnPing" class="btn">–ü–∏–Ω–≥ —Å–µ–π—á–∞—Å</button><span class="badge" id="diag">r=‚Äî, —à—É–º=‚Äî</span></div>
      <div class="field"><label>–ü—Ä–æ–±–ª–µ–º—ã —Å–æ –∑–≤—É–∫–æ–º?</label><button id="btnAudioResume" class="btn">–í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫</button><span class="badge">iOS: —Å–Ω–∏–º–∏—Ç–µ –±–µ–∑–∑–≤—É—á–Ω—ã–π —Ä–µ–∂–∏–º</span></div>
      <div class="field"><label>–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ AEC</label><button id="btnLoopback" class="btn">–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä—è–º–æ–π –Ω–∞–≤–æ–¥–∫–∏</button><span class="badge" id="loopDiag">‚Äî</span></div>
      <div class="field"><label>–°–æ–≤–µ—Ç—ã</label><span class="badge">–£–±–µ—Ä–∏—Ç–µ –≥–∞—Ä–Ω–∏—Ç—É—Ä—É ‚Ä¢ –ñ—ë—Å—Ç–∫–∞—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å ‚Ä¢ –ü–æ–≤–µ—Ä–Ω–∏—Ç–µ –¥–∏–Ω–∞–º–∏–∫ –∫ —Å—Ç–æ–ª—É</span></div>
    </section>

    <!-- CAMERA -->
    <section id="sec-camera">
      <div class="row" style="margin-bottom:10px">
        <button id="btnOpen" class="btn primary">–û—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É</button>
        <button id="btnStop" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        <span id="permHint" class="badge">–†–∞–∑—Ä–µ—à–∏—Ç–µ –º–∏–∫—Ä–æ—Ñ–æ–Ω –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é</span>
        <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden" />
      </div>

      <div class="cam-wrap" id="camWrap" aria-label="–ñ–∏–≤–æ–µ –ø—Ä–µ–≤—å—é –∫–∞–º–µ—Ä—ã">
        <video id="video" class="cam-video" playsinline muted></video>

        <div class="cam-overlay">
          <div class="grid"></div>

          <!-- top info -->
          <div class="topbar">
            <div id="chipDist" class="chip">–ì–æ—Ç–æ–≤–∏–º—Å—è –∫ –∑–∞–º–µ—Ä—É‚Ä¶</div>
            <div id="chipMic" class="chip">üéôÔ∏è –ú–∏–∫—Ä–æ—Ñ–æ–Ω: –ª–æ–∫–∞–ª—å–Ω–æ</div>
          </div>

          <!-- torch -->
          <button id="btnTorch" class="btn-torch hidden" aria-label="–§–æ–Ω–∞—Ä–∏–∫">‚ö°Ô∏è</button>

          <!-- level -->
          <div class="center-level">
            <div class="level-outer">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>
        </div>

        <div class="controls">
          <button id="btnShot" class="shutter" aria-label="–°–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫" disabled></button>
        </div>
      </div>
    </section>

    <!-- PREVIEW -->
    <section id="sec-preview" class="hidden" style="margin-top:12px">
      <div class="card pad">
        <img id="photo" class="preview-img" alt="–°–Ω–∏–º–æ–∫" />
        <div id="meta" class="meta"></div>
        <div class="row" style="margin-top:10px">
          <button id="btnRetake" class="btn">–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
          <button id="btnSave" class="btn primary">–°–∫–∞—á–∞—Ç—å —Å–Ω–∏–º–æ–∫</button>
        </div>
      </div>
    </section>
  </main>

  <script>
  // ===================== CONFIG / STATE =====================
  const CONFIG = {
    idealFacing: { facingMode: { ideal: 'environment' } },
    maxSide: 2000,
    bandMinCm: 25, bandMaxCm: 35,

    pingHz: 3,
    chirpMs: 160,
    f0: 13000, f1: 16000,
    gain: 0.06,
    minLagCm: 8, maxLagCm: 80,
    goodSeq: 3,
    corrThresh: 0.2,

    // BOOST
    boost: true,
    bands: [[10000,12000],[12000,14000],[13000,16000]],
    gainSteps: [0.06,0.09,0.12],
    scanChirpMs: 260,
    scanMinCm: 5, scanMaxCm: 120,
  };

  const S = {
    // camera
    stream:null, track:null, torchCap:false, _torchOn:false,
    // ui
    allowShot:false, okSeq:0,
    // level
    levelOn:false,
    // audio
    actx:null, mic:null, bpf:null, proc:null, ring:new Float32Array(0), ringPos:0, ringSize:0,
    refChirp:null, refEnergy:0, fs:44100,
    pingTimer:null,
    // diagnostics
    rLast:null, noiseRMS:null,
  };

  // ===================== DOM =====================
  const $ = id => document.getElementById(id);
  const err=$('err'), video=$('video');
  const btnOpen=$('btnOpen'), btnStop=$('btnStop'), btnTorch=$('btnTorch'), btnShot=$('btnShot'), fileSystem=$('file-system');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget');
  const chipDist=$('chipDist'), chipMic=$('chipMic');
  const secCam=$('sec-camera'), secPrev=$('sec-preview'), photo=$('photo'), meta=$('meta');
  const btnRetake=$('btnRetake'), btnSave=$('btnSave'), permHint=$('permHint');
  const gain=$('gain'), gainVal=$('gainVal'), band=$('band'), btnPing=$('btnPing'), diag=$('diag');
  const chirpMs=$('chirpMs'), chirpVal=$('chirpVal');
  const btnAudioResume=$('btnAudioResume');
  const btnLoopback=$('btnLoopback'), loopDiag=$('loopDiag');
  const boost=$('boost');

  // ===================== UTILS =====================
  function setError(msg,hint){ if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; } const extra = hint?`<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>`:''; err.innerHTML = msg + extra; err.classList.remove('hidden'); }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
  function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
  async function queryPerm(name){ try{ const p=await navigator.permissions?.query?.({name}); return p?.state??null }catch{return null} }
  function cmFromLagSamples(N){ return (N / S.fs) * 34300 / 2; }
  function lagSamplesFromCm(cm){ return Math.round((cm*2/34300)*S.fs); }
  function rms(buf){ let s=0; for(let i=0;i<buf.length;i++){ const v=buf[i]; s+=v*v; } return Math.sqrt(s/buf.length); }
  function dot(a,b){ const n=Math.min(a.length,b.length); let sum=0; for(let i=0;i<n;i++){ sum+=a[i]*b[i]; } return sum; }

  // ===================== CAMERA FLOW =====================
  btnOpen.addEventListener('click', openFlow);
  btnStop.addEventListener('click', ()=>stopAll());
  btnTorch.addEventListener('click', toggleTorch);
  btnShot.addEventListener('click', onShutter);
  btnSave.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=photo.src; a.download='photo.jpg'; document.body.appendChild(a); a.click(); a.remove(); });
  btnRetake.addEventListener('click', ()=>{ secPrev.classList.add('hidden'); secCam.classList.remove('hidden'); openFlow(); });

  gain.addEventListener('input', ()=>{ CONFIG.gain=parseFloat(gain.value); gainVal.textContent=CONFIG.gain.toFixed(3); });
  band.addEventListener('change', ()=>{ const [f0,f1]=band.value.split('-').map(x=>parseInt(x,10)); CONFIG.f0=f0; CONFIG.f1=f1; buildChirp(); updateBPF(); });
  chirpMs.addEventListener('input', ()=>{ CONFIG.chirpMs=parseInt(chirpMs.value,10); chirpVal.textContent=String(CONFIG.chirpMs); buildChirp(); });
  btnPing.addEventListener('click', async ()=>{ await singlePing(true); });
  btnAudioResume.addEventListener('click', async ()=>{ try{ await S.actx?.resume?.(); }catch{} });
  boost.addEventListener('change', ()=>{ CONFIG.boost = boost.checked; });
  btnLoopback.addEventListener('click', loopbackTest);

  async function openFlow(){
    setError(''); S.allowShot=false; btnShot.disabled=true; chipDist.className='chip'; chipDist.textContent='–ì–æ—Ç–æ–≤–∏–º—Å—è –∫ –∑–∞–º–µ—Ä—É‚Ä¶';
    await enableLevelSensors();
    const camOk = await openCameraGUM(); if(!camOk){ try{ fileSystem?.click(); }catch{} }
    const audOk = await initAudio(); if(!audOk){ setError('–ù–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É/–∞—É–¥–∏–æ.', envHint()); return; }
    if(CONFIG.boost){ await autoTune(); }
    startAcousticLoop();
  }

  async function openCameraGUM(){
    if(!canUseGUM()){ setError('–ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.', envHint()); return false; }
    const perm = await queryPerm('camera'); if(perm==='denied'){ setError('–î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∑–∞–ø—Ä–µ—â—ë–Ω.', envHint()); return false; }
    try{ const s = await navigator.mediaDevices.getUserMedia({video: CONFIG.idealFacing, audio:false}); await bindStream(s); const caps=S.track?.getCapabilities?.()||{}; btnTorch.classList.toggle('hidden', !caps.torch); S.torchCap=!!caps.torch; return true; }catch(e){ console.warn(e); setError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É.', envHint()); return false; }
  }
  async function bindStream(stream){ stopCamera(); S.stream=stream; S.track=stream.getVideoTracks()[0]; video.srcObject=stream; try{ await video.play(); }catch{}; secCam.classList.remove('hidden'); secPrev.classList.add('hidden'); }
  function stopCamera(){ try{ video.pause(); video.srcObject=null }catch{}; try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}; S.stream=null; S.track=null; }
  async function toggleTorch(){ if(!S.track || !S.torchCap) return; try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }catch{ btnTorch.classList.add('hidden'); } }

  async function onShutter(){ if(!S.allowShot){ haptic(); return; } haptic(); await takeShot(); }
  async function takeShot(){ if(!video.videoWidth || !video.videoHeight) return; const srcW=video.videoWidth, srcH=video.videoHeight; const scale = Math.min(1, CONFIG.maxSide/Math.max(srcW,srcH)); const w=Math.max(1,Math.round(srcW*scale)), h=Math.max(1,Math.round(srcH*scale)); const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(video,0,0,w,h); let url = c.toDataURL('image/webp',0.85), type='image/webp'; if(!/^data:image\/webp/.test(url)){ url=c.toDataURL('image/jpeg',0.85); type='image/jpeg'; } photo.src=url; meta.textContent = `${w}√ó${h} ‚Ä¢ ${type}`; secCam.classList.add('hidden'); secPrev.classList.remove('hidden'); }

  // ===================== AUDIO (ACOUSTIC RANGE) =====================
  async function initAudio(){
    try{
      S.actx = new (window.AudioContext || window.webkitAudioContext)();
      if(S.actx.state!=='running'){ try{ await S.actx.resume(); }catch{} }
      S.fs = S.actx.sampleRate || 44100;
      const micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } });
      S.mic = S.actx.createMediaStreamSource(micStream);

      // Bandpass filter for analysis
      S.bpf = S.actx.createBiquadFilter(); S.bpf.type = 'bandpass'; updateBPF();

      // ScriptProcessor (for broad support)
      const bufSize = 4096; S.proc = S.actx.createScriptProcessor(bufSize, 1, 1);
      S.ringSize = Math.max(S.fs*0.8|0, 44100); // ~0.8s ring
      S.ring = new Float32Array(S.ringSize); S.ringPos=0;
      S.proc.onaudioprocess = (e)=>{ const inp = e.inputBuffer.getChannelData(0); S.noiseRMS = rms(inp); let p=S.ringPos; const N=inp.length; for(let i=0;i<N;i++){ S.ring[p]=inp[i]; if(++p>=S.ringSize) p=0; } S.ringPos=p; const out=e.outputBuffer.getChannelData(0); for(let i=0;i<N;i++) out[i]=0; };

      // connect graph: mic -> bpf -> proc -> destination (muted)
      S.mic.connect(S.bpf); S.bpf.connect(S.proc); S.proc.connect(S.actx.destination);

      buildChirp();

      // Echo-cancel info
      try{ const st=micStream.getAudioTracks?.()[0]?.getSettings?.()||{}; chipMic.textContent = `üéôÔ∏è –ú–∏–∫—Ä–æ—Ñ–æ–Ω: –ª–æ–∫–∞–ª—å–Ω–æ ‚Ä¢ AEC: ${st.echoCancellation===true?'–≤–∫–ª':st.echoCancellation===false?'–≤—ã–∫–ª':'–Ω–µ–∏–∑–≤.'}`; }catch{}

      return true;
    }catch(e){ console.warn('initAudio failed', e); return false; }
  }

  function buildChirp(){ S.refChirp = makeChirp(S.fs, CONFIG.chirpMs/1000, CONFIG.f0, CONFIG.f1); S.refEnergy = dot(S.refChirp, S.refChirp); }
  function updateBPF(){ const center=(CONFIG.f0+CONFIG.f1)/2; const bw=(CONFIG.f1-CONFIG.f0); const nyq=S.fs/2; const safeCenter=Math.min(center, nyq*0.9); const Q=Math.max(0.0001, safeCenter/Math.max(200,bw)); try{ S.bpf.frequency.value=safeCenter; S.bpf.Q.value=Q; }catch{} }

  function makeChirp(fs, dur, f0, f1){ const N=Math.max(1,Math.round(fs*dur)); const buf=new Float32Array(N); const w=(i)=>0.5-0.5*Math.cos(2*Math.PI*i/(N-1)); const K=(f1-f0)/(2*dur); for(let n=0;n<N;n++){ const t=n/fs; const phase=2*Math.PI*(f0*t + K*t*t); buf[n]=Math.sin(phase)*w(n); } return buf; }

  function playChirp(){ const src=S.actx.createBufferSource(); const g=S.actx.createGain(); g.gain.value=CONFIG.gain; const b=S.actx.createBuffer(1, S.refChirp.length, S.fs); b.copyToChannel(S.refChirp,0,0); src.buffer=b; src.connect(g); g.connect(S.actx.destination); src.start(); return new Promise(res=>{ src.onended=res; }); }

  function ringSlice(lastSamples){ const N=Math.min(lastSamples, S.ringSize); const out=new Float32Array(N); const start=(S.ringPos - N + S.ringSize) % S.ringSize; if(start+N<=S.ringSize){ out.set(S.ring.subarray(start,start+N)); } else { const first=S.ringSize-start; out.set(S.ring.subarray(start,S.ringSize),0); out.set(S.ring.subarray(0,N-first),first); } return out; }

  function correlate(ref, rec, minLag, maxLag){ const refN=ref.length; const refE=S.refEnergy||dot(ref,ref); let bestLag=-1, bestR=-1; for(let lag=minLag; lag<=maxLag; lag++){ if(lag+refN>=rec.length) break; let a=0,b=0; for(let i=0;i<refN;i++){ const v=rec[lag+i]; a+=ref[i]*v; b+=v*v; } const r=a/Math.sqrt((refE+1e-9)*(b+1e-9)); if(r>bestR){ bestR=r; bestLag=lag; } } return {lag:bestLag, r:bestR}; }

  async function singlePing(showDiag){ await ensureAudio(); await playChirp(); const takeMs = Math.max(CONFIG.chirpMs + 200, 240); const rec = ringSlice(Math.round(S.fs * takeMs/1000) + S.refChirp.length + 1024); const minLag=lagSamplesFromCm(CONFIG.minLagCm); const maxLag=lagSamplesFromCm(CONFIG.maxLagCm); const {lag, r}=correlate(S.refChirp, rec, minLag, maxLag); S.rLast=r; if(showDiag){ diag.textContent = `r=${r?.toFixed?.(2) ?? '‚Äî'}, —à—É–º=${(S.noiseRMS||0).toFixed(3)}`; } return {lag,r}; }

  async function ensureAudio(){ if(S.actx && S.actx.state!=='running'){ try{ await S.actx.resume(); }catch{} } }

  async function autoTune(){
    const nyq = (S.fs||44100)/2;
    let best={r:-1,f0:CONFIG.f0,f1:CONFIG.f1,gain:CONFIG.gain};
    const bands = CONFIG.bands.filter(([f0,f1])=> f1 < nyq*0.95);
    const old = {f0:CONFIG.f0,f1:CONFIG.f1,gain:CONFIG.gain,chirpMs:CONFIG.chirpMs};

    CONFIG.chirpMs = CONFIG.scanChirpMs; buildChirp();
    const minLag=lagSamplesFromCm(CONFIG.scanMinCm), maxLag=lagSamplesFromCm(CONFIG.scanMaxCm);

    for(const g of CONFIG.gainSteps){
      CONFIG.gain=g;
      for(const [f0,f1] of bands){
        CONFIG.f0=f0; CONFIG.f1=f1; buildChirp(); updateBPF();
        // —É—Å—Ä–µ–¥–Ω—è–µ–º 2 –ø–∏–Ω–≥–∞
        let acc=0, n=0; for(let k=0;k<2;k++){ await ensureAudio(); await playChirp(); const rec=ringSlice(Math.round(S.fs*(CONFIG.chirpMs+240)/1000)+S.refChirp.length+1024); const {r}=correlate(S.refChirp, rec, minLag, maxLag); if(isFinite(r)){ acc+=r; n++; } }
        const rMean = n? acc/n : -1;
        if(rMean>best.r){ best={r:rMean,f0,f1,gain:g}; }
      }
      // —Ä–∞–Ω–Ω–∏–π –≤—ã—Ö–æ–¥ –µ—Å–ª–∏ —É–∂–µ —Ö–æ—Ä–æ—à–æ
      if(best.r>=0.25) break;
    }

    // –ø—Ä–∏–º–µ–Ω—è–µ–º
    CONFIG.f0=best.f0; CONFIG.f1=best.f1; CONFIG.gain=best.gain; buildChirp(); updateBPF();
    band.value = `${CONFIG.f0}-${CONFIG.f1}`;
    gain.value = CONFIG.gain; gainVal.textContent = CONFIG.gain.toFixed(2);
    chipDist.textContent = `BOOST: –ø–æ–ª–æ—Å–∞ ${Math.round(CONFIG.f0/1000)}‚Äì${Math.round(CONFIG.f1/1000)} –∫–ì—Ü, r‚âà${best.r.toFixed(2)}`;

    // –≤–µ—Ä–Ω—É—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    CONFIG.chirpMs = parseInt(chirpMs.value,10) || old.chirpMs; buildChirp();
  }

  async function loopbackTest(){
    // –∏–∑–º–µ—Ä—è–µ–º –∫–æ—Ä—Ä–µ–ª—è—Ü–∏—é –≤–±–ª–∏–∑–∏ –Ω—É–ª–µ–≤–æ–≥–æ –ª–∞–≥–∞ ‚Äî –µ—Å—Ç—å –ª–∏ –ø—Ä—è–º–∞—è –Ω–∞–≤–æ–¥–∫–∞/—ç—Ö–æ –æ—Ç –¥–∏–Ω–∞–º–∏–∫–∞ –≤–æ–æ–±—â–µ
    await ensureAudio(); await playChirp(); const rec=ringSlice(Math.round(S.fs*(CONFIG.chirpMs+240)/1000)+S.refChirp.length+512);
    const nearMax = lagSamplesFromCm(5);
    const {r}=correlate(S.refChirp, rec, 0, nearMax);
    loopDiag.textContent = `near-r=${(r||0).toFixed(2)} (‚â•0.25 —Ö–æ—Ä–æ—à–æ)`;
    if((r||0)<0.12){ setError('–ü–æ—Ö–æ–∂–µ, —Å–∏—Å—Ç–µ–º–∞ –≥–ª—É—à–∏—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–≤—É–∫ (AEC/–±–µ–∑–∑–≤—É—á–Ω—ã–π —Ä–µ–∂–∏–º/–º–∞—Ä—à—Ä—É—Ç–∏–∑–∞—Ü–∏—è –≤ —É—Ö–æ).', '–°–Ω–∏–º–∏—Ç–µ –±–µ–∑–∑–≤—É—á–Ω—ã–π —Ä–µ–∂–∏–º, –æ—Ç–∫–ª—é—á–∏—Ç–µ BT, —É–≤–µ–ª–∏—á—å—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å, —Ä–∞–∑–≤–µ—Ä–Ω–∏—Ç–µ –Ω–∏–∂–Ω–∏–π –¥–∏–Ω–∞–º–∏–∫ –∫ —Å—Ç–æ–ª—É. –ù–∞ iOS –≤ WebView AEC –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–∫–ª—é—á—ë–Ω.'); }
  }

  function startAcousticLoop(){ if(S.pingTimer) clearInterval(S.pingTimer); S.okSeq=0; chipDist.textContent='–ó–∞–º–µ—Ä —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è‚Ä¶'; chipDist.className='chip'; const periodMs=Math.max(250, Math.round(1000/CONFIG.pingHz)); S.pingTimer=setInterval(async()=>{ const {lag,r}=await singlePing(false); if(lag>0 && r>=CONFIG.corrThresh){ const cm=Math.round(cmFromLagSamples(lag)); const inBand=cm>=CONFIG.bandMinCm && cm<=CONFIG.bandMaxCm; chipDist.textContent=`–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: ${cm} —Å–º ${inBand?'‚Äî –û–ö':`(–Ω—É–∂–Ω–æ ${CONFIG.bandMinCm}‚Äì${CONFIG.bandMaxCm} —Å–º)`}`; chipDist.className='chip ' + (inBand ? 'ok' : 'warn'); if(inBand){ S.okSeq++; if(S.okSeq>=CONFIG.goodSeq){ S.allowShot=true; btnShot.disabled=false; pauseAcoustic(); } } else { S.allowShot=false; btnShot.disabled=true; S.okSeq=0; } } else { S.allowShot=false; btnShot.disabled=true; S.okSeq=0; chipDist.textContent=`–≠—Ö–æ —Å–ª–∞–±–æ–µ (r=${(r||0).toFixed(2)}) ‚Äî BOOST –ø–æ–ø—Ä–æ–±—É–µ—Ç –ø–æ–ª–æ—Å—É/–≥–µ–π–Ω`; chipDist.className='chip bad'; } }, periodMs); }

  function pauseAcoustic(){ if(S.pingTimer){ clearInterval(S.pingTimer); S.pingTimer=null; chipDist.textContent+=' ‚Ä¢ –ó–∞–º–µ—Ä —É–¥–µ—Ä–∂–∞–Ω'; } }

  // ===================== LEVEL SENSORS =====================
  async function enableLevelSensors(){ if(S.levelOn) return; let ok=false; try{ if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){ try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{} } if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } if(!ok){ if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){ try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{} } else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; } } }catch{} S.levelOn=ok; permHint.classList.toggle('hidden', ok); }
  function onOrient(e){ const pitch=e.beta??0, roll=e.gamma??0; paintLevel(pitch,roll) }
  function onMotion(e){ const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0; const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; paintLevel(pitch,roll); }
  function paintLevel(pitch, roll){ const R=70, T=18, nx=clamp(roll/30,-1,1), ny=clamp(pitch/30,-1,1); const dx=nx*R*0.45, dy=-ny*R*0.45; levelBubble.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; const ok=Math.hypot(dx,dy)<=T; levelBubble.classList.toggle('ok',ok); levelTarget.classList.toggle('ok',ok); }

  // ===================== ENV HINT =====================
  function envHint(){
    const https = !isSecureContext ? "\n‚Ä¢ –ù—É–∂–µ–Ω HTTPS (–∏–ª–∏ localhost)." : "";
    return `–ö–∞–º–µ—Ä–∞/–º–∏–∫—Ä–æ—Ñ–æ–Ω —Ç—Ä–µ–±—É—é—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π.${https}\n‚Ä¢ –í–∫–ª—é—á–∏—Ç–µ –≥—Ä–æ–º–∫–æ—Å—Ç—å, –æ—Ç–∫–ª—é—á–∏—Ç–µ –≥–∞—Ä–Ω–∏—Ç—É—Ä—É, –ø–æ–ª–æ–∂–∏—Ç–µ —Ç–∞—Ä–µ–ª–∫—É –Ω–∞ –∂—ë—Å—Ç–∫—É—é –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å.`;
  }

  // ===================== TEARDOWN =====================
  window.addEventListener('beforeunload', ()=>stopAll());
  function stopAll(){ if(S.pingTimer){ clearInterval(S.pingTimer); S.pingTimer=null; } try{ S.proc?.disconnect(); S.mic?.disconnect(); S.bpf?.disconnect(); }catch{} try{ S.actx?.close?.(); }catch{} stopCamera(); }

  // ===================== TESTS (console) =====================
  (function testLag(){ const z=30, N=lagSamplesFromCm(z); console.log('[test lag 30cm]', N); console.log('[cm from N]', Math.round(cmFromLagSamples(N))); console.assert(Math.abs(Math.round(cmFromLagSamples(N)) - z) <= 1, 'invertible cm<->samples'); })();
  (function testCorrelate(){ const fs=44100, dur=CONFIG.chirpMs/1000; const ref=makeChirp(fs,dur,CONFIG.f0,CONFIG.f1); const lagCm=30; const lag=lagSamplesFromCm(lagCm); const rec=new Float32Array(lag+ref.length+64); rec.set(ref, lag); const {lag:found, r}=correlate(ref, rec, lag-5, lag+5); console.log('[test correlate] expected', lag, 'found', found, 'r', (r||0).toFixed(2)); console.assert(Math.abs(found-lag) <= 2, 'correlate finds correct lag'); })();
  (function testDot(){ const a=new Float32Array([1,2,3]); const b=new Float32Array([4,5,6]); const d=dot(a,b); console.log('[test dot] expected 32, got', d); console.assert(d===32,'dot product'); })();
  (function testEnvHint(){ const h=envHint(); console.log('[test envHint]', h); console.assert(typeof h==='string' && h.length>0, 'envHint returns string'); })();
  </script>
</body>
</html>
