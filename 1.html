<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam — камера</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    /* Buttons */
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    /* CAMERA AREA */
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
    .cam-video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .2s ease}
    .cam-photo{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000}

    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    /* grid */
    .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    /* top info bar */
    .topbar{position:absolute;left:0;right:0;top:64px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}
    .chip.ok{background:rgba(22,163,74,.9)} .chip.warn{background:rgba(245,158,11,.95)}

    /* Torch */
    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}

    /* Level (one target + dot) */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:160px;height:160px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.75);background:rgba(0,0,0,.15);backdrop-filter:blur(3px)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
    .level-bubble.ok{background:#22c55e}

    /* bottom controls inside camera */
    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    /* Reference slot (bank card) */
    .card-slot{
      position:absolute; right:10px; top:50%; transform:translateY(-50%);
      width:40%; aspect-ratio: 1.586; /* 85.60/53.98 */
      border:2px dashed rgba(255,255,255,.85); border-radius:10px;
      background:rgba(255,255,255,.06);
      box-shadow:inset 0 0 0 2px rgba(0,0,0,.25);
    }
    .card-slot.ok{ border-color:#22c55e; box-shadow:inset 0 0 0 2px rgba(34,197,94,.35) }
    .card-slot.warn{ border-color:#ef4444; box-shadow:inset 0 0 0 2px rgba(239,68,68,.35) }

    /* meta + input */
    .meta{color:var(--muted);font-size:12px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px;margin-top:10px}
    .textarea{width:100%;min-height:68px;resize:vertical;padding:10px 12px;border:1px solid var(--ring);border-radius:12px;font:inherit;line-height:1.35}
    .helper{color:var(--muted);font-size:12px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
  </style>
</head>
<body>
  <main class="container">
    <div id="err" class="error hidden"></div>

    <!-- SINGLE VIEW -->
    <section id="sec-main">
      <!-- скрытые инпуты для fallback -->
      <input id="file-cam" type="file" accept="image/*" capture="environment" class="hidden" />
      <input id="file-gallery" type="file" accept="image/*" class="hidden" />

      <div class="cam-wrap" id="camWrap" aria-label="Камера и/или снимок">
        <!-- video mode -->
        <video id="video" class="cam-video" playsinline muted></video>
        <!-- photo mode -->
        <img id="photo" class="cam-photo hidden" alt="Снимок" />

        <!-- overlays (only for camera mode) -->
        <div id="overlay" class="cam-overlay">
          <div class="grid"></div>

          <div class="topbar">
            <div id="chipInfo" class="chip" role="status" aria-live="polite">Положите карту в рамку справа</div>
          </div>

          <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

          <div class="center-level">
            <div class="level-outer">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>

          <!-- reference slot -->
          <div id="cardSlot" class="card-slot warn" aria-label="Область для банковской карты"></div>
        </div>

        <!-- shutter (only for camera mode) -->
        <div id="controls" class="controls">
          <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
        </div>
      </div>

      <div id="meta" class="meta"></div>

      <!-- Комментарий + кнопки -->
      <div class="field">
        <label for="comment" class="helper">Комментарий (необязательно). Например: «треска и рис».</label>
        <textarea id="comment" class="textarea" maxlength="200" placeholder="Например: «треска и рис»"></textarea>
        <div id="commentWarn" class="helper hidden"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnRetake" class="btn" disabled>Переснять</button>
        <button id="btnGallery" class="btn">Загрузить из галереи</button>
        <button id="btnSend" class="btn primary" disabled>Отправить</button>
      </div>
    </section>
  </main>

  <script>
  // ===================== CONFIG / STATE =====================
  const CONFIG = {
    idealFacing: { facingMode: { ideal: 'environment' }, aspectRatio: { ideal: 3/4 }, height: { ideal: 1920 }, width: { ideal: 1440 } },
    maxSide: 4096,
    jpegQ: 0.95,
    webpQ: 0.95,

    BUBBLE_R: 12,
    TARGET_R: 16,
    ENFORCE_GEOMETRY: true,
    FORWARD_MOVES_UP: false,

    SMOOTH_ALPHA: 0.25,

    // --- Slot / detection ---
    CARD_AR: 85.60/53.98,   // банковская карта
    SLOT_TOL: 0.05,         // ±5%
    DETECT_HZ: 8            // частота детекции ~8 раз/сек
  };

  const S = { stream:null, track:null, torchCap:false, _torchOn:false, levelOn:false };
  let _fx = 0, _fy = 0, _initF = false;           // EMA (уровень)
  let _levelOK = false;
  let _fitOK = false;

  let _lastBlob = null;                            // текущий снимок
  let _view = 'camera';                            // 'camera' | 'photo'
  let _taking = false;                             // идёт freeze/encode
  let _detTimer = null;                            // таймер детекции

  // ===================== DOM =====================
  const $ = id => document.getElementById(id);
  const err=$('err');
  const camWrap=$('camWrap');
  const video=$('video'), photo=$('photo'), overlay=$('overlay'), controls=$('controls');
  const btnShot=$('btnShot'), btnTorch=$('btnTorch'), chipInfo=$('chipInfo');
  const fileCam=$('file-cam'), fileGallery=$('file-gallery');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget');
  const cardSlot=$('cardSlot');
  const meta=$('meta');
  const btnRetake=$('btnRetake'), btnGallery=$('btnGallery'), btnSend=$('btnSend');
  const commentEl=$('comment'), commentWarn=$('commentWarn');

  // ===================== UTILS =====================
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  function setError(msg,hint){ if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; } const extra = hint?`<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>`:''; err.innerHTML = msg + extra; err.classList.remove('hidden'); }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
  function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
  async function queryPerm(name){ try{ const p=await navigator.permissions?.query?.({name}); return p?.state??null }catch{return null} }

  function sanitizeComment(input){
    let s = String(input||'').slice(0, 200);
    s = s.replace(/<[^>]*>/g, '');
    s = s.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');
    s = s.replace(/(javascript:|data:|vbscript:|<script|<\/script|on\w+\s*=)/gi, '');
    s = s.replace(/[^\p{L}\p{N}\p{M}\s.,!?:;"'()\-–—[\]{}#@+/&%]/gu, '');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }
  function hasText(){ return sanitizeComment(commentEl.value).length > 0; }
  function showCommentWarning(show, text){
    commentWarn.textContent = text || '';
    commentWarn.classList.toggle('hidden', !show);
  }
  function updateButtons(){
    btnRetake.disabled = (_view === 'camera') || _taking;
    btnSend.disabled = !(_lastBlob || hasText()) || _taking;
    // Спуск — только если уровень ок и карта попала в слот
    btnShot.disabled = !(_levelOK && _fitOK);
  }
  function showCameraUI(){
    _view = 'camera';
    video.classList.remove('hidden');
    overlay.classList.remove('hidden');
    controls.classList.remove('hidden');
    photo.classList.add('hidden');
    meta.textContent = '';
    startDetection();
    updateButtons();
  }
  function showPhotoUI(){
    _view = 'photo';
    video.classList.add('hidden');
    overlay.classList.add('hidden');
    controls.classList.add('hidden');
    photo.classList.remove('hidden');
    stopDetection();
    updateButtons();
  }

  // ===================== AUTOSTART =====================
  window.addEventListener('DOMContentLoaded', () => {
    startCameraFlow();
    try { window.Telegram?.WebApp?.ready?.(); } catch {}
  });

  // ===================== CAMERA FLOW =====================
  btnShot.addEventListener('click', onShutter);
  btnTorch.addEventListener('click', toggleTorch);
  btnRetake.addEventListener('click', ()=>{ if(btnRetake.disabled) return; startCameraFlow(true); });
  btnGallery.addEventListener('click', ()=>fileGallery?.click());
  fileGallery.addEventListener('change', onFilePicked);
  fileCam.addEventListener('change', onFilePicked);
  commentEl.addEventListener('input', ()=>{
    const raw = commentEl.value;
    const safe = sanitizeComment(raw);
    showCommentWarning(raw !== safe, raw !== safe ? 'Некоторые символы удалены для безопасности.' : '');
    updateButtons();
  });
  window.addEventListener('resize', ()=>{ /* пересчёт на случай ресайза */ });

  function syncRadii(){
    let bubble = Number(CONFIG.BUBBLE_R)||0;
    let target = Number(CONFIG.TARGET_R)||0;
    if (CONFIG.ENFORCE_GEOMETRY && target < bubble + 1) target = bubble + 1;
    CONFIG.BUBBLE_R = bubble; CONFIG.TARGET_R = target;
    const br = bubble * 2, tr = target * 2;
    levelBubble.style.width = br + 'px'; levelBubble.style.height = br + 'px';
    levelTarget.style.width = tr + 'px'; levelTarget.style.height = tr + 'px';
  }

  async function startCameraFlow(){
    _lastBlob = null; _taking = false;
    _fitOK = false; _levelOK = false;
    updateButtons();
    setError(''); syncRadii();
    showCameraUI();
    await enableLevelSensors();
    const camOk = await openCameraGUM();
    if(!camOk){ try{ fileCam?.click(); }catch{} } // fallback
  }

  async function openCameraGUM(){
    if(!canUseGUM()){ setError('Камера недоступна.', envHint()); return false; }
    const perm = await queryPerm('camera'); if(perm==='denied'){ setError('Доступ к камере запрещён.', envHint()); return false; }
    try{
      const s = await navigator.mediaDevices.getUserMedia({video: CONFIG.idealFacing, audio:false});
      await bindStream(s);
      await upgradeResolution();
      await stabilizeVideo(300, 1200);
      video.style.opacity = '1';
      const caps=S.track?.getCapabilities?.()||{};
      S.torchCap = !!caps.torch;
      btnTorch.classList.toggle('hidden', !S.torchCap);
      return true;
    }catch(e){ console.warn(e); setError('Не удалось открыть камеру.', envHint()); return false; }
  }

  async function bindStream(stream){
    stopCamera();
    S.stream=stream; S.track=stream.getVideoTracks()[0];
    video.style.opacity='0';
    video.srcObject=stream;
    try{ await video.play(); }catch{}
  }

  async function upgradeResolution(){
    try{
      const caps = S.track.getCapabilities?.() || {};
      const wants = {};
      if(caps.width && caps.width.max) wants.width = caps.width.max;
      if(caps.height && caps.height.max) wants.height = caps.height.max;
      if(caps.aspectRatio && caps.aspectRatio.max && caps.aspectRatio.min){
        const ar = 3/4;
        wants.aspectRatio = Math.min(caps.aspectRatio.max, Math.max(caps.aspectRatio.min, ar));
      }
      if(Object.keys(wants).length){ try{ await S.track.applyConstraints(wants); }catch(e){ console.warn('applyConstraints(max) failed', e); } }
    }catch(e){ console.warn('upgradeResolution failed', e); }
  }

  async function stabilizeVideo(stableWindowMs=250, timeoutMs=1500){
    let prevW=0, prevH=0, stable=0, t=0;
    while(t < timeoutMs){
      const w=video.videoWidth, h=video.videoHeight;
      if(w>0 && h>0 && w===prevW && h===prevH){ stable += 50; if(stable >= stableWindowMs) break; }
      else { stable = 0; prevW=w; prevH=h; }
      await sleep(50); t += 50;
    }
  }

  function stopCamera(){ try{ video.pause(); video.srcObject=null }catch{}; try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}; S.stream=null; S.track=null; S._torchOn=false; }

  // ---------- FREEZE-FIRST SHUTTER ----------
  async function onShutter(){
    if(btnShot.disabled || _taking) return;
    _taking = true; updateButtons();
    haptic();

    const snapCanvas = snapshotNow(); // мгновенный freeze
    try {
      const previewURL = snapCanvas.toDataURL('image/webp', CONFIG.webpQ);
      photo.src = previewURL;
      meta.textContent = `${snapCanvas.width}×${snapCanvas.height}`;
      showPhotoUI();
    } catch {}

    try{
      const blob = await canvasToBlob(snapCanvas);
      _lastBlob = blob;
    } finally {
      stopCamera();
      _taking = false; updateButtons();
    }
  }

  function snapshotNow(){
    // Рисуем "как на экране": cover-кроп исходного кадра в канвас
    const eW = camWrap.clientWidth, eH = camWrap.clientHeight;
    const vW = video.videoWidth, vH = video.videoHeight;
    const c=document.createElement('canvas'); c.width=eW; c.height=eH;
    const ctx=c.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:true });
    const scale = Math.max(eW/vW, eH/vH);
    const sw = Math.round(eW/scale), sh = Math.round(eH/scale);
    const sx = Math.floor((vW - sw)/2), sy = Math.floor((vH - sh)/2);
    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, eW, eH);
    return c;
  }
  function canvasToBlob(c){
    return new Promise(resolve=>{
      c.toBlob(b=>{
        if(b) return resolve(b);
        c.toBlob(bb=> resolve(bb), 'image/jpeg', CONFIG.jpegQ);
      }, 'image/webp', CONFIG.webpQ);
    });
  }

  // ---------- ГАЛЕРЕЯ ----------
  async function onFilePicked(ev){
    const file = ev.target?.files?.[0];
    if(!file) return;
    if(!file.type.startsWith('image/')){ setError('Нужен файл изображения.'); return; }
    _lastBlob = file;
    const url = URL.createObjectURL(file);
    photo.onload = ()=>{ meta.textContent = `${photo.naturalWidth}×${photo.naturalHeight} • ${file.type||'image'}`; };
    photo.src = url;
    stopCamera();
    showPhotoUI();
    updateButtons();
    ev.target.value = '';
  }

  // ---------- TORCH & SENSORS ----------
  async function toggleTorch(){ if(!S.track || !S.torchCap) return; try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }catch{ btnTorch.classList.add('hidden'); } }

  function getScreenAngle(){ let a = (screen.orientation?.angle ?? window.orientation ?? 0); a = a % 360; if(a < 0) a += 360; return a; }
  function getAxisSigns(){
    const angle = getScreenAngle();
    const flip180 = (angle === 180) ? -1 : 1;
    const sx = flip180;
    const userY = CONFIG.FORWARD_MOVES_UP ? -1 : 1;
    const sy = flip180 * userY;
    return { sx, sy };
  }
  function isInside(dx,dy){ return (Math.hypot(dx,dy) + CONFIG.BUBBLE_R) <= CONFIG.TARGET_R; }

  async function enableLevelSensors(){
    if(S.levelOn) return; let ok=false;
    try{
      if(typeof DeviceOrientationEvent!== 'undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{}
      }
      if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; }
      if(!ok){
        if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
          try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{}
        } else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; }
      }
    }catch{}
    S.levelOn=ok;
  }

  function onOrient(e){ if(_view!=='camera') return; const pitch=e.beta??0, roll=e.gamma??0; paintLevel(pitch,roll); }
  function onMotion(e){
    if(_view!=='camera') return;
    const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0;
    const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0;
    const roll=(Math.atan2(y,z)*180/Math.PI)||0;
    paintLevel(pitch,roll);
  }

  function paintLevel(pitch, roll){
    const R = 70;
    const nx = clamp(roll/30,-1,1);
    const ny = clamp(pitch/30,-1,1);

    const alpha = CONFIG.SMOOTH_ALPHA;
    if(!_initF){ _fx = nx; _fy = ny; _initF = true; }
    else { _fx = _fx + alpha * (nx - _fx); _fy = _fy + alpha * (ny - _fy); }

    const { sx, sy } = getAxisSigns();
    const dx = sx * _fx * R * 0.45;
    const dy = sy * _fy * R * 0.45;

    levelBubble.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

    _levelOK = isInside(dx,dy);
    levelBubble.classList.toggle('ok', _levelOK);
    levelTarget.classList.toggle('ok', _levelOK);

    updateFitChip();
    updateButtons();
  }

  // ---------- SLOT FIT DETECTION (±5%) ----------
  function startDetection(){
    stopDetection();
    _detTimer = setInterval(()=>{ if(_view==='camera') detectCardFit(); }, 1000/CONFIG.DETECT_HZ);
  }
  function stopDetection(){ if(_detTimer){ clearInterval(_detTimer); _detTimer=null; } }

  function detectCardFit(){
    if(!video.videoWidth || !video.videoHeight) return;

    // 1) подготавливаем downscale-канвас с cover-кропом (как на экране)
    const eW = camWrap.clientWidth, eH = camWrap.clientHeight;
    const vW = video.videoWidth, vH = video.videoHeight;

    const sW = Math.min(320, eW|0); // ширина сэмпла
    const sH = Math.round(sW * (eH/eW));

    const c = document.createElement('canvas'); c.width=sW; c.height=sH;
    const ctx = c.getContext('2d', { willReadFrequently:true, desynchronized:true });

    const scale = Math.max(sW/vW, sH/vH);
    const sw = Math.round(sW/scale), sh = Math.round(sH/scale);
    const sx = Math.floor((vW - sw)/2), sy = Math.floor((vH - sh)/2);
    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sW, sH);

    // 2) координаты ROI (слота) в координатах сэмпла
    const slot = cardSlot.getBoundingClientRect();
    const wrap = camWrap.getBoundingClientRect();
    const rx = Math.max(0, Math.round((slot.left - wrap.left) / wrap.width * sW));
    const ry = Math.max(0, Math.round((slot.top  - wrap.top ) / wrap.height * sH));
    const rw = Math.min(sW - rx, Math.round(slot.width  / wrap.width  * sW));
    const rh = Math.min(sH - ry, Math.round(slot.height / wrap.height * sH));
    if(rw<12 || rh<12) return;

    const img = ctx.getImageData(rx, ry, rw, rh).data;

    // 3) простая оценка границ: суммы градиентов по столбцам/строкам
    const col = new Float32Array(rw).fill(0);
    const row = new Float32Array(rh).fill(0);

    // Быстрый градиент: |I(x+1)-I(x-1)| и |I(y+1)-I(y-1)|
    const grayAt = (x,y)=>{
      const i = (y*rw + x)*4;
      const r=img[i], g=img[i+1], b=img[i+2];
      return (r*0.2126 + g*0.7152 + b*0.0722);
    };

    for(let y=1;y<rh-1;y++){
      for(let x=1;x<rw-1;x++){
        const gx = Math.abs(grayAt(x+1,y) - grayAt(x-1,y));
        const gy = Math.abs(grayAt(x,y+1) - grayAt(x,y-1));
        col[x] += gx;
        row[y] += gy;
      }
    }

    // 4) находим лево/право/верх/низ как позиции с сильными откликами
    const maxCol = Math.max(...col), maxRow = Math.max(...row);
    const tCol = maxCol * 0.6, tRow = maxRow * 0.6;

    let L=0; while(L<rw && col[L] < tCol) L++;
    let R=rw-1; while(R>=0 && col[R] < tCol) R--;
    let T=0; while(T<rh && row[T] < tRow) T++;
    let B=rh-1; while(B>=0 && row[B] < tRow) B--;

    const w = Math.max(0, R-L+1);
    const h = Math.max(0, B-T+1);

    // 5) проверки: разумная рамка и аспект-рацио близок к карте
    const ar = (h>0)? (w/h) : 0;
    const arOk = (Math.abs(ar - CONFIG.CARD_AR) / CONFIG.CARD_AR) <= 0.15; // мягче по АР

    // 6) попадание в слот: размеры близки к самому слоту (±5%) и AR ок
    const wErr = Math.abs(w - rw)/rw;
    const hErr = Math.abs(h - rh)/rh;
    const fit = arOk && (wErr <= CONFIG.SLOT_TOL) && (hErr <= CONFIG.SLOT_TOL);

    // 7) UI + состояние
    _fitOK = !!fit;
    cardSlot.classList.toggle('ok', _fitOK);
    cardSlot.classList.toggle('warn', !_fitOK);
    updateFitChip();
    updateButtons();
  }

  function updateFitChip(){
    if(_levelOK && _fitOK){
      chipInfo.textContent = 'Ровно • Референс ок — можно снимать';
      chipInfo.className = 'chip ok';
    } else if(!_fitOK){
      chipInfo.textContent = 'Положите карту в рамку (±5%)';
      chipInfo.className = 'chip warn';
    } else {
      chipInfo.textContent = 'Выравнивайте… (кнопка заблокирована)';
      chipInfo.className = 'chip warn';
    }
  }

  // ===================== SEND (пока отключено) =====================
  async function onSend(){
    const safeText = sanitizeComment(commentEl.value);
    if(!_lastBlob && !safeText){
      setError('Пусто. Добавьте фото или комментарий.'); return;
    }
    console.log('DEBUG: отправка отключена. Подготовлено к отправке:', {
      hasImage: !!_lastBlob,
      comment: safeText
    });
    setError('Отправка пока отключена. Подключим бэкенд/бота позже.');
  }
  btnSend.addEventListener('click', onSend);

  // ===================== ENV HINT =====================
  function envHint(){
    const https = !isSecureContext ? "\n• Нужен HTTPS (или localhost)." : "";
    return `Камера требует разрешений.${https}\n• Если камера не открывается — используйте галерею.`;
  }

  // ===================== TEARDOWN =====================
  window.addEventListener('beforeunload', ()=>stopAll());
  function stopAll(){ stopCamera(); stopDetection(); }

  // ===================== TESTS (console) =====================
  (function testRadii(){
    console.assert(CONFIG.TARGET_R > CONFIG.BUBBLE_R || !CONFIG.ENFORCE_GEOMETRY, 'target > bubble (when enforced)');
    console.assert(CONFIG.BUBBLE_R>0 && CONFIG.TARGET_R>0, 'radii positive');
  })();
  </script>
</body>
</html>
