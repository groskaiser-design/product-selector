<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>FoodCam ‚Äî –∫–∞–º–µ—Ä–∞</title>
  <meta name="theme-color" content="#0a7cff" />
  <style>
    :root{ --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb; --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{ margin:0;background:var(--bg);color:var(--text); font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif; -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent; }
    .container{max-width:760px;margin:0 auto;padding:16px}
    .hidden{display:none!important}
    .row{display:flex;gap:10px;flex-wrap:wrap}

    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}

    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4;contain:layout paint;}
    .cam-video{position:absolute;inset:0;width:100%;height:100%;object-fit:cover;display:block;opacity:0;transition:opacity .2s ease;transform:translateZ(0);backface-visibility:hidden}
    .cam-photo{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000}

    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    .grid{position:absolute;inset:0;opacity:.15;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    .topbar{position:absolute;left:0;right:0;top:64px;display:flex;justify-content:center;gap:10px;z-index:9;pointer-events:none}
    .chip{pointer-events:auto;display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:12px;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.55);color:#fff}

    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}
    .btn-sensors{position:absolute;right:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-sensors.hidden{display:none}

    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:160px;height:160px;border-radius:50%}
    .level-target{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.75);background:rgba(0,0,0,.15)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{
      position:absolute;left:50%;top:50%;
      transform: translate(-50%, -50%) translateZ(0); /* –±–∞–∑–æ–≤–æ–µ —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ */
      border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);
      will-change:transform;
      transition: background-color .12s;
    }
    .level-bubble.ok{background:#22c55e}

    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    .meta{color:var(--muted);font-size:12px;margin-top:8px}
    .field{display:flex;flex-direction:column;gap:6px;margin-top:10px}
    .textarea{width:100%;min-height:68px;resize:vertical;padding:10px 12px;border:1px solid var(--ring);border-radius:12px;font:inherit;line-height:1.35}
    .helper{color:var(--muted);font-size:12px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}

    .card-area{
      position:absolute; right:12px; top:50%; transform:translateY(-50%);
      width:115px; height:183px;
      border-radius:14px;
      border:2px solid rgba(255,255,255,.95);
      background:
        repeating-linear-gradient(45deg,
          rgba(255,255,255,.18) 0 10px,
          rgba(255,255,255,0) 10px 20px);
      box-shadow:0 0 0 1px rgba(0,0,0,.15) inset;
      pointer-events:none;
    }
    .card-area.ok{ border-color:#22c55e; box-shadow:0 0 0 2px rgba(34,197,94,.45) inset }

    .indicators{position:absolute;left:0;right:0;bottom:96px;display:flex;gap:10px;justify-content:center;z-index:9;pointer-events:none}
    .ind{pointer-events:auto;display:flex;align-items:center;gap:8px;padding:8px 10px;border-radius:12px;background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.2);color:#fff;backdrop-filter:blur(2px)}
    .ind .bulb{width:12px;height:12px;border-radius:50%;background:var(--warn);box-shadow:0 0 0 2px rgba(0,0,0,.25) inset}
    .ind.ok .bulb{background:var(--ok)}
    .ind .label{font-size:12px;opacity:.95}
  </style>
</head>
<body>
  <main class="container">
    <div id="err" class="error hidden"></div>

    <section id="sec-main">
      <input id="file-cam" type="file" accept="image/*" capture="environment" class="hidden" />
      <input id="file-gallery" type="file" accept="image/*" class="hidden" />

      <div class="cam-wrap" id="camWrap" aria-label="–ö–∞–º–µ—Ä–∞ –∏/–∏–ª–∏ —Å–Ω–∏–º–æ–∫">
        <video id="video" class="cam-video" playsinline muted></video>
        <img id="photo" class="cam-photo hidden" alt="–°–Ω–∏–º–æ–∫" />

        <div id="overlay" class="cam-overlay">
          <div class="grid"></div>
          <div class="topbar">
            <div id="chipInfo" class="chip" role="status" aria-live="polite">–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω, –ø–æ–ª–æ–∂–∏—Ç–µ –±–∞–Ω–∫–æ–≤—Å–∫—É—é –∫–∞—Ä—Ç—É –≤ —Å–µ—Ä—É—é –∑–æ–Ω—É</div>
          </div>
          <button id="btnTorch" class="btn-torch hidden" aria-label="–§–æ–Ω–∞—Ä–∏–∫">‚ö°Ô∏è</button>
          <button id="btnSensors" class="btn-sensors hidden" aria-label="–í–∫–ª—é—á–∏—Ç—å –¥–∞—Ç—á–∏–∫–∏">üìê</button>

          <div class="center-level">
            <div class="level-outer" id="levelOuter">
              <div id="levelTarget" class="level-target"></div>
              <div id="levelBubble" class="level-bubble"></div>
            </div>
          </div>

          <div id="cardArea" class="card-area" aria-label="–û–±–ª–∞—Å—Ç—å –¥–ª—è –∫–∞—Ä—Ç—ã (–ø–æ—Ä—Ç—Ä–µ—Ç)"></div>

          <div class="indicators">
            <div id="indLevel" class="ind"><span class="bulb"></span><span class="label">–†–æ–≤–Ω–æ</span></div>
            <div id="indCard" class="ind"><span class="bulb"></span><span class="label">–ö–∞—Ä—Ç–∞</span></div>
          </div>
        </div>

        <div id="controls" class="controls">
          <button id="btnShot" class="shutter" aria-label="–°–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫" disabled></button>
        </div>
      </div>

      <div id="meta" class="meta"></div>

      <div class="field">
        <label for="comment" class="helper">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –æ–Ω –ø–æ–≤—ã—Å–∏—Ç —Ç–æ—á–Ω–æ—Å—Ç—å)</label>
        <textarea id="comment" class="textarea" maxlength="200" placeholder="–¢—Ä–µ—Å–∫–∞ 150 –≥—Ä –∏ —Ä–∏—Å 200 –≥—Ä"></textarea>
        <div id="commentWarn" class="helper hidden"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <button id="btnRetake" class="btn" disabled>–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
        <button id="btnGallery" class="btn">–ì–∞–ª–µ—Ä–µ—è</button>
        <button id="btnSend" class="btn primary" disabled>–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
      </div>
    </section>
  </main>

  <script>
  // ===================== CONFIG / STATE =====================
  const CONFIG = {
    idealFacing: { facingMode: { ideal: 'environment' }, aspectRatio: { ideal: 3/4 }, height: { ideal: 1920 }, width: { ideal: 1440 } },
    maxSide: 4096,
    jpegQ: 0.95,
    webpQ: 0.95,

    BUBBLE_R: 12,
    TARGET_R: 15,
    ENFORCE_GEOMETRY: true,

    SMOOTH2_ALPHA1: 0.22,
    SMOOTH2_ALPHA2: 0.15,
    SMOOTH_DEADZONE: 0.02,

    BASELINE_TRIM_ALPHA: 0.004,
    ZERO_THRESH: 0.06,

    DETECT_HZ: 12,
    EDGE_MARGIN_PX: 3,
    MIN_SIDE_FRAC: 0.25,
    BOX_ALPHA: 0.18,
    HOLD_MAX_MS: 220,
    HIT_ON: 1,
    HIT_OFF: 2,

    CORNER_BOX: 6,
    CORNER_MIN_N: 2,
    AR_MIN: 1.35,
    AR_MAX: 1.85,

    DSCALE_W: 224
  };

  const S = { stream:null, track:null, torchCap:false, _torchOn:false, levelOn:false };
  let _lastBlob = null, _view = 'camera', _taking = false;

  // Level
  let _rawNx=0,_rawNy=0, _fx1=0,_fy1=0, _fx2=0,_fy2=0, _bx=0,_by=0, _initF=false, _rafId=null;
  let _levelRadius = 40;

  // Level hysteresis
  let _levelOK=false, _lvlHits=0, _lvlMiss=0; const LVL_ON=2, LVL_OFF=3;

  // Presence
  let _detIdle=null, _lastDetTS=0, _fitOK=false, _hitCount=0,_missCount=0,_lastInsideTS=0;

  // iOS sensors watchdog
  const isIOS = /iP(hone|od|ad)/.test(navigator.userAgent);
  let _sensorLastTS = 0;
  let _sensorWatch = null;
  const SENSOR_STALE_MS = 1500;

  // ===================== DOM =====================
  const $ = id => document.getElementById(id);
  const err=$('err');
  const video=$('video'), photo=$('photo'), overlay=$('overlay'), controls=$('controls');
  const btnShot=$('btnShot'), btnTorch=$('btnTorch'), chipInfo=$('chipInfo'), btnSensors=$('btnSensors');
  const fileCam=$('file-cam'), fileGallery=$('file-gallery');
  const levelBubble=$('levelBubble'), levelTarget=$('levelTarget'), levelOuter=$('levelOuter');
  const cardArea=$('cardArea'); const camWrap=$('camWrap');
  const indLevel=$('indLevel'), indCard=$('indCard');
  const meta=$('meta');
  const btnRetake=$('btnRetake'), btnGallery=$('btnGallery'), btnSend=$('btnSend');
  const commentEl=$('comment'), commentWarn=$('commentWarn');

  // ===================== UTILS =====================
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  function setError(msg,hint){ if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; } const extra = hint?`<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>`:''; err.innerHTML = msg + extra; err.classList.remove('hidden'); }
  function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
  function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
  function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
  async function queryPerm(name){ try{ const p=await navigator.permissions?.query?.({name}); return p?.state??null }catch{return null} }

  function sanitizeComment(input){
    let s = String(input||'').slice(0, 200);
    s = s.replace(/<[^>]*>/g, '');
    s = s.replace(/[\u0000-\u001F\u007F-\u009F]/g, '');
    s = s.replace(/(javascript:|data:|vbscript:|<script|<\/script|on\w+\s*=)/gi, '');
    s = s.replace(/[^\p{L}\p{N}\p{M}\s\.,!?:;"'()\-\u2013\u2014\[\]{}#@+/&%]/gu, '');
    s = s.replace(/\s+/g, ' ').trim();
    return s;
  }
  function hasText(){ return sanitizeComment(commentEl.value).length > 0; }
  function showCommentWarning(show, text){
    commentWarn.textContent = text || '';
    commentWarn.classList.toggle('hidden', !show);
  }
  function updateButtons(){
    btnRetake.disabled = (_view === 'camera') || _taking;
    btnSend.disabled = !(_lastBlob || hasText()) || _taking;
    btnShot.disabled = !(_levelOK && _fitOK);
  }
  function syncIndicators(){
    indLevel.classList.toggle('ok', _levelOK);
    indCard.classList.toggle('ok', _fitOK);
    indLevel.setAttribute('aria-label', _levelOK ? '–†–æ–≤–Ω–æ: –æ–∫' : '–†–æ–≤–Ω–æ: –Ω–µ—Ç');
    indCard.setAttribute('aria-label', _fitOK ? '–ö–∞—Ä—Ç–∞: –æ–∫' : '–ö–∞—Ä—Ç–∞: –Ω–µ—Ç');
  }

  function showCameraUI(){
    _view = 'camera';
    video.classList.remove('hidden'); overlay.classList.remove('hidden'); controls.classList.remove('hidden');
    photo.classList.add('hidden');
    meta.textContent = '';
    chipInfo.textContent = '–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω, –ø–æ–ª–æ–∂–∏—Ç–µ –±–∞–Ω–∫–æ–≤—Å–∫—É—é –∫–∞—Ä—Ç—É –≤ —Å–µ—Ä—É—é –∑–æ–Ω—É';
    startDetection(); startLevelLoop(); startSensorsWatchdog();
    updateButtons(); syncIndicators();
  }
  function showPhotoUI(){
    _view = 'photo';
    video.classList.add('hidden'); overlay.classList.add('hidden'); controls.classList.add('hidden');
    photo.classList.remove('hidden');
    stopDetection(); stopLevelLoop(); stopSensorsWatchdog();
    updateButtons();
  }

  // ===================== AUTOSTART =====================
  window.addEventListener('DOMContentLoaded', () => {
    adaptPerf();
    startCameraFlow();
    try { window.Telegram?.WebApp?.ready?.(); } catch {}
  });

  // ===================== CAMERA FLOW =====================
  btnShot.addEventListener('click', onShutter);
  btnTorch.addEventListener('click', toggleTorch);
  btnRetake.addEventListener('click', ()=>{ if(btnRetake.disabled) return; startCameraFlow(true); });
  btnGallery.addEventListener('click', ()=>fileGallery?.click());
  fileGallery.addEventListener('change', onFilePicked);
  fileCam.addEventListener('change', onFilePicked);
  commentEl.addEventListener('input', ()=>{
    const raw = commentEl.value;
    const safe = sanitizeComment(raw);
    showCommentWarning(raw !== safe, raw !== safe ? '–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–∏–º–≤–æ–ª—ã —É–¥–∞–ª–µ–Ω—ã –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.' : '');
    updateButtons();
  });

  // iOS: –∫–Ω–æ–ø–∫–∞ –≤–∫–ª—é—á–µ–Ω–∏—è –¥–∞—Ç—á–∏–∫–æ–≤ (–ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏)
  btnSensors.addEventListener('click', requestSensorPermission);

  function adaptPerf(){
    const mem = (navigator.deviceMemory||8);
    if(mem <= 4){
      CONFIG.DETECT_HZ = 6;
      CONFIG.DSCALE_W = Math.min(CONFIG.DSCALE_W, 160);
    }
  }

  function syncRadii(){
    let bubble = Number(CONFIG.BUBBLE_R)||0;
    let target = Number(CONFIG.TARGET_R)||0;
    if (CONFIG.ENFORCE_GEOMETRY && target < bubble + 1) target = bubble + 1;
    CONFIG.BUBBLE_R = bubble; CONFIG.TARGET_R = target;
    const br = bubble * 2, tr = target * 2;
    levelBubble.style.width = br + 'px'; levelBubble.style.height = br + 'px';
    levelTarget.style.width = tr + 'px'; levelTarget.style.height = tr + 'px';
  }

  function computeLevelRadius(){
    const rOuter = Math.min(levelOuter.clientWidth, levelOuter.clientHeight) * 0.5;
    _levelRadius = Math.max(8, Math.floor(Math.min(rOuter - CONFIG.BUBBLE_R - 2, rOuter * 0.6)));
  }

  async function startCameraFlow(){
    _lastBlob=null; _taking=false;
    _fitOK=false; _levelOK=false; _lvlHits=0; _lvlMiss=0; _hitCount=0; _missCount=0; _lastInsideTS=0;
    _bx=0; _by=0; _initF=false; _sensorLastTS=0;
    updateButtons();
    setError(''); syncRadii();
    recomputeRects(); computeLevelRadius();
    startObservers();
    showCameraUI();
    await enableLevelSensors(true); // –ø–µ—Ä–≤–∏—á–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞
    const camOk = await openCameraGUM();
    if(!camOk){ try{ fileCam?.click(); }catch{} }
    // –µ—Å–ª–∏ –Ω–∞ iOS —Å–ø—É—Å—Ç—è 900–º—Å –Ω–µ—Ç —Å–æ–±—ã—Ç–∏–π ‚Äî –ø–æ–∫–∞–∂–µ–º –∫–Ω–æ–ø–∫—É
    if(isIOS) setTimeout(()=>{ if(_sensorLastTS===0) showSensorsButton(true); }, 900);
  }

  // ======== Camera selection ========
  async function getPermission() { try{ await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' } }, audio:false }); }catch{} }
  async function pickBackCamera(){
    const devs = await navigator.mediaDevices.enumerateDevices();
    const prefer = [/back/i, /rear/i, /—Ç—ã–ª/i, /–∑–∞–¥–Ω/i, /Back Camera/i, /Wide Camera/i];
    const avoid = [/ultra/i, /tele/i, /macro/i, /—Å–≤–µ—Ä—Ö/i, /—Ç–µ–ª/i];
    let best = null;
    for(const d of devs){
      if(d.kind!== 'videoinput') continue;
      const L=d.label||'';
      if(prefer.some(r=>r.test(L)) && !avoid.some(r=>r.test(L))){ best=d; break; }
    }
    if(!best) best = devs.find(d=> d.kind==='videoinput' && /back|rear/i.test(d.label||''));
    return best?.deviceId || devs.find(d=>d.kind==='videoinput')?.deviceId || null;
  }
  async function openLockedBackCamera(){
    await getPermission();
    const id = await pickBackCamera();
    const cons = id
      ? { video: { deviceId: { exact: id }, frameRate: { ideal: 30, max: 30 } }, audio:false }
      : { video: { facingMode: { exact: 'environment' }, frameRate: { ideal: 30, max: 30 } }, audio:false };
    return navigator.mediaDevices.getUserMedia(cons);
  }

  async function openCameraGUM(){
    if(!canUseGUM()){ setError('–ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.', envHint()); return false; }
    const perm = await queryPerm('camera'); if(perm==='denied'){ setError('–î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∑–∞–ø—Ä–µ—â—ë–Ω.', envHint()); return false; }
    try{
      const s = await openLockedBackCamera();
      await bindStream(s);
      await stabilizeVideo(300, 1200);
      video.style.opacity = '1';
      const caps=S.track?.getCapabilities?.()||{};
      S.torchCap = !!caps.torch;
      btnTorch.classList.toggle('hidden', !S.torchCap);
      if('zoom' in caps){
        try{ await S.track.applyConstraints({ advanced:[{ zoom: Math.min(Math.max(1, caps.zoom?.min||1), caps.zoom?.max||1) }] }); }catch{}
      }
      return true;
    }catch(e){ console.warn(e); setError('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É.', envHint()); return false; }
  }

  async function bindStream(stream){
    stopCamera();
    S.stream=stream; S.track=stream.getVideoTracks()[0];
    video.style.opacity='0';
    video.srcObject=stream;
    try{ await video.play(); }catch{}
  }

  async function stabilizeVideo(stableWindowMs=250, timeoutMs=1500){
    let prevW=0, prevH=0, stable=0, t=0;
    while(t < timeoutMs){
      const w=video.videoWidth, h=video.videoHeight;
      if(w>0 && h>0 && w===prevW && h===prevH){ stable += 50; if(stable >= stableWindowMs) break; }
      else { stable = 0; prevW=w; prevH=h; }
      await sleep(50); t += 50;
    }
  }

  function stopCamera(){ try{ video.pause(); video.srcObject=null }catch{}; try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}; S.stream=null; S.track=null; S._torchOn=false; }

  // ---------- SHUTTER ----------
  async function onShutter(){
    if(btnShot.disabled || _taking) return;
    _taking = true; updateButtons(); haptic();
    const snapCanvas = snapshotNow();
    try {
      const previewURL = snapCanvas.toDataURL('image/webp', CONFIG.webpQ);
      photo.src = previewURL;
      meta.textContent = `${snapCanvas.width}√ó${snapCanvas.height}`;
      showPhotoUI();
    } catch {}
    try{
      const blob = await canvasToBlob(snapCanvas);
      _lastBlob = blob;
    } finally {
      stopCamera(); _taking = false; updateButtons();
    }
  }

  function snapshotNow(){
    const srcW = video.videoWidth, srcH = video.videoHeight;
    const scale = Math.min(1,  CONFIG.maxSide/Math.max(srcW,srcH));
    const w=Math.max(1,Math.round(srcW*scale)), h=Math.max(1,Math.round(srcH*scale));
    const c=document.createElement('canvas'); c.width=w; c.height=h;
    const ctx=c.getContext('2d', { alpha:false, desynchronized:true, willReadFrequently:true });
    try{ ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high'; }catch{}
    ctx.drawImage(video,0,0,w,h);
    return c;
  }
  function canvasToBlob(c){
    return new Promise(resolve=>{
      c.toBlob(b=>{
        if(b) return resolve(b);
        c.toBlob(bb=> resolve(bb), 'image/jpeg', CONFIG.jpegQ);
      }, 'image/webp', CONFIG.webpQ);
    });
  }

  // ---------- –ì–ê–õ–ï–†–ï–Ø ----------
  async function onFilePicked(ev){
    const file = ev.target?.files?.[0];
    if(!file) return;
    if(!file.type.startsWith('image/')){ setError('–ù—É–∂–µ–Ω —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.'); return; }
    _lastBlob = file;
    const url = URL.createObjectURL(file);
    photo.onload = ()=>{ meta.textContent = `${photo.naturalWidth}√ó${photo.naturalHeight} ‚Ä¢ ${file.type||'image'}`; };
    photo.src = url;
    stopCamera();
    showPhotoUI();
    updateButtons();
    ev.target.value = '';
  }

  // ---------- Torch ----------
  let _torchBusy=false;
  async function toggleTorch(){
    if(!S.track || !S.torchCap || _torchBusy) return; _torchBusy=true;
    try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }
    catch{ btnTorch.classList.add('hidden'); }
    finally{ setTimeout(()=>{ _torchBusy=false; }, 200); }
  }

  // ---------- ORIENTATION ----------
  function getScreenAngle(){
    let a = (screen.orientation?.angle ?? window.orientation ?? 0);
    a = ((a % 360)+360)%360;
    if (a >= 315 || a < 45) return 0;
    if (a >= 45 && a < 135) return 90;
    if (a >= 135 && a < 225) return 180;
    return 270;
  }

  function mapTilt(pitchDeg, rollDeg){
    const a = getScreenAngle();
    const s = 45; // 45¬∞ -> 1.0
    const pr = clamp(pitchDeg / s, -1, 1);
    const rr = clamp(rollDeg  / s, -1, 1);
    let nx=0, ny=0;
    switch(a){
      case 0:   nx = rr;     ny = pr;     break;
      case 90:  nx = -pr;    ny = rr;     break;
      case 180: nx = -rr;    ny = -pr;    break;
      case 270: nx = pr;     ny = -rr;    break;
    }
    return { nx, ny };
  }

  // ---------- SENSORS ----------
  async function enableLevelSensors(firstTry=false){
    if(S.levelOn) return true;
    let ok=false;
    try{
      if(typeof DeviceOrientationEvent!== 'undefined' && typeof DeviceOrientationEvent.requestPermission==='function' && firstTry){
        try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation', onOrient, true); ok=true; } }catch{}
      }
      if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation', onOrient, true); ok=true; }
      if(!ok && typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function' && firstTry){
        try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion', onMotion, true); ok=true; } }catch{}
      }
      if(!ok && 'ondevicemotion' in window){ window.addEventListener('devicemotion', onMotion, true); ok=true; }
    }catch{}
    S.levelOn=ok;
    return ok;
  }

  async function requestSensorPermission(){
    let granted=false;
    try{
      if(typeof DeviceOrientationEvent!== 'undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
        granted = (await DeviceOrientationEvent.requestPermission())==='granted';
        if(granted) window.addEventListener('deviceorientation', onOrient, true);
      }
      if(!granted && typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        granted = (await DeviceMotionEvent.requestPermission())==='granted';
        if(granted) window.addEventListener('devicemotion', onMotion, true);
      }
      if(!granted){ setError('–ù—É–∂–Ω–æ —Ä–∞–∑—Ä–µ—à–∏—Ç—å ¬´–î–≤–∏–∂–µ–Ω–∏–µ –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è¬ª. –û—Ç–∫—Ä–æ–π—Ç–µ –≤ Safari/–±—Ä–∞—É–∑–µ—Ä–µ –∏ –¥–∞–π—Ç–µ –¥–æ—Å—Ç—É–ø.'); return; }
      S.levelOn=true; showSensorsButton(false); chipInfo.textContent='–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω, –ø–æ–ª–æ–∂–∏—Ç–µ –±–∞–Ω–∫–æ–≤—Å–∫—É—é –∫–∞—Ä—Ç—É –≤ —Å–µ—Ä—É—é –∑–æ–Ω—É';
    }catch(e){
      setError('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–∫–ª—é—á–∏—Ç—å –¥–∞—Ç—á–∏–∫–∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏.');
    }
  }

  function showSensorsButton(show){ btnSensors.classList.toggle('hidden', !show); }

  function onOrient(e){
    if(_view!=='camera') return;
    _sensorLastTS = performance.now();
    const pitch=e.beta??0, roll=e.gamma??0;
    const { nx, ny } = mapTilt(pitch, roll);
    _rawNx=nx; _rawNy=ny;
  }
  function onMotion(e){
    if(_view!=='camera') return;
    _sensorLastTS = performance.now();
    const a=e.accelerationIncludingGravity||{};
    const x=a.x||0,y=a.y||0,z=a.z||0;
    const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0;
    const roll =(Math.atan2( y, z)*180/Math.PI)||0;
    const { nx, ny } = mapTilt(pitch, roll);
    _rawNx=nx; _rawNy=ny;
  }

  function startSensorsWatchdog(){
    stopSensorsWatchdog();
    if(!isIOS) return; // –Ω–∞ Android –æ–±—ã—á–Ω–æ –Ω–µ –Ω—É–∂–Ω–æ
    _sensorWatch = setInterval(()=>{
      if(_view!=='camera') return;
      const stale = (performance.now() - _sensorLastTS) > SENSOR_STALE_MS;
      if(stale){
        // —Å–µ–Ω—Å–æ—Ä—ã ¬´–∑–∞—Å—Ç—ã–ª–∏¬ª: –ø—Ä–æ—Å–∏–º –∂–µ—Å—Ç –∏–ª–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º—Å—è
        showSensorsButton(true);
      }
    }, 1000);
  }
  function stopSensorsWatchdog(){ if(_sensorWatch){ clearInterval(_sensorWatch); _sensorWatch=null; } }

  window.addEventListener('pageshow', ()=>{ if(_view==='camera'){ _sensorLastTS=0; enableLevelSensors(false); }});
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && _view==='camera'){ _sensorLastTS=0; }});

  // ---------- LEVEL LOOP ----------
  function setLevelOK(next){
    if(next){ _lvlHits++; _lvlMiss=0; } else { _lvlMiss++; _lvlHits=0; }
    const prev = _levelOK;
    const stable = prev ? (_lvlMiss >= LVL_OFF ? false : prev) : (_lvlHits >= LVL_ON ? true : prev);
    if(stable !== _levelOK){
      _levelOK = stable;
      levelBubble.classList.toggle('ok', _levelOK);
      levelTarget.classList.toggle('ok', _levelOK);
      syncIndicators(); updateButtons();
    }
  }
  function isInside(dx,dy){ return (Math.hypot(dx,dy) + CONFIG.BUBBLE_R) <= CONFIG.TARGET_R; }

  function startLevelLoop(){
    if(_rafId) return;
    const step=()=>{
      if(_view==='camera'){
        const nearCenter = (Math.abs(_fx2) < CONFIG.ZERO_THRESH && Math.abs(_fy2) < CONFIG.ZERO_THRESH);
        if(nearCenter){
          _bx = _bx + CONFIG.BASELINE_TRIM_ALPHA*(_rawNx - _bx);
          _by = _by + CONFIG.BASELINE_TRIM_ALPHA*(_rawNy - _by);
        }

        const rx = _rawNx - _bx, ry = _rawNy - _by;
        const a1=CONFIG.SMOOTH2_ALPHA1, a2=CONFIG.SMOOTH2_ALPHA2, dz=CONFIG.SMOOTH_DEADZONE;
        if(!_initF){ _fx1=rx; _fy1=ry; _fx2=rx; _fy2=ry; _initF=true; }
        else{
          _fx1 = _fx1 + a1*(rx - _fx1);
          _fy1 = _fy1 + a1*(ry - _fy1);
          let nx2 = _fx2 + a2*(_fx1 - _fx2);
          let ny2 = _fy2 + a2*(_fy1 - _fy2);
          if(Math.abs(nx2 - _fx2) < dz) nx2 = _fx2;
          if(Math.abs(ny2 - _fy2) < dz) ny2 = _fy2;
          _fx2 = nx2; _fy2 = ny2;
        }

        const R = _levelRadius;
        const dx = clamp(_fx2, -1, 1) * R;
        const dy = clamp(_fy2, -1, 1) * R;

        levelBubble.style.transform = `translate(-50%, -50%) translate(${dx}px, ${dy}px) translateZ(0)`;

        setLevelOK(isInside(dx,dy));
      }
      _rafId=requestAnimationFrame(step);
    };
    _rafId=requestAnimationFrame(step);
  }
  function stopLevelLoop(){ if(_rafId){ cancelAnimationFrame(_rafId); _rafId=null; } }

  // ---------- PRESENCE DETECTOR ----------
  const DET = {
    c: document.createElement('canvas'),
    ctx: null, sW: 0, sH: 0,
    wrapRect: null, slotRect: null,
    g: null, gb: null, colV: null, rowH: null, allE: null,
  };
  DET.ctx = DET.c.getContext('2d', { willReadFrequently:true, desynchronized:true });

  let _roStarted=false;
  function startObservers(){
    if(_roStarted) return;
    const ro = new ResizeObserver(()=>{ recomputeRects(); computeLevelRadius(); });
    ro.observe(camWrap); ro.observe(cardArea); ro.observe(levelOuter);
    _roStarted=true;
  }

  function recomputeRects(){
    DET.wrapRect = camWrap.getBoundingClientRect();
    DET.slotRect = cardArea.getBoundingClientRect();
    DET.sW = CONFIG.DSCALE_W;
    DET.sH = Math.max(1, Math.round(DET.sW * (DET.wrapRect.height / Math.max(1, DET.wrapRect.width))));
    DET.c.width = DET.sW; DET.c.height = DET.sH;
    DET.g = DET.gb = DET.colV = DET.rowH = DET.allE = null;
  }
  window.addEventListener('resize', ()=>{ recomputeRects(); computeLevelRadius(); });
  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible'){ recomputeRects(); computeLevelRadius(); } });

  function startDetection(){
    stopDetection();
    const ric = window.requestIdleCallback || function(cb, opts){ return setTimeout(cb, (opts && opts.timeout) || 120); };
    const loop = ()=>{
      if(_view==='camera'){
        const now = performance.now();
        if(now - _lastDetTS >= (1000/CONFIG.DETECT_HZ)){
          detectPresence(); _lastDetTS = now;
        }
        _detIdle = ric(loop, {timeout: 120});
      }
    };
    _detIdle = ric(loop, {timeout: 120});
  }
  function stopDetection(){ const cic = window.cancelIdleCallback || clearTimeout; if(_detIdle){ cic(_detIdle); _detIdle=null; } }

  function meanStd(arr){
    let m=0, m2=0, n=arr.length;
    for(let i=0;i<n;i++){ const v=arr[i]; m+=v; m2+=v*v; }
    m/=n; const std=Math.sqrt(Math.max(0, m2/n - m*m)); return [m,std];
  }

  function detectPresence(){
    if(!video.videoWidth || !video.videoHeight || !DET.wrapRect || !DET.slotRect) return;

    const sW = DET.sW, sH = DET.sH, ctx = DET.ctx;

    const vW = video.videoWidth, vH = video.videoHeight;
    const scale = Math.max(sW/vW, sH/vH);
    const sw = Math.round(sW/scale), sh = Math.round(sH/scale);
    const sx = Math.floor((vW - sw)/2), sy = Math.floor((vH - sh)/2);
    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, sW, sH);

    const wrap = DET.wrapRect, slot = DET.slotRect;
    const rx = Math.max(0, Math.round((slot.left - wrap.left) / wrap.width  * sW));
    const ry = Math.max(0, Math.round((slot.top  - wrap.top ) / wrap.height * sH));
    const rw = Math.min(sW - rx, Math.round(slot.width  / wrap.width  * sW));
    const rh = Math.min(sH - ry, Math.round(slot.height / wrap.height * sH));
    if(rw<20 || rh<20) return;

    const img = ctx.getImageData(rx, ry, rw, rh); const data = img.data;

    const N = rw*rh;
    if(!DET.g || DET.g.length!==N){ DET.g=new Float32Array(N); DET.gb=new Float32Array(N); DET.allE=new Float32Array(N); }
    if(!DET.colV || DET.colV.length!==rw){ DET.colV=new Float32Array(rw); }
    if(!DET.rowH || DET.rowH.length!==rh){ DET.rowH=new Float32Array(rh); }
    DET.colV.fill(0); DET.rowH.fill(0);

    const g = DET.g, gb = DET.gb, colV = DET.colV, rowH = DET.rowH, allE = DET.allE;

    for(let y=0, i=0, j=0; y<rh; y++){
      for(let x=0; x<rw; x++, i+=4, j++){
        g[j] = data[i]*0.2126 + data[i+1]*0.7152 + data[i+2]*0.0722;
      }
    }
    for(let y=0; y<rh; y++){
      for(let x=0; x<rw; x++){
        let s=0,cnt=0;
        for(let yy=y-1; yy<=y+1; yy++){
          if(yy<0||yy>=rh) continue;
          for(let xx=x-1; xx<=x+1; xx++){
            if(xx<0||xx>=rw) continue;
            s+=g[yy*rw+xx]; cnt++;
          }
        }
        gb[y*rw+x]= s/cnt;
      }
    }

    for(let y=1;y<rh-1;y++){
      for(let x=1;x<rw-1;x++){
        const gx = Math.abs(gb[y*rw+(x+1)] - gb[y*rw+(x-1)]);
        const gy = Math.abs(gb[(y+1)*rw+x] - gb[(y-1)*rw+x]);
        colV[x]+=gx; rowH[y]+=gy;
        allE[y*rw+x] = gx+gy;
      }
    }

    const a = CONFIG.BOX_ALPHA;
    for(let x=1;x<rw;x++){ colV[x] = colV[x-1] + a*(colV[x]-colV[x-1]); }
    for(let y=1;y<rh;y++){ rowH[y] = rowH[y-1] + a*(rowH[y]-rowH[y-1]); }

    const [mc,sc] = meanStd(colV);
    const [mr,sr] = meanStd(rowH);
    const tCol = mc + 1.15*sc;
    const tRow = mr + 1.15*sr;

    const m = CONFIG.EDGE_MARGIN_PX;
    let L=m; while(L<rw-m && colV[L] < tCol) L++;
    let R=rw-1-m; while(R>m && colV[R] < tCol) R--;
    let T=m; while(T<rh-m && rowH[T] < tRow) T++;
    let B=rh-1-m; while(B>m && rowH[B] < tRow) B--;

    if(!(R>L && B>T)) { applyPresence(false); return; }

    const width = R - L; const height = B - T;
    const sizeOK = (width >= rw*CONFIG.MIN_SIDE_FRAC && height >= rh*CONFIG.MIN_SIDE_FRAC);
    const ar = height / Math.max(1,width);
    const arOK = (ar >= CONFIG.AR_MIN && ar <= CONFIG.AR_MAX);
    const inside = (L>m && T>m && R<rw-1-m && B<rh-1-m);

    const cornerEnergy = (cx,cy)=>{
      const cb = CONFIG.CORNER_BOX;
      let s=0,cnt=0;
      for(let y=Math.max(T,cy); y<Math.min(B,cy+cb); y++){
        for(let x=Math.max(L,cx); x<Math.min(R,cx+cb); x++){
          const gx = Math.abs(gb[y*rw + Math.min(rw-1,x+1)] - gb[y*rw + Math.max(0,x-1)]);
          const gy = Math.abs(gb[Math.min(rh-1,y+1)*rw + x] - gb[Math.max(0,y-1)*rw + x]);
          s += gx + gy; cnt++;
        }
      } return s/Math.max(1,cnt);
    };

    const eLT = cornerEnergy(L, T);
    const eRT = cornerEnergy(Math.max(L, R-CONFIG.CORNER_BOX), T);
    const eLB = cornerEnergy(L, Math.max(T, B-CONFIG_CROSS?CONFIG.CORNER_BOX:CONFIG.CORNER_BOX)); // keep
    const eRB = cornerEnergy(Math.max(L, R-CONFIG.CORNER_BOX), Math.max(T, B-CONFIG.CORNER_BOX));

    const [me,se] = meanStd(allE);
    const eThr = me + 1.0*se;

    let strongCorners = 0; if(eLT>eThr) strongCorners++; if(eRT>eThr) strongCorners++; if(eLB>eThr) strongCorners++; if(eRB>eThr) strongCorners++;
    const cornersOK = (strongCorners >= CONFIG.CORNER_MIN_N);

    applyPresence(inside && sizeOK && arOK && cornersOK);
  }

  function applyPresence(hit){
    const now = performance.now();
    if(hit){ _lastInsideTS = now; _hitCount++; _missCount=0; } else { _missCount++; _hitCount=0; }

    let ok = (_hitCount >= CONFIG.HIT_ON) ? true : (_missCount >= CONFIG.HIT_OFF ? false : _fitOK);
    if(!hit && ok && (now - _lastInsideTS) > CONFIG.HOLD_MAX_MS){ ok = false; }

    if(ok!==_fitOK){
      _fitOK = ok;
      cardArea.classList.toggle('ok', ok);
      syncIndicators(); updateButtons();
    }
  }

  // SEND (–ø–æ–∫–∞ –∑–∞–≥–ª—É—à–∫–∞)
  async function onSend(){
    const safeText = sanitizeComment(commentEl.value);
    if(!_lastBlob && !safeText){ setError('–ü—É—Å—Ç–æ. –î–æ–±–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π.'); return; }
    console.log('DEBUG: –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞.', { hasImage: !!_lastBlob, comment: safeText });
    setError('–û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞. –ü–æ–¥–∫–ª—é—á–∏–º –±—ç–∫–µ–Ω–¥/–±–æ—Ç–∞ –ø–æ–∑–∂–µ.');
  }
  btnSend.addEventListener('click', onSend);

  function envHint(){
    const https = !isSecureContext ? "\n‚Ä¢ –ù—É–∂–µ–Ω HTTPS (–∏–ª–∏ localhost)." : "";
    return `–ö–∞–º–µ—Ä–∞ —Ç—Ä–µ–±—É–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π.${https}\n‚Ä¢ –ï—Å–ª–∏ –∫–∞–º–µ—Ä–∞ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≥–∞–ª–µ—Ä–µ—é.`;
  }

  window.addEventListener('beforeunload', ()=>stopAll());
  function stopAll(){ stopCamera(); stopDetection(); stopLevelLoop(); stopSensorsWatchdog(); }

  // TESTS
  (function testRadii(){
    syncRadii();
    console.assert(CONFIG.TARGET_R > CONFIG.BUBBLE_R || !CONFIG.ENFORCE_GEOMETRY, 'target > bubble (when enforced)');
    console.assert(CONFIG.BUBBLE_R>0 && CONFIG.TARGET_R>0, 'radii positive');
  })();
  (function testInsideMath(){ const T=CONFIG.TARGET_R-CONFIG.BUBBLE_R; console.assert(T>0,'T>0'); console.assert(isInside(0,0),'center'); console.assert(isInside(T,0),'boundary'); console.assert(!isInside(T+0.01,0),'outside'); })();

  </script>
</body>
</html>
