<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>FoodCam — Distance Coach: 25–35 см + площадь (AR)</title>
  <meta name="theme-color" content="#0a7cff"/>
  <style>
    :root{--bg:#fff;--text:#111827;--muted:#6b7280;--ring:#e5e7eb;--primary:#2563eb;--ok:#16a34a}
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);
      font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif}
    .container{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:0 0 6px}.muted{color:var(--muted);font-size:14px;margin:0 0 12px}
    .row{display:flex;gap:10px;flex-wrap:wrap}.hidden{display:none!important}
    .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:14px;
      border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
    .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
    .btn[disabled]{opacity:.45;cursor:not-allowed}
    .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
    .cam-video{width:100%;height:100%;object-fit:cover;display:block}
    .cam-overlay{position:absolute;inset:0;pointer-events:none}
    .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
      linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
      linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
      linear-gradient(90deg,#fff 1px,transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x}

    /* верхняя подсказка — всегда над кнопками */
    .top-hint{position:absolute;left:50%;top:12px;transform:translateX(-50%);z-index:9;
      background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.25);
      border-radius:12px;padding:8px 12px;font-size:14px;pointer-events:auto;white-space:nowrap}
    .top-hint.ok{background:rgba(22,163,74,.85)}

    .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
    .btn-torch.hidden{display:none}

    .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;
      background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
    .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
    .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

    /* уровень по центру */
    .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
    .level-outer{position:relative;width:140px;height:140px;border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.2);backdrop-filter:blur(4px)}
    .level-target{position:absolute;left:50%;top:50%;width:36px;height:36px;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.55)}
    .level-target.ok{border-color:#34d399}
    .level-bubble{position:absolute;left:50%;top:50%;width:22px;height:22px;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
    .level-bubble.ok{background:#22c55e}

    /* превью и вычисления */
    .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
    .pad{padding:14px}
    .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
    .meta{color:var(--muted);font-size:12px;margin-top:6px}
    .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    .tools{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#f3f4f6;border:1px solid var(--ring);font-size:14px;cursor:pointer}
    .chip.primary{background:#e0e7ff;border-color:#c7d2fe}
    .badge{font-size:12px;color:#64748b}
  </style>
</head>
<body>
<main class="container">
  <header>
    <h1>Distance Coach — 25–35 см → Площадь</h1>
    <p class="muted">Держите телефон строго сверху (по уровню). Как только <b>расстояние</b> попадёт в <b>25–35 см</b>, кнопка станет активной.</p>
  </header>

  <div id="err" class="error hidden"></div>

  <!-- CAMERA -->
  <section id="sec-camera">
    <div class="row" style="margin-bottom:10px">
      <button id="btnOpen" class="btn primary">Открыть камеру</button>
      <button id="btnStop" class="btn">Закрыть</button>
      <span id="permHint" class="badge">iOS: разрешите «Ориентацию и движение»</span>
      <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden"/>
    </div>

    <div class="cam-wrap" id="camWrap" aria-label="Живое превью камеры">
      <video id="video" class="cam-video" playsinline muted></video>

      <div class="cam-overlay">
        <div class="grid"></div>

        <!-- верхняя подсказка расстояния -->
        <div id="topHint" class="top-hint">Пробуем AR для замера дистанции…</div>

        <!-- фонарь -->
        <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

        <!-- центральный уровень -->
        <div class="center-level">
          <div class="level-outer">
            <div id="levelTarget" class="level-target"></div>
            <div id="levelBubble" class="level-bubble"></div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
      </div>
    </div>
  </section>

  <!-- PREVIEW + AREA -->
  <section id="sec-preview" class="hidden" style="margin-top:12px">
    <div class="card pad">
      <img id="photo" class="preview-img" alt="Снимок"/>
      <div id="meta" class="meta"></div>
      <div id="areaBox" class="muted" style="margin-top:8px"></div>

      <div class="tools">
        <button id="btnDetectCircle" class="chip primary">Авто: круг</button>
        <button id="btnRetake" class="btn">Переснять</button>
        <button id="btnSave" class="btn primary">Скачать снимок</button>
      </div>
      <div class="badge">Масштаб: <span id="scaleMode">—</span></div>
    </div>
  </section>
</main>

<script>
/* ===================== CONFIG/STATE ===================== */
const CONFIG = {
  idealFacing: { facingMode: { ideal: 'environment' } },
  maxSide: 2000,

  // Диапазон активации спуска
  bandMinCm: 25,
  bandMaxCm: 35,

  detectEveryMs: 350,
  downscaleW: 256,
};
const S = {
  stream:null, track:null, torchCap:false, _torchOn:false,
  levelOn:false,
  xr:null, xrSession:null, xrRefSpace:null, xrHitSource:null,
  lastDistanceM:null, lastFov:{x:null,y:null},
  allowShot:false,
  scaleCmPerPx:null,          // выставляется из AR
};

/* ===================== DOM REFS ===================== */
const $ = id => document.getElementById(id);
const err=$('err'), camWrap=$('camWrap'), video=$('video');
const btnOpen=$('btnOpen'), btnStop=$('btnStop'), btnTorch=$('btnTorch'), btnShot=$('btnShot'), fileSystem=$('file-system');
const levelBubble=$('levelBubble'), levelTarget=$('levelTarget'), topHint=$('topHint');
const secCam=$('sec-camera'), secPrev=$('sec-preview'), photo=$('photo'), meta=$('meta'), areaBox=$('areaBox');
const btnRetake=$('btnRetake'), btnSave=$('btnSave'), permHint=$('permHint');
const btnDetectCircle=$('btnDetectCircle');
const scaleMode=$('scaleMode');

/* ===================== UTILS ===================== */
function setError(msg,hint){
  if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; }
  const extra = hint ? `<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>` : '';
  err.innerHTML = msg + extra; err.classList.remove('hidden');
}
function clamp(v,a,b){return Math.min(b,Math.max(a,v))}
function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch{} }
function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
async function queryCamPerm(){ try{ const p=await navigator.permissions?.query?.({name:'camera'}); return p?.state??null }catch{return null}}

/* ===================== FLOW ===================== */
btnOpen.addEventListener('click', openFlow);
btnStop.addEventListener('click', ()=>stopAll());
btnTorch.addEventListener('click', toggleTorch);
btnShot.addEventListener('click', onShutter);
btnSave.addEventListener('click', ()=>{ const a=document.createElement('a'); a.href=photo.src; a.download='photo.jpg'; document.body.appendChild(a); a.click(); a.remove(); });
btnRetake.addEventListener('click', ()=>{ secPrev.classList.add('hidden'); secCam.classList.remove('hidden'); openFlow(); });
btnDetectCircle.addEventListener('click', onAutoCircle);

async function openFlow(){
  setError(''); S.allowShot=false; btnShot.disabled=true; topHint.classList.remove('ok');
  topHint.textContent = 'Пробуем AR: измеряем расстояние до стола…';
  await enableLevelSensors();

  const xrOk = await tryStartAR();
  if(!xrOk){
    topHint.textContent = 'AR недоступен: расстояние измерить нельзя';
    topHint.classList.remove('ok');
    btnShot.disabled = true; // без расстояния не разблокируем
    await openCameraGUM();
  }
}

/* ===================== AR (WebXR) ===================== */
async function tryStartAR(){
  try{
    if(!('xr' in navigator)) return false;
    S.xr = navigator.xr;
    const ok = await S.xr.isSessionSupported?.('immersive-ar');
    if(!ok) return false;

    const glCanvas = document.createElement('canvas');
    const gl = glCanvas.getContext('webgl', {xrCompatible:true});
    const session = await S.xr.requestSession('immersive-ar', {
      requiredFeatures:['hit-test','local'],
      optionalFeatures:['dom-overlay'],
      domOverlay:{root:document.body},
    });
    S.xrSession=session;
    await gl.makeXRCompatible?.();
    const layer = new XRWebGLLayer(session, gl);
    session.updateRenderState({baseLayer: layer});
    S.xrRefSpace = await session.requestReferenceSpace('local');

    const viewerSpace = await session.requestReferenceSpace('viewer');
    S.xrHitSource = await session.requestHitTestSource({space: viewerSpace});

    const onXRFrame = (time, frame)=>{
      session.requestAnimationFrame(onXRFrame);
      const pose = frame.getViewerPose(S.xrRefSpace);
      if(!pose) return;
      const view = pose.views[0];

      // FOV из матрицы проекции
      S.lastFov.y = 2*Math.atan(1/(view.projectionMatrix[5])); // rad

      const hits = frame.getHitTestResults(S.xrHitSource);
      if(hits.length){
        const hitPose = hits[0].getPose(S.xrRefSpace);
        const camPos = pose.transform.position;
        const h = hitPose.transform.position;
        const dx=h.x-camPos.x, dy=h.y-camPos.y, dz=h.z-camPos.z;
        const distM = Math.hypot(dx,dy,dz);
        S.lastDistanceM = distM;

        // показываем ЦИФРОВОЕ расстояние в см
        const cm = Math.round(distM*100);
        const inBand = (cm >= CONFIG.bandMinCm && cm <= CONFIG.bandMaxCm);
        topHint.textContent = `Расстояние: ${cm} см ${inBand ? '— ОК' : `(нужно ${CONFIG.bandMinCm}–${CONFIG.bandMaxCm} см)`}`;
        topHint.classList.toggle('ok', inBand);
        S.allowShot = inBand;
        btnShot.disabled = !inBand;
      }else{
        topHint.textContent = 'Ищем плоскость стола… поводи телефоном плавно';
        topHint.classList.remove('ok'); S.allowShot=false; btnShot.disabled=true;
      }
    };
    session.requestAnimationFrame(onXRFrame);

    // параллельно откроем обычную камеру
    await openCameraGUM();
    return true;
  }catch(e){
    console.warn('AR failed', e);
    return false;
  }
}

async function onShutter(){
  if(!S.allowShot){ haptic(); return; }
  haptic();

  // Выставляем масштаб в см/пикс по AR (если известно FOV_y и расстояние)
  if(S.lastDistanceM && S.lastFov.y){
    const H = video.videoHeight || 1080;
    const sceneHeightM = 2*S.lastDistanceM*Math.tan(S.lastFov.y/2);
    S.scaleCmPerPx = (sceneHeightM*100)/H; // см/пикс
    scaleMode.textContent = `AR: ${S.scaleCmPerPx.toFixed(3)} см/пикс`;
  } else {
    S.scaleCmPerPx = null;
    scaleMode.textContent = '—';
  }
  await takeShot();
}

/* ===================== getUserMedia camera ===================== */
async function openCameraGUM(){
  if(!canUseGUM()){
    setError('Камера недоступна.', envHint()); try{ fileSystem?.click(); }catch{}; return false;
  }
  const perm = await queryCamPerm();
  if(perm==='denied'){ setError('Доступ к камере запрещён.', envHint()); return false; }
  try{
    const s = await navigator.mediaDevices.getUserMedia({video: CONFIG.idealFacing, audio:false});
    await bindStream(s);
    const caps = S.track?.getCapabilities?.() || {};
    S.torchCap = !!caps.torch;
    btnTorch.classList.toggle('hidden', !S.torchCap);
    return true;
  }catch(e){
    console.warn(e); setError('Не удалось открыть камеру.', envHint()); return false;
  }
}
async function bindStream(stream){
  stopCamera();
  S.stream=stream; S.track=stream.getVideoTracks()[0];
  video.srcObject=stream; try{ await video.play(); }catch{}
  secCam.classList.remove('hidden'); secPrev.classList.add('hidden');
}
function stopCamera(){
  try{ video.pause(); video.srcObject=null }catch{}
  try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}
  S.stream=null; S.track=null;
}
async function toggleTorch(){
  if(!S.track || !S.torchCap) return;
  try{ S._torchOn=!S._torchOn; await S.track.applyConstraints({advanced:[{torch:S._torchOn}]}); haptic(); }
  catch{ btnTorch.classList.add('hidden'); }
}
async function takeShot(){
  if(!video.videoWidth || !video.videoHeight) return;
  const srcW=video.videoWidth, srcH=video.videoHeight;
  const scale = Math.min(1, CONFIG.maxSide/Math.max(srcW,srcH));
  const w=Math.max(1,Math.round(srcW*scale)), h=Math.max(1,Math.round(srcH*scale));
  const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(video,0,0,w,h);
  let url = c.toDataURL('image/webp',0.85), type='image/webp';
  if(!/^data:image\/webp/.test(url)){ url=c.toDataURL('image/jpeg',0.85); type='image/jpeg'; }
  showPreview(url,w,h,type);
  stopCamera();
}
function showPreview(dataUrl,w,h,type){
  photo.src=dataUrl; meta.textContent = `${w}×${h} • ${type}`;
  secCam.classList.add('hidden'); secPrev.classList.remove('hidden');
  areaBox.textContent = S.scaleCmPerPx
    ? `Масштаб установлен по AR: ${S.scaleCmPerPx.toFixed(3)} см/пикс`
    : `AR недоступен — площадь посчитать не сможем (нет масштаба).`;
}

/* ===================== ВЫЧИСЛЕНИЕ ПЛОЩАДИ (круг по превью) ===================== */
async function onAutoCircle(){
  if(!S.scaleCmPerPx){ areaBox.textContent='Нет масштаба (AR не дал расстояние). Площадь недоступна.'; return; }
  const res = await detectCircleFromImg(photo, CONFIG.downscaleW);
  if(!res || res.conf<0.2){ areaBox.textContent='Круг не найден.'; return; }
  // радиус в пикселях превью
  const rPx = res.r * (photo.clientWidth / CONFIG.downscaleW);
  const areaCm2 = Math.PI * Math.pow(rPx * S.scaleCmPerPx, 2);
  areaBox.textContent = `Площадь (круг): ${areaCm2.toFixed(0)} см²`;
}
async function detectCircleFromImg(imgEl, outW){
  const w = imgEl.naturalWidth, h=imgEl.naturalHeight;
  const c=document.createElement('canvas'); c.width=w; c.height=h; c.getContext('2d').drawImage(imgEl,0,0,w,h);
  return detectPlateCircle(c, outW);
}
function detectPlateCircle(sourceCanvas, outW){
  const vw=sourceCanvas.width, vh=sourceCanvas.height;
  const scale=outW/vw; const ow=Math.max(64,Math.round(vw*scale)), oh=Math.max(64,Math.round(vh*scale));
  const c=document.createElement('canvas'); c.width=ow; c.height=oh; const ctx=c.getContext('2d');
  ctx.drawImage(sourceCanvas,0,0,ow,oh);
  const img = ctx.getImageData(0,0,ow,oh); const data=img.data;
  const gray=new Uint8ClampedArray(ow*oh);
  for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j]=(data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114)|0; }
  const mag=new Float32Array(ow*oh);
  const idx=(x,y)=>y*ow+x;
  for(let y=1;y<oh-1;y++){
    for(let x=1;x<ow-1;x++){
      const gxm = -gray[idx(x-1,y-1)] -2*gray[idx(x-1,y)] -gray[idx(x-1,y+1)] + gray[idx(x+1,y-1)] +2*gray[idx(x+1,y)] + gray[idx(x+1,y+1)];
      const gym = -gray[idx(x-1,y-1)] -2*gray[idx(x,y-1)] -gray[idx(x+1,y-1)] + gray[idx(x-1,y+1)] +2*gray[idx(x,y+1)] + gray[idx(x+1,y+1)];
      mag[idx(x,y)] = Math.abs(gxm)+Math.abs(gym);
    }
  }
  let maxM=1; for(let i=0;i<mag.length;i++) if(mag[i]>maxM) maxM=mag[i];
  const cx=ow/2, cy=oh/2, minSide=Math.min(ow,oh);
  const rMin=Math.max(12,Math.round(minSide*0.18)), rMax=Math.round(minSide*0.48);
  const step=2, samples=48; let best={r:0,score:-1}; const twoPi=Math.PI*2;
  for(let r=rMin;r<=rMax;r+=step){
    let s=0; for(let k=0;k<samples;k++){ const a=twoPi*k/samples; const x=(cx+r*Math.cos(a))|0, y=(cy+r*Math.sin(a))|0; s+=mag[idx(x,y)]; }
    const sc = s/(samples*maxM+1e-6); if(sc>best.score) best={r,score:sc};
  }
  return {r:best.r, conf:best.score, w:ow, h:oh};
}

/* ===================== УРОВЕНЬ ===================== */
async function enableLevelSensors(){
  if(S.levelOn) return; let ok=false;
  try{
    if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      try{ const p=await DeviceOrientationEvent.requestPermission(); if(p==='granted'){ window.addEventListener('deviceorientation',onOrient,true); ok=true; } }catch{}
    }
    if(!ok && 'ondeviceorientation' in window){ window.addEventListener('deviceorientation',onOrient,true); ok=true; }
    if(!ok){
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        try{ const p2=await DeviceMotionEvent.requestPermission(); if(p2==='granted'){ window.addEventListener('devicemotion',onMotion,true); ok=true; } }catch{}
      }else if('ondevicemotion' in window){ window.addEventListener('devicemotion',onMotion,true); ok=true; }
    }
  }catch{}
  S.levelOn=ok; permHint.classList.toggle('hidden', ok);
}
function onOrient(e){ const pitch=e.beta??0, roll=e.gamma??0; paintLevel(pitch,roll) }
function onMotion(e){ const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0;
  const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; paintLevel(pitch,roll);
}
function paintLevel(pitch, roll){
  const R=70, T=18, nx=clamp(roll/30,-1,1), ny=clamp(pitch/30,-1,1);
  const dx=nx*R*0.45, dy=-ny*R*0.45;
  levelBubble.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  const ok = Math.hypot(dx,dy)<=T; levelBubble.classList.toggle('ok',ok); levelTarget.classList.toggle('ok',ok);
}

/* ===================== HELPERS ===================== */
function envHint(){
  const https = !isSecureContext ? '\n• Нужен HTTPS (или localhost).' : '';
  return 'Проверьте разрешения на камеру.'+https+'\n• Измерение расстояния работает в Chrome Android с ARCore (WebXR).';
}
window.addEventListener('beforeunload', ()=>stopAll());
function stopAll(){
  try{ S.xrSession?.end?.() }catch{}; S.xrSession=null; S.xrRefSpace=null; S.xrHitSource=null;
  stopCamera();
}
function stopCamera(){
  try{ video.pause(); video.srcObject=null }catch{}
  try{ S.track?.stop() }catch{}; try{ S.stream?.getTracks()?.forEach(t=>t.stop()) }catch{}
  S.stream=null; S.track=null;
}

/* ===================== TESTS (консоль) ===================== */
(function testBand(){
  const inBand = (cm)=> cm>=CONFIG.bandMinCm && cm<=CONFIG.bandMaxCm;
  console.log('[band 25]', inBand(25)?'OK':'FAIL');
  console.log('[band 35]', inBand(35)?'OK':'FAIL');
  console.log('[band 24]', !inBand(24)?'OK':'FAIL');
  console.log('[band 36]', !inBand(36)?'OK':'FAIL');
})();
(function testFovMath(){
  const f = 2*Math.atan(1/1.2); console.log('[fov rad≈]', f.toFixed(3));
})();
</script>
</body>
</html>
