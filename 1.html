<!doctype html>
<html lang="ru">
  <head>
    <!-- ===================== BLOCK: head / meta ===================== -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>FoodCam — одна камера с уровнем (live)</title>
    <meta name="theme-color" content="#0a7cff" />
    <style>
      /* ===================== BLOCK: styles ===================== */
      :root{
        --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb;
        --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
      }
      *{box-sizing:border-box}
      html,body{height:100%}
      body{
        margin:0;background:var(--bg);color:var(--text);
        font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;
      }
      .container{max-width:720px;margin:0 auto;padding:16px}
      h1{font-size:22px;margin:0 0 6px}
      .muted{color:var(--muted);font-size:14px;margin:0 0 16px}
      .hidden{display:none!important}

      /* Buttons */
      .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;
           border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
      .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
      .btn.ghost{background:transparent}
      .btn:active{transform:scale(.98)}
      .row{display:flex;gap:10px;flex-wrap:wrap}

      /* ===================== BLOCK: camera (frame) ===================== */
      .cam-wrap{
        position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;
        aspect-ratio:3/4; /* мобильный портрет */
      }
      .cam-video{width:100%;height:100%;object-fit:cover;display:block}
      .cam-overlay{position:absolute;inset:0;pointer-events:none;}
      /* Рамка/сетка 3×3 */
      .grid{
        position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;
        background:
          linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
          linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
          linear-gradient(90deg, #fff 1px, transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
          linear-gradient(90deg, #fff 1px, transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x;
      }

      /* ===================== BLOCK: centered level ===================== */
      .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
      .outer-ring{position:relative;width:140px;height:140px;border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.2);backdrop-filter:blur(4px)}
      .inner-target{position:absolute;left:50%;top:50%;width:36px;height:36px;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.55)}
      .inner-target.ok{border-color:#34d399}
      .bubble-center{position:absolute;left:50%;top:50%;width:22px;height:22px;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
      .bubble-center.ok{background:#22c55e}

      /* ===================== BLOCK: torch + shutter ===================== */
      .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
      .btn-torch.hidden{display:none}

      .controls{
        position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;
        background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));
        color:#fff
      }
      .shutter{
        width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;
        box-shadow:0 2px 12px rgba(0,0,0,.4)
      }

      /* ===================== BLOCK: preview ===================== */
      .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
      .pad{padding:14px}
      .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
      .meta{color:var(--muted);font-size:12px;margin-top:6px}
      .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    </style>
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Одна камера с уровнем (live)</h1>
        <p class="muted">Нажмите «Открыть камеру», держите телефон <b>параллельно поверхности</b>, ориентируйтесь по уровню. Потом сделайте снимок.</p>
      </header>

      <div id="err" class="error hidden"></div>

      <!-- ===================== BLOCK: camera ===================== -->
      <section id="sec-camera">
        <div class="row" style="margin-bottom:10px">
          <button id="btnOpen" class="btn primary">Открыть камеру</button>
          <button id="btnStop" class="btn">Закрыть</button>
          <span id="permHint" class="badge">iOS: разрешите «Ориентацию и движение»</span>
          <!-- Фоллбек: системная камера/галерея -->
          <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden" />
        </div>

        <div class="cam-wrap" id="camWrap" aria-label="Живое превью камеры">
          <video id="video" class="cam-video" playsinline muted></video>

          <!-- overlay -->
          <div class="cam-overlay">
            <div class="grid"></div>

            <!-- фонарь (верх-слева) -->
            <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

            <!-- центральный уровень -->
            <div class="center-level">
              <div class="outer-ring">
                <div id="target" class="inner-target"></div>
                <div id="bubble" class="bubble-center"></div>
              </div>
            </div>
          </div>

          <!-- нижняя панель — одна круглая кнопка спуска по центру -->
          <div class="controls">
            <button id="btnShot" class="shutter" aria-label="Сделать снимок"></button>
          </div>
        </div>
      </section>

      <!-- ===================== BLOCK: preview ===================== -->
      <section id="sec-preview" class="hidden" style="margin-top:12px">
        <div class="card pad">
          <img id="photo" class="preview-img" alt="Снимок" />
          <div id="meta" class="meta"></div>
          <div class="row" style="margin-top:10px">
            <button id="btnRetake" class="btn">Переснять</button>
            <button id="btnSave" class="btn primary">Скачать снимок</button>
          </div>
        </div>
      </section>
    </main>

    <script>
      // ===================== BLOCK: config/state =====================
      const CONFIG = {
        idealFacing: { facingMode: { ideal: 'environment' } },
        maxSide: 2000,                 // ресайз по большей стороне
      };

      const S = {
        stream: null,
        track: null,
        torchCap: false,
        _torchOn: false,
        levelOn: false,
      };

      // ===================== BLOCK: dom refs =====================
      const $ = (id) => document.getElementById(id);
      const err = $('err');
      const video = $('video');
      const btnOpen = $('btnOpen');
      const btnStop = $('btnStop');
      const btnTorch = $('btnTorch');
      const btnShot = $('btnShot');
      const permHint = $('permHint');
      const bubble = $('bubble');
      const target = $('target');
      const fileSystem = $('file-system');

      const secCam = $('sec-camera');
      const secPrev = $('sec-preview');
      const photo = $('photo');
      const meta = $('meta');
      const btnRetake = $('btnRetake');
      const btnSave = $('btnSave');

      // ===================== BLOCK: utils =====================
      function setError(msg, hint){
        if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; }
        const extra = hint ? `<div class="meta" style="white-space:pre-line;margin-top:6px">${hint}</div>` : '';
        err.innerHTML = `${msg}${extra}`;
        err.classList.remove('hidden');
      }
      function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
      function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch(e){} }

      function showPreview(dataUrl, w, h, type = ''){
        photo.src = dataUrl;
        meta.textContent = `${w}×${h}${type ? ' • '+type : ''}`;
        secCam.classList.add('hidden');
        secPrev.classList.remove('hidden');
      }
      function backToCamera(){
        secPrev.classList.add('hidden');
        secCam.classList.remove('hidden');
      }

      // ===================== BLOCK: env helpers =====================
      function envHintForDenied(){
        const https = !isSecureContext ? '\\n• Нужен HTTPS (или localhost).' : '';
        return 'Доступ к камере запрещён или недоступен.' + https +
               '\\n• Проверьте разрешения на камеру в браузере/приложении.' +
               '\\n• Если в WebView/iframe — нужен Permissions-Policy: camera;' +
               '\\n• iOS: Настройки → Safari/Telegram → Камера: Разрешить; включите «Ориентация и движение».';
      }
      function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
      async function queryCameraPermission(){
        try{
          const p = await navigator.permissions?.query?.({name:'camera'});
          return p?.state||null;
        }catch{return null}
      }

      // ===================== BLOCK: camera open/close =====================
      async function openCamera(){
        setError('');
        if(!canUseGUM()){
          setError('Камера недоступна в этом окружении.', envHintForDenied());
          try{ fileSystem?.click(); }catch(e){}
          return;
        }
        const state = await queryCameraPermission();
        if(state==='denied'){
          setError('Доступ к камере запрещён.', envHintForDenied());
          try{ fileSystem?.click(); }catch(e){}
          return;
        }
        try{
          await enableLevelSensors(); // не критично, если не получится

          // 1) открываем камеру по facingMode
          const s = await getUserMediaSafe({ video: CONFIG.idealFacing, audio: false });
          if(!s) throw new Error('getUserMedia returned null');
          await bindStream(s);

          // 2) попробуем найти реальную заднюю по label и переключиться
          const rearId = await findRearDeviceId();
          if(rearId && !/back|rear|environment/i.test(S.track?.label || '')){
            const s2 = await getUserMediaSafe({ video: { deviceId: { exact: rearId } }, audio:false });
            if(s2) await bindStream(s2);
          }
        }catch(e){
          console.warn('openCamera failed:', e);
          setError('Не удалось открыть камеру.', envHintForDenied());
          try{ fileSystem?.click(); }catch(_){}
        }
      }

      async function getUserMediaSafe(constraints){
        try{ return await navigator.mediaDevices.getUserMedia(constraints); }
        catch(e){ console.warn('getUserMedia blocked:', e?.name||e); return null; }
      }

      async function bindStream(stream){
        stopCamera();

        S.stream = stream;
        S.track = stream.getVideoTracks()[0];

        // Возможности
        const caps = S.track.getCapabilities?.() || {};
        // Torch
        S.torchCap = !!caps.torch;
        S._torchOn = false;
        btnTorch.classList.toggle('hidden', !S.torchCap);

        video.srcObject = stream;
        try{ await video.play(); }catch(e){}

        // показать секцию камеры (если вдруг скрыта)
        secCam.classList.remove('hidden');
        secPrev.classList.add('hidden');
      }

      function stopCamera(){
        try{
          video.pause();
          video.srcObject = null;
          if (S.track) { try{ S.track.stop(); }catch(e){} }
          if (S.stream) {
            S.stream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} });
          }
        }catch(e){}
        S.stream = null; S.track = null;
      }

      async function findRearDeviceId(){
        try{
          const list = await navigator.mediaDevices.enumerateDevices();
          const videoInputs = list.filter(d=>d.kind==='videoinput');
          const rear = videoInputs.find(d=>/back|rear|environment/i.test(d.label));
          return rear?.deviceId || null;
        }catch(e){ return null; }
      }

      // ===================== BLOCK: camera actions (torch/shot) =====================
      async function toggleTorch(){
        if(!S.track || !S.torchCap) return;
        try{
          const cur = S._torchOn = !S._torchOn;
          await S.track.applyConstraints({ advanced: [{ torch: cur }] });
          haptic();
        }catch(e){
          btnTorch.classList.add('hidden');
        }
      }

      async function takeShot(){
        if(!video.videoWidth || !video.videoHeight) return;
        haptic();

        // Рисуем кадр на canvas, ресайз до maxSide
        const srcW = video.videoWidth, srcH = video.videoHeight;
        const scale = Math.min(1, CONFIG.maxSide / Math.max(srcW, srcH));
        const w = Math.max(1, Math.round(srcW * scale));
        const h = Math.max(1, Math.round(srcH * scale));

        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        ctx.drawImage(video, 0, 0, w, h);

        // webp → jpeg fallback
        let dataUrl = c.toDataURL('image/webp', 0.85);
        let type = 'image/webp';
        if (!/^data:image\/webp/.test(dataUrl)) {
          dataUrl = c.toDataURL('image/jpeg', 0.85);
          type = 'image/jpeg';
        }
        showPreview(dataUrl, w, h, type);
        stopCamera();
      }

      // ===================== BLOCK: level sensors =====================
      async function enableLevelSensors(){
        if (S.levelOn) return;
        let granted = false;

        try{
          // iOS 13+ пермишен
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try{
              const p = await DeviceOrientationEvent.requestPermission();
              if (p === 'granted') {
                window.addEventListener('deviceorientation', onOrientation, true);
                granted = true;
              }
            }catch(e){}
          }
          // Android/другие
          if (!granted && 'ondeviceorientation' in window) {
            window.addEventListener('deviceorientation', onOrientation, true);
            granted = true;
          }
          // Fallback через devicemotion (менее точно)
          if (!granted) {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
              try{
                const p2 = await DeviceMotionEvent.requestPermission();
                if (p2 === 'granted') {
                  window.addEventListener('devicemotion', onMotion, true);
                  granted = true;
                }
              }catch(e){}
            } else if ('ondevicemotion' in window) {
              window.addEventListener('devicemotion', onMotion, true);
              granted = true;
            }
          }
        }catch(e){}

        S.levelOn = granted;
        permHint.classList.toggle('hidden', granted);
      }

      function onOrientation(e){
        const pitch = e.beta ?? 0;  // -180..180 (вперёд/назад)
        const roll  = e.gamma ?? 0; // -90..90  (влево/вправо)
        paintLevel(pitch, roll);
      }
      function onMotion(e){
        const a = e.accelerationIncludingGravity || {};
        const x = a.x||0, y=a.y||0, z=a.z||0;
        // Грубая оценка направления:
        const pitch = (Math.atan2(-x, Math.sqrt(y*y+z*z))*180/Math.PI)||0;
        const roll  = (Math.atan2(y, z)*180/Math.PI)||0;
        paintLevel(pitch, roll);
      }

      function paintLevel(pitch, roll){
        // Смещение пузырька в пределах кольца
        const RING_R = 70;
        const TARGET_R = 18;
        const nx = clamp(roll/30, -1, 1);
        const ny = clamp(pitch/30, -1, 1);
        const dx = nx * RING_R * 0.45;
        const dy = -ny * RING_R * 0.45;
        bubble.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        const inTarget = Math.hypot(dx, dy) <= TARGET_R;
        bubble.classList.toggle('ok', inTarget);
        target.classList.toggle('ok', inTarget);
      }

      // ===================== BLOCK: fallback: system camera / gallery =====================
      async function onPickFromSystem(file){
        if(!file) return;
        setError('');
        try{
          let bmp;
          try { bmp = await createImageBitmap(file, { imageOrientation: 'from-image' }); }
          catch { bmp = await createImageBitmap(file); }
          const scale = Math.min(1, CONFIG.maxSide / Math.max(bmp.width, bmp.height));
          const w = Math.max(1, Math.round(bmp.width * scale));
          const h = Math.max(1, Math.round(bmp.height * scale));
          const c = document.createElement('canvas'); c.width = w; c.height = h;
          c.getContext('2d').drawImage(bmp, 0, 0, w, h);
          let dataUrl = c.toDataURL('image/webp', 0.85);
          let type = 'image/webp';
          if (!/^data:image\/webp/.test(dataUrl)) { dataUrl = c.toDataURL('image/jpeg', 0.85); type='image/jpeg'; }
          showPreview(dataUrl, w, h, type);
        }catch(e){
          setError('Не удалось обработать файл.');
          backToCamera();
        }
      }

      // ===================== BLOCK: wiring =====================
      btnOpen.addEventListener('click', openCamera);
      btnStop.addEventListener('click', () => { stopCamera(); });
      btnTorch.addEventListener('click', toggleTorch);
      btnShot.addEventListener('click', takeShot);

      btnRetake.addEventListener('click', () => { backToCamera(); openCamera(); });
      btnSave.addEventListener('click', () => {
        // Скачиваем изображение из <img src=dataURL>
        const url = photo.src; if(!url) return;
        const a = document.createElement('a');
        a.href = url; a.download = 'photo.jpg';
        document.body.appendChild(a); a.click(); a.remove();
      });

      fileSystem.addEventListener('change', (e)=> onPickFromSystem(e.target.files && e.target.files[0]));

      window.addEventListener('pagehide', stopCamera);
      window.addEventListener('beforeunload', stopCamera);

      // ===================== RUNTIME TESTS (консоль) =====================
      (function testTarget(){
        const R = 18, ok = (x,y)=>Math.hypot(x,y) <= R + 1e-6;
        const cases = [
          {pt:[0,0], want:true},
          {pt:[R,0], want:true},
          {pt:[R+0.1,0], want:false},
          {pt:[R/Math.SQRT2,R/Math.SQRT2], want:true}
        ];
        cases.forEach((t,i)=>console.log(`[level test ${i}]`, ok(...t.pt)===t.want?'OK':`FAIL (got ${ok(...t.pt)}, want ${t.want})`));
      })();

      // ===================== NOTE =====================
      // Работает на HTTPS или localhost. В Telegram WebView поведение зависит от платформы.
      // Если камера не открывается: проверьте разрешения на камеру/движение-ориентацию (iOS: Настройки > Safari/Telegram > Motion & Orientation).
    </script>
  </body>
</html>
