<!doctype html>
<html lang="ru">
  <head>
    <!-- ===================== BLOCK: head / meta ===================== -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>FoodCam — камера с уровнем + Scale Coach (HTML)</title>
    <meta name="theme-color" content="#0a7cff" />
    <style>
      /* ===================== BLOCK: styles ===================== */
      :root{
        --bg:#ffffff; --text:#111827; --muted:#6b7280; --ring:#e5e7eb; --primary:#2563eb;
        --ok:#16a34a; --warn:#f59e0b; --danger:#ef4444;
      }
      *{box-sizing:border-box}
      html,body{height:100%}
      body{
        margin:0;background:var(--bg);color:var(--text);
        font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
        -webkit-font-smoothing:antialiased;-webkit-tap-highlight-color:transparent;
      }
      .container{max-width:720px;margin:0 auto;padding:16px}
      h1{font-size:22px;margin:0 0 6px}
      .muted{color:var(--muted);font-size:14px;margin:0 0 16px}
      .hidden{display:none!important}

      /* Buttons */
      .btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;
           border-radius:14px;border:1px solid var(--ring);background:#fff;font-weight:600;cursor:pointer}
      .btn.primary{background:var(--primary);color:#fff;border-color:transparent}
      .btn.ghost{background:transparent}
      .btn:active{transform:scale(.98)}
      .btn[disabled]{opacity:.45;cursor:not-allowed}
      .row{display:flex;gap:10px;flex-wrap:wrap}

      /* ===================== BLOCK: camera (frame) ===================== */
      .cam-wrap{position:relative;border:1px solid var(--ring);border-radius:16px;overflow:hidden;background:#000;aspect-ratio:3/4}
      .cam-video{width:100%;height:100%;object-fit:cover;display:block}
      .cam-overlay{position:absolute;inset:0;pointer-events:none}

      /* Рамка/сетка 3×3 */
      .grid{position:absolute;inset:0;opacity:.25;mix-blend-mode:screen;background:
        linear-gradient(#fff 1px, transparent 1px) 0 calc(33.333% - .5px)/100% 33.333% repeat-y,
        linear-gradient(#fff 1px, transparent 1px) 0 calc(66.666% - .5px)/100% 33.333% repeat-y,
        linear-gradient(90deg, #fff 1px, transparent 1px) calc(33.333% - .5px) 0/33.333% 100% repeat-x,
        linear-gradient(90deg, #fff 1px, transparent 1px) calc(66.666% - .5px) 0/33.333% 100% repeat-x;
      }

      /* ===================== BLOCK: centered level ===================== */
      .center-level{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
      .level-outer{position:relative;width:140px;height:140px;border-radius:50%;border:2px solid rgba(255,255,255,.6);background:rgba(0,0,0,.2);backdrop-filter:blur(4px)}
      .level-target{position:absolute;left:50%;top:50%;width:36px;height:36px;transform:translate(-50%,-50%);border-radius:50%;border:2px solid rgba(255,255,255,.55)}
      .level-target.ok{border-color:#34d399}
      .level-bubble{position:absolute;left:50%;top:50%;width:22px;height:22px;transform:translate(-50%,-50%);border-radius:50%;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.35);transition:transform .08s linear,background-color .15s}
      .level-bubble.ok{background:#22c55e}

      /* ===================== BLOCK: scale coach ===================== */
      .scale-wrap{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
      .scale-ring{position:absolute;border-radius:50%;border:2px dashed rgba(255,255,255,.8)}
      .scale-ring.min{border-color:rgba(34,197,94,.8)} /* нижняя граница допуска */
      .scale-ring.max{border-color:rgba(34,197,94,.8)} /* верхняя граница допуска */
      .scale-hint{position:absolute;left:50%;bottom:16px;transform:translateX(-50%);pointer-events:auto;
        background:rgba(0,0,0,.55);color:#fff;border:1px solid rgba(255,255,255,.25);border-radius:12px;padding:8px 12px;font-size:14px}
      .scale-hint.ok{background:rgba(22,163,74,.85);border-color:rgba(255,255,255,.2)}

      /* ===================== BLOCK: torch + shutter ===================== */
      .btn-torch{position:absolute;left:12px;top:12px;z-index:10;pointer-events:auto;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.3);color:#fff;background:rgba(255,255,255,.1)}
      .btn-torch.hidden{display:none}

      .controls{position:absolute;left:0;right:0;bottom:0;padding:12px;display:flex;gap:10px;align-items:center;justify-content:center;background:linear-gradient(to top, rgba(0,0,0,.55), rgba(0,0,0,0));color:#fff}
      .shutter{width:72px;height:72px;border-radius:999px;border:4px solid rgba(255,255,255,.9);background:#fff;cursor:pointer;box-shadow:0 2px 12px rgba(0,0,0,.4)}
      .shutter[disabled]{opacity:.45;cursor:not-allowed;border-color:rgba(255,255,255,.5)}

      /* ===================== BLOCK: preview & messages ===================== */
      .card{border:1px solid var(--ring);border-radius:16px;background:#fff}
      .pad{padding:14px}
      .preview-img{width:100%;max-height:70vh;object-fit:contain;border-radius:12px}
      .meta{color:var(--muted);font-size:12px;margin-top:6px}
      .error{background:#fef2f2;color:#b91c1c;border:1px solid #fecaca;border-radius:12px;padding:12px;margin:12px 0}
    </style>
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Камера с уровнем и подсказкой масштаба</h1>
        <p class="muted">Держите телефон <b>параллельно поверхности</b> (по уровню). Доведите размер тарелки до зелёной зоны (±5%) — кнопка съёмки станет активной.</p>
      </header>

      <div id="err" class="error hidden"></div>

      <!-- ===================== BLOCK: camera ===================== -->
      <section id="sec-camera">
        <div class="row" style="margin-bottom:10px">
          <button id="btnOpen" class="btn primary">Открыть камеру</button>
          <button id="btnStop" class="btn">Закрыть</button>
          <span id="permHint" class="muted">iOS: разрешите «Ориентацию и движение»</span>
          <!-- Фоллбек: системная камера/галерея -->
          <input id="file-system" type="file" accept="image/*" capture="environment" class="hidden" />
        </div>

        <div class="cam-wrap" id="camWrap" aria-label="Живое превью камеры">
          <video id="video" class="cam-video" playsinline muted></video>

          <!-- overlay -->
          <div class="cam-overlay">
            <div class="grid"></div>

            <!-- фонарь (верх-слева) -->
            <button id="btnTorch" class="btn-torch hidden" aria-label="Фонарик">⚡️</button>

            <!-- центральный уровень -->
            <div class="center-level">
              <div class="level-outer">
                <div id="levelTarget" class="level-target"></div>
                <div id="levelBubble" class="level-bubble"></div>
              </div>
            </div>

            <!-- Scale Coach: два кольца допуска -->
            <div class="scale-wrap">
              <div id="scaleMin" class="scale-ring min" aria-label="Минимальный допуск"></div>
              <div id="scaleMax" class="scale-ring max" aria-label="Максимальный допуск"></div>
              <div id="scaleHint" class="scale-hint">Ищем тарелку…</div>
            </div>
          </div>

          <!-- нижняя панель — одна круглая кнопка спуска по центру -->
          <div class="controls">
            <button id="btnShot" class="shutter" aria-label="Сделать снимок" disabled></button>
          </div>
        </div>
      </section>

      <!-- ===================== BLOCK: preview ===================== -->
      <section id="sec-preview" class="hidden" style="margin-top:12px">
        <div class="card pad">
          <img id="photo" class="preview-img" alt="Снимок" />
          <div id="meta" class="meta"></div>
          <div class="row" style="margin-top:10px">
            <button id="btnRetake" class="btn">Переснять</button>
            <button id="btnSave" class="btn primary">Скачать снимок</button>
          </div>
        </div>
      </section>
    </main>

    <script>
      // ===================== BLOCK: config/state =====================
      const CONFIG = {
        idealFacing: { facingMode: { ideal: 'environment' } },
        maxSide: 2000,                // ресайз по большей стороне
        diamRatio: 0.60,              // ЦЕЛЕВОЙ диаметр тарелки = 60% от меньшей стороны кадра
        tol: 0.05,                    // допуск ±5%
        detectEveryMs: 350,           // частота авто-детекции
        downscaleW: 256,              // ширина фрейма для анализа
      };

      const S = {
        stream: null,
        track: null,
        torchCap: false,
        _torchOn: false,
        levelOn: false,
        detectTimer: null,
        emaR: null,                   // сглаженный радиус (downscaled)
      };

      // ===================== BLOCK: dom refs =====================
      const $ = (id) => document.getElementById(id);
      const err = $('err');
      const video = $('video');
      const camWrap = $('camWrap');
      const btnOpen = $('btnOpen');
      const btnStop = $('btnStop');
      const btnTorch = $('btnTorch');
      const btnShot = $('btnShot');
      const permHint = $('permHint');

      const levelBubble = $('levelBubble');
      const levelTarget = $('levelTarget');

      const scaleMin = $('scaleMin');
      const scaleMax = $('scaleMax');
      const scaleHint = $('scaleHint');

      const fileSystem = $('file-system');

      const secCam = $('sec-camera');
      const secPrev = $('sec-preview');
      const photo = $('photo');
      const meta = $('meta');
      const btnRetake = $('btnRetake');
      const btnSave = $('btnSave');

      // ===================== BLOCK: utils =====================
      function setError(msg, hint){
        if(!msg){ err.classList.add('hidden'); err.innerHTML=''; return; }
        const extra = hint ? '<div class="meta" style="white-space:pre-line;margin-top:6px">'+hint+'</div>' : '';
        err.innerHTML = msg + extra;
        err.classList.remove('hidden');
      }
      function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }
      function haptic(){ try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred?.('light'); }catch(e){} }

      function measureMinSidePx(){
        const r = camWrap.getBoundingClientRect();
        return Math.min(r.width, r.height);
      }
      function setScaleRings(){
        const minSide = measureMinSidePx();
        const targetDiam = CONFIG.diamRatio * minSide;
        const minDiam = targetDiam * (1 - CONFIG.tol);
        const maxDiam = targetDiam * (1 + CONFIG.tol);
        [ [scaleMin, minDiam], [scaleMax, maxDiam] ].forEach(([el, d])=>{
          el.style.width = d + 'px';
          el.style.height = d + 'px';
        });
      }
      function setScaleStatus(state){
        // state: 'search' | 'far' | 'near' | 'ok' | 'manual'
        const texts = {
          search: 'Ищем тарелку…',
          far: 'Дальше → БЛИЖЕ к тарелке',
          near: 'Ближе → ДАЛЬШЕ от тарелки',
          ok: 'ОК — держите так',
          manual: 'Совместите тарелку с зелёной зоной',
        };
        scaleHint.textContent = texts[state] || texts.search;
        scaleHint.classList.toggle('ok', state === 'ok');
        btnShot.disabled = state !== 'ok';
      }

      function showPreview(dataUrl, w, h, type = ''){
        photo.src = dataUrl;
        meta.textContent = w+'×'+h+(type ? ' • '+type : '');
        secCam.classList.add('hidden');
        secPrev.classList.remove('hidden');
      }
      function backToCamera(){
        secPrev.classList.add('hidden');
        secCam.classList.remove('hidden');
      }

      // ===================== BLOCK: env helpers =====================
      function envHintForDenied(){
        const https = !isSecureContext ? '\n• Нужен HTTPS (или localhost).' : '';
        return 'Доступ к камере запрещён или недоступен.' + https +
               '\n• Проверьте разрешения на камеру в браузере/приложении.' +
               '\n• Если в WebView/iframe — нужен Permissions-Policy: camera;' +
               '\n• iOS: Настройки → Safari/Telegram → Камера: Разрешить; включите «Ориентация и движение».';
      }
      function canUseGUM(){ return !!(navigator.mediaDevices?.getUserMedia) && isSecureContext; }
      async function queryCameraPermission(){
        try{ const p = await navigator.permissions?.query?.({name:'camera'}); return p?.state||null; }catch{return null}
      }

      // ===================== BLOCK: camera open/close =====================
      async function openCamera(){
        setError('');
        setScaleRings();
        if(!canUseGUM()){
          setError('Камера недоступна в этом окружении.', envHintForDenied());
          try{ fileSystem?.click(); }catch(e){}
          return;
        }
        const state = await queryCameraPermission();
        if(state==='denied'){
          setError('Доступ к камере запрещён.', envHintForDenied());
          try{ fileSystem?.click(); }catch(e){}
          return;
        }
        try{
          await enableLevelSensors(); // не критично, если не получится

          const s = await getUserMediaSafe({ video: CONFIG.idealFacing, audio: false });
          if(!s) throw new Error('getUserMedia returned null');
          await bindStream(s);

          const rearId = await findRearDeviceId();
          if(rearId && !/back|rear|environment/i.test(S.track?.label || '')){
            const s2 = await getUserMediaSafe({ video: { deviceId: { exact: rearId } }, audio:false });
            if(s2) await bindStream(s2);
          }

          startScaleDetect();
        }catch(e){
          console.warn('openCamera failed:', e);
          setError('Не удалось открыть камеру.', envHintForDenied());
          try{ fileSystem?.click(); }catch(_){ }
        }
      }

      async function getUserMediaSafe(constraints){
        try{ return await navigator.mediaDevices.getUserMedia(constraints); }
        catch(e){ console.warn('getUserMedia blocked:', e?.name||e); return null; }
      }

      async function bindStream(stream){
        stopCamera();
        S.stream = stream; S.track = stream.getVideoTracks()[0];
        const caps = S.track.getCapabilities?.() || {};
        S.torchCap = !!caps.torch; S._torchOn = false;
        btnTorch.classList.toggle('hidden', !S.torchCap);
        video.srcObject = stream; try{ await video.play(); }catch(e){}
        secCam.classList.remove('hidden'); secPrev.classList.add('hidden');
      }

      function stopCamera(){
        if(S.detectTimer){ clearInterval(S.detectTimer); S.detectTimer=null; }
        try{ video.pause(); video.srcObject = null; }catch(e){}
        try{ if(S.track) S.track.stop(); }catch(e){}
        try{ if(S.stream) S.stream.getTracks().forEach(t=>{ try{ t.stop(); }catch(e){} }); }catch(e){}
        S.stream = null; S.track = null; S.emaR = null; setScaleStatus('search');
      }

      async function findRearDeviceId(){
        try{
          const list = await navigator.mediaDevices.enumerateDevices();
          const videoInputs = list.filter(d=>d.kind==='videoinput');
          const rear = videoInputs.find(d=>/back|rear|environment/i.test(d.label));
          return rear?.deviceId || null;
        }catch(e){ return null; }
      }

      // ===================== BLOCK: camera actions (torch/shot) =====================
      async function toggleTorch(){
        if(!S.track || !S.torchCap) return;
        try{ const cur = S._torchOn = !S._torchOn; await S.track.applyConstraints({ advanced: [{ torch: cur }] }); haptic(); }
        catch(e){ btnTorch.classList.add('hidden'); }
      }

      async function takeShot(){
        if(!video.videoWidth || !video.videoHeight) return;
        haptic();
        const srcW = video.videoWidth, srcH = video.videoHeight;
        const scale = Math.min(1, CONFIG.maxSide / Math.max(srcW, srcH));
        const w = Math.max(1, Math.round(srcW * scale));
        const h = Math.max(1, Math.round(srcH * scale));
        const c = document.createElement('canvas'); c.width = w; c.height = h; c.getContext('2d').drawImage(video, 0, 0, w, h);
        let dataUrl = c.toDataURL('image/webp', 0.85); let type='image/webp';
        if (!/^data:image\/webp/.test(dataUrl)) { dataUrl = c.toDataURL('image/jpeg', 0.85); type='image/jpeg'; }
        showPreview(dataUrl, w, h, type); stopCamera();
      }

      // ===================== BLOCK: level sensors =====================
      async function enableLevelSensors(){
        if (S.levelOn) return; let granted=false;
        try{
          if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            try{ const p = await DeviceOrientationEvent.requestPermission(); if (p === 'granted') { window.addEventListener('deviceorientation', onOrientation, true); granted=true; } }catch(e){}
          }
          if (!granted && 'ondeviceorientation' in window) { window.addEventListener('deviceorientation', onOrientation, true); granted=true; }
          if (!granted) {
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
              try{ const p2 = await DeviceMotionEvent.requestPermission(); if (p2 === 'granted') { window.addEventListener('devicemotion', onMotion, true); granted=true; } }catch(e){}
            } else if ('ondevicemotion' in window) { window.addEventListener('devicemotion', onMotion, true); granted=true; }
          }
        }catch(e){}
        S.levelOn = granted; permHint.classList.toggle('hidden', granted);
      }
      function onOrientation(e){ const pitch = e.beta ?? 0; const roll = e.gamma ?? 0; paintLevel(pitch, roll); }
      function onMotion(e){ const a=e.accelerationIncludingGravity||{}; const x=a.x||0,y=a.y||0,z=a.z||0; const pitch=(Math.atan2(-x,Math.sqrt(y*y+z*z))*180/Math.PI)||0; const roll=(Math.atan2(y,z)*180/Math.PI)||0; paintLevel(pitch, roll); }
      function paintLevel(pitch, roll){
        const RING_R = 70, TARGET_R = 18; const nx = clamp(roll/30,-1,1), ny = clamp(pitch/30,-1,1);
        const dx = nx * RING_R * 0.45, dy = -ny * RING_R * 0.45;
        levelBubble.style.transform = 'translate(calc(-50% + '+dx+'px), calc(-50% + '+dy+'px))';
        const inTarget = Math.hypot(dx,dy) <= TARGET_R; levelBubble.classList.toggle('ok', inTarget); levelTarget.classList.toggle('ok', inTarget);
      }

      // ===================== BLOCK: Scale Coach — авто-детект круга =====================
      function startScaleDetect(){
        if(S.detectTimer) clearInterval(S.detectTimer);
        setScaleStatus('search');
        S.detectTimer = setInterval(async ()=>{
          if(!video.videoWidth || !video.videoHeight) return;
          const res = await detectPlateCircle(video, CONFIG.downscaleW);
          if(!res || res.conf < 0.18){ setScaleStatus('manual'); return; }
          const alpha = 0.35; S.emaR = (S.emaR==null) ? res.r : (alpha*res.r + (1-alpha)*S.emaR);
          const minSide = Math.min(res.w, res.h);
          const diamRatioNow = (2*(S.emaR||res.r)) / minSide;
          const target = CONFIG.diamRatio, tol = CONFIG.tol;
          if (Math.abs(diamRatioNow - target) <= tol){ setScaleStatus('ok'); }
          else if (diamRatioNow < target) { setScaleStatus('far'); }
          else { setScaleStatus('near'); }
        }, CONFIG.detectEveryMs);
      }

      async function detectPlateCircle(video, outW){
        const vw = video.videoWidth, vh = video.videoHeight; if(!vw||!vh) return null;
        const scale = outW / vw; const ow = Math.max(64, Math.round(vw*scale)); const oh = Math.max(64, Math.round(vh*scale));
        const c = document.createElement('canvas'); c.width=ow; c.height=oh; const ctx=c.getContext('2d');
        ctx.drawImage(video,0,0,ow,oh);
        const img = ctx.getImageData(0,0,ow,oh); const data = img.data;
        const gray = new Uint8ClampedArray(ow*oh);
        for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j] = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114)|0; }
        const mag = new Float32Array(ow*oh);
        const idx=(x,y)=>y*ow+x;
        for(let y=1;y<oh-1;y++){
          for(let x=1;x<ow-1;x++){
            const gxm = -gray[idx(x-1,y-1)] -2*gray[idx(x-1,y)] -gray[idx(x-1,y+1)] + gray[idx(x+1,y-1)] +2*gray[idx(x+1,y)] + gray[idx(x+1,y+1)];
            const gym = -gray[idx(x-1,y-1)] -2*gray[idx(x,y-1)] -gray[idx(x+1,y-1)] + gray[idx(x-1,y+1)] +2*gray[idx(x,y+1)] + gray[idx(x+1,y+1)];
            mag[idx(x,y)] = Math.abs(gxm) + Math.abs(gym);
          }
        }
        let maxM = 1; for(let i=0;i<mag.length;i++){ if(mag[i]>maxM) maxM=mag[i]; }
        const cx = ow/2, cy = oh/2; const minSide = Math.min(ow, oh);
        const rMin = Math.max(12, Math.round(minSide*0.18));
        const rMax = Math.round(minSide*0.48);
        const step = 2; const samples = 48;
        let best = {r:0, score:-1};
        const twoPi = Math.PI*2;
        for(let r=rMin;r<=rMax;r+=step){
          let s=0;
          for(let k=0;k<samples;k++){
            const a = twoPi*k/samples;
            const x = (cx + r*Math.cos(a))|0; const y = (cy + r*Math.sin(a))|0;
            s += mag[idx(x,y)];
          }
          const sc = s / (samples*maxM + 1e-6);
          if(sc>best.score) best={r,score:sc};
        }
        return { r: best.r, conf: best.score, w: ow, h: oh };
      }

      // ===================== BLOCK: fallback: system camera / gallery =====================
      async function onPickFromSystem(file){
        if(!file) return; setError('');
        try{
          let bmp; try { bmp = await createImageBitmap(file, { imageOrientation: 'from-image' }); } catch { bmp = await createImageBitmap(file); }
          const maxSide = CONFIG.maxSide; const scale = Math.min(1, maxSide / Math.max(bmp.width, bmp.height));
          const w = Math.max(1, Math.round(bmp.width * scale)); const h = Math.max(1, Math.round(bmp.height * scale));
          const c = document.createElement('canvas'); c.width = w; c.height = h; c.getContext('2d').drawImage(bmp, 0, 0, w, h);
          let dataUrl = c.toDataURL('image/webp', 0.85); let type='image/webp';
          if (!/^data:image\/webp/.test(dataUrl)) { dataUrl = c.toDataURL('image/jpeg', 0.85); type='image/jpeg'; }
          showPreview(dataUrl, w, h, type);
        }catch(e){ setError('Не удалось обработать файл.'); backToCamera(); }
      }

      // ===================== BLOCK: wiring =====================
      function onResize(){ setScaleRings(); }
      window.addEventListener('resize', onResize);

      btnOpen.addEventListener('click', openCamera);
      btnStop.addEventListener('click', () => { stopCamera(); });
      btnTorch.addEventListener('click', toggleTorch);
      btnShot.addEventListener('click', takeShot);

      btnRetake.addEventListener('click', () => { backToCamera(); openCamera(); });
      btnSave.addEventListener('click', () => {
        const url = photo.src; if(!url) return; const a = document.createElement('a'); a.href = url; a.download = 'photo.jpg'; document.body.appendChild(a); a.click(); a.remove();
      });

      fileSystem.addEventListener('change', (e)=> onPickFromSystem(e.target.files && e.target.files[0]));

      window.addEventListener('pagehide', stopCamera);
      window.addEventListener('beforeunload', stopCamera);

      // ===================== RUNTIME TESTS (консоль) =====================
      (function testTolerance(){
        const t=CONFIG.diamRatio, tol=CONFIG.tol; const inside=(x)=>Math.abs(x-t)<=tol;
        const cases=[t, t*(1+tol*0.9), t*(1-tol*0.9), t*(1+tol*1.1)];
        cases.forEach((x,i)=>console.log('[tol test '+i+']', inside(x)?'OK':'OUT'));
      })();
      (function testRingSizes(){
        const minSide = 300; const target = CONFIG.diamRatio*minSide; const minD=target*(1-CONFIG.tol), maxD=target*(1+CONFIG.tol);
        console.log('[ring test]', Math.round(minD)===171 && Math.round(maxD)===189 ? 'OK' : 'CHK');
      })();
      (function testDetectorEdgeCase(){
        const v = document.createElement('video');
        if(!v.videoWidth && !v.videoHeight) console.log('[detectPlateCircle test] skipped (no video ready)');
      })();

      // ===================== NOTE =====================
      // Работает на HTTPS или localhost. В Telegram WebView поведение зависит от платформы.
      // Если авто-детект долго не находит круг — появится режим «manual»: совместите тарелку с зелёной зоной ±5%.
    </script>
  </body>
</html>
