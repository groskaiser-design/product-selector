<!DOCTYPE html>
<html lang="ru">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
<meta charset="UTF-8" />
<title>Замеры тела</title>

<script>
window.__pageLoadTime = performance.now();
const APP_HTML_VERSION = 'v2025-0008';
(function smartVersionCheck(){
  try{
    const url = new URL(location.href);
    const v = url.searchParams.get('v');
    if (v !== APP_HTML_VERSION){ url.searchParams.set('v', APP_HTML_VERSION); location.replace(url.href); }
  }catch(_){}
})();
</script>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  html, body, button, [role="button"], .btn {
    touch-action: manipulation;
  }
  input, select, textarea { font-size: 16px; }
  
  :root{
    --bg: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    --cardA: rgba(255,255,255,.18);
    --cardB: rgba(255,255,255,.16);
    --border: rgba(255,255,255,.28);
    --shadow: 0 8px 28px rgba(0,0,0,.18);
    --okA:#fbbf24; --okB:#f59e0b;
    --row: 36px;
    --contentW: 420px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  html{background:transparent;}
  body{
    min-height:100svh;background:transparent;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
    color:#fff;position:relative;isolation:isolate;
  }
  body::before{content:"";position:fixed;inset:0;background:var(--bg);z-index:0;pointer-events:none;transform:translateZ(0);}
  .page{max-width:560px;margin:0 auto;padding:18px 14px 24px;position:relative;z-index:1}

  .section{background:linear-gradient(180deg,var(--cardA),var(--cardB));border:1px solid var(--border);border-radius:18px;box-shadow:var(--shadow);backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);overflow:hidden;margin-bottom:14px;}
  .section-h{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer;user-select:none}
  .section-h h2{font-size:16px;font-weight:800;flex:1}
  .meta{font-size:11px;opacity:.9}
  .toggle{width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:.9}
  .toggle svg{transition:transform .18s ease}
  .section.collapsed .toggle svg{transform:rotate(-90deg)}
  .section-content{padding:0}
  .section.collapsed .section-content{display:none}

  .field{padding:12px}
  .field + .field{border-top:1px solid rgba(255,255,255,.14)}
  .label{font-size:13px;font-weight:800}
  .help{margin-top:6px;text-align:center;font-size:12px;opacity:.8}

  .binary-choice{display:flex;gap:8px;padding:12px;border-radius:14px;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.24);max-width:var(--contentW);width:100%;margin:8px auto 0}
  .binary-btn{flex:1;padding:10px 16px;border:0;border-radius:12px;background:rgba(255,255,255,.15);color:#fff;font-weight:700;font-size:14px;transition:all .2s ease;cursor:pointer}
  .binary-btn.active{background:linear-gradient(135deg,var(--okA),var(--okB));box-shadow:0 4px 12px rgba(251,191,36,.4),inset 0 1px 0 rgba(255,255,255,.3);transform:scale(1.02)}

  .savebar{display:flex;justify-content:center;padding:12px;border-top:1px solid rgba(255,255,255,.14);padding-bottom: calc(12px + env(safe-area-inset-bottom));}
  .btn{
    min-width:160px;padding:12px 16px;border:0;border-radius:14px;
    background:linear-gradient(135deg,var(--okA),var(--okB));color:#fff;font-weight:900;
    box-shadow:var(--shadow);transition: transform .08s ease;
    -webkit-tap-highlight-color:transparent;touch-action: manipulation;
    display:inline-flex;align-items:center;justify-content:center;gap:10px;
  }

/* ============================================================
   ПЛАН/ФАКТ ГРАФИК - ТОЧНАЯ КОПИЯ ИЗ backend-test.html
   ============================================================ */
.pf-chart-card{
  background:rgba(255,255,255,.12);
  border:1px solid rgba(255,255,255,.24);
  border-radius:14px;
  margin:12px 0;
  padding:12px;
  position:relative;
}
.pf-scroller{
  position:relative;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  overscroll-behavior:contain;
  scroll-snap-type:y proximity;
  scroll-behavior:smooth;
  border-radius:16px;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,.35) transparent;
}
.pf-scroller::-webkit-scrollbar{ width: 8px; height: 8px; }
.pf-scroller::-webkit-scrollbar-track{ background: transparent; }
.pf-scroller::-webkit-scrollbar-thumb{
  background-color: rgba(255,255,255,.35);
  border-radius: 8px;
  border: 2px solid transparent;
  background-clip: content-box;
}
.pf-scroller:hover::-webkit-scrollbar-thumb{ background-color: rgba(255,255,255,.55); }
.pf-scroll-hint{
  position:relative;
  margin:10px auto 0;
  opacity:.65;
  pointer-events:none;
  transition:opacity .2s ease;
  width:18px;
  height:18px;
}
.pf-scroll-hint.hidden{ opacity:0; visibility:hidden; }
.pf-scroll-hint svg{
  display:block;
  width:18px;
  height:18px;
  filter:drop-shadow(0 1px 2px rgba(0,0,0,.25));
  animation:hint-bounce 1.2s infinite;
}
.pf-scroll-hint svg.up{ rotate:180deg; animation-name:hint-bounce-up; }
@keyframes hint-bounce{0%,100%{transform:translate(0,0)}50%{transform:translate(0,4px)}}
@keyframes hint-bounce-up{0%,100%{transform:translate(0,0)}50%{transform:translate(0,-4px)}}
@media (prefers-reduced-motion:reduce){ .pf-scroll-hint svg{ animation:none; } }
.pf-list{
  display:flex;
  flex-direction:column;
  gap:0;
  padding:8px 10px;
  border-radius:16px;
  overflow:hidden;
  background:linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,.06));
  border:1px solid rgba(255,255,255,.30);
}
.pf-row{
  display:flex;
  flex-direction:column;
  gap:8px;
  padding:10px 4px;
  scroll-snap-align:start;
}
.pf-row+.pf-row{
  border-top:1px solid rgba(255,255,255,.22);
  margin-top:8px;
  padding-top:16px;
}
.pf-top{
  display:flex;
  align-items:flex-start;
  justify-content:flex-start;
  gap:10px;
  flex-wrap:wrap;
}
.pf-name{
  font-size: clamp(10px, 3.2vw, 16px);
  font-weight: 400;
  line-height: 1.25;
}
.pf-vals{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  font-size:clamp(10px, 3.2vw, 16px);
  line-height:1.25;
}
.pf-vals .pf-kv{
  display:inline-flex;
  align-items:baseline;
  gap:2px;
}
.pf-vals .pf-lab{ color:rgba(255,255,255,.82); margin-right:2px; }
.pf-vals .pf-val{
  font-weight: 800;
  font-size: clamp(10px, 3.8vw, 16px);
}
.pf-dot{ color:rgba(255,255,255,.82); margin:0 2px; }
.pf-gauge{
  position:relative;
  height:28px;
  border-radius:6px;
}
.pf-plan{
  position:absolute;
  inset:0 auto 0 0;
  width:var(--wp,0%);
  border-radius:6px;
  background:rgba(255,255,255,.38);
  border:1px solid rgba(255,255,255,.52);
  box-shadow:inset 0 -1px 0 rgba(255,255,255,.18);
  z-index:1;
}
.pf-fact{
  position:absolute;
  left:0;
  top:50%;
  transform:translateY(-50%);
  height:50%;
  width:var(--wf,0%);
  min-width:6px;
  border-radius:3px;
  border:1px solid rgba(255,255,255,.95);
  background: #22c55e;
  box-shadow:inset 0 -1px 0 rgba(255,255,255,.16),0 10px 24px -14px rgba(9,25,52,.55);
  transform-origin:left center;
  transition:width .22s ease;
  z-index:2;
}
.pf-fact.orange{ background: #f59e0b; }
.pf-fact.red{ background: #ef4444; }
@supports (background: color-mix(in oklab, white 50%, black)){
  .pf-fact{
    background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
               color-mix(in oklab,#22c55e 88%, transparent);
  }
  .pf-fact.orange{
    background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
               color-mix(in oklab,#f59e0b 88%, transparent);
  }
  .pf-fact.red{
    background: linear-gradient(180deg,rgba(255,255,255,.12),rgba(255,255,255,0) 60%),
               color-mix(in oklab,#ef4444 88%, transparent);
  }
}
.pf-fact.neutral{
  background: rgba(255,255,255,.08);
  border-color: rgba(255,255,255,.6);
  box-shadow: inset 0 -1px 0 rgba(255,255,255,.12);
}
.pf-timeline{
  position:relative;
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 8px 6px;
}
.pf-timeline[hidden]{ display:none !important; }
.pf-wheel{
  position:relative;
  flex:1;
  display:flex;
  align-items:center;
  gap:8px;
  overflow-x:auto;
  overflow-y:hidden;
  scroll-snap-type:x mandatory;
  -webkit-overflow-scrolling:touch;
  padding:10px 8px;
  border-radius:14px;
  scrollbar-width:none;
}
.pf-wheel::-webkit-scrollbar{ display:none; }
.pf-wheel .pf-item{
  flex:0 0 auto;
  min-width:76px;
  padding:8px 12px;
  margin:0 4px;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  opacity:.6;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.08);
  scroll-snap-align:center;
  font-size:clamp(12px,3.3vw,14px);
  font-weight:700;
  letter-spacing:.2px;
  color:#fff;
  user-select:none;
  transition:opacity .18s ease, transform .18s ease, box-shadow .18s ease;
  line-height:1.2;
}
.pf-wheel .pf-item.active{
  opacity:1;
  background:rgba(255,255,255,.18);
  border-color:rgba(255,255,255,.45);
  box-shadow:0 6px 20px rgba(27,35,78,.18);
  transform:scale(1.02);
}
.pf-wheel .pf-spacer{
  flex:0 0 var(--edge,0px);
  height:1px;
  padding:0;
  margin:0;
  border:0;
  background:transparent;
}
.pf-wheel-mask{
  pointer-events:none;
  position:absolute;
  inset:0;
}
.pf-wheel-mask::before{
  content:"";
  position:absolute;
  left:var(--mask-left,50%);
  top:var(--mask-top,50%);
  width:var(--mask-w,min(70%,260px));
  height:var(--mask-h,44px);
  border-radius:16px;
  border:1.5px solid rgba(255,255,255,.35);
  background:rgba(255,255,255,.08);
  box-shadow:inset 0 -1px 0 rgba(255,255,255,.16), 0 8px 24px rgba(27,35,78,.12);
  box-sizing:border-box;
}
.pf-loading-indicator{
  position: absolute;
  top: 8px;
  right: 8px;
  width: 20px;
  height: 20px;
  border: 2px solid rgba(255,255,255,.3);
  border-top-color: rgba(255,255,255,.9);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
  opacity: 0;
  transition: opacity 0.2s;
  z-index: 10;
}
.pf-loading-indicator.visible{ opacity: 1; }
@keyframes spin{ to{ transform: rotate(360deg); } }

/* Переопределение для компактного отображения в нашем приложении */
#pfHApp .pf-top{
  align-items:flex-start;
  flex-wrap:wrap;
  gap:4px 0;
}
#pfHApp .pf-top .pf-name{
  flex:1 0 100%;
  display:block;
}
#pfHApp .pf-top .pf-vals{
  gap:6px;
  margin-top:0;
}
  
</style>
</head>
<body>
  <div class="page">

    <section class="section collapsed" id="sec-measures">
      <div class="section-h" data-toggle="sec-measures" role="button" tabindex="0">
        <h2>Анкета</h2>
        <div class="meta" id="lastTime">Последний замер: нет данных</div>
        <div class="toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
      </div>
      <div class="section-content">
        
        <div class="field">
          <div class="label">Пол</div>
          <div class="binary-choice">
            <button class="binary-btn" data-field="gender" data-value="male">Мужской</button>
            <button class="binary-btn" data-field="gender" data-value="female">Женский</button>
          </div>
          <div class="help">Выберите один вариант</div>
        </div>

        <div class="savebar">
          <button class="btn" id="saveBtn">
            <span>Сохранить</span>
          </button>
        </div>
      </div>
    </section>

    <section class="section" id="sec-analytics">
      <div class="section-h" data-toggle="sec-analytics" role="button" tabindex="0">
        <h2>Аналитика</h2>
        <div class="toggle">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
      </div>
      <div class="section-content" id="analytics">
        <div class="field"><div class="help">После сохранения появятся графики.</div></div>
        
        <!-- ПЛАН/ФАКТ ГРАФИК -->
        <div class="field" id="plan-fact-chart-box">
          <div class="pf-chart-card" id="pfHApp">
            <div class="pf-loading-indicator" id="pfLoadingIndicator"></div>
            <div class="pf-scroller" id="pfScroller">
              <div class="pf-list" id="pfRows"></div>
            </div>
            <div class="pf-scroll-hint" id="pfScrollHint">
              <svg viewBox="0 0 24 24" fill="none">
                <path d="M6 9l6 6 6-6" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </div>
            <div class="pf-timeline" id="pfTimeline" hidden>
              <div class="pf-wheel" id="pfDateWheel" tabindex="0"></div>
              <div class="pf-wheel-mask"></div>
            </div>
          </div>
          <div class="help" id="pf-hint">Загружаем график замеров…</div>
        </div>
      </div>
    </section>

  </div>

<script>
(function initTMA(){
  const tg = window.Telegram?.WebApp;
  if (!tg) return;
  try { tg.ready(); tg.expand(); } catch(_){}
})();

// ============================================================
// ПЛАН/ФАКТ ГРАФИК - ТОЧНАЯ КОПИЯ JavaScript из backend-test.html
// ============================================================
(function planFactChartInit(){
  const LABELS = {
    fat: '% Жира',
    neck: 'Шея',
    shoulders: 'Плечи',
    chest: 'Грудь',
    waist: 'Талия',
    hips: 'Ягодицы',
    thigh: 'Бедро',
    calf: 'Икра',
    bicep: 'Бицепс'
  };
  
  const ORDER = ['fat', 'neck', 'shoulders', 'chest', 'waist', 'hips', 'thigh', 'calf', 'bicep'];

  function round(n, p) {
    const m = Math.pow(10, p || 1);
    return Math.round(n * m) / m;
  }

  function fmtNum(n) {
    return isFinite(n) ? round(n, 1) : '—';
  }

  function fmtDeltaNoUnit(n) {
    if (!isFinite(n)) return '—';
    const s = n > 0 ? '+' : '';
    return s + round(n, 1);
  }

  function toRows(json) {
    const rows = [];
    if (!json) return rows;
    for (let i = 0; i < ORDER.length; i++) {
      const key = ORDER[i];
      const it = json[key];
      if (!it) continue;
      const unit = it.unit || (key === 'fat' ? '%' : 'см');
      const planRaw = it.plan != null ? it.plan : it.target;
      const factRaw = it.fact != null ? it.fact : it.actual;
      const plan = Number(planRaw);
      const fact = Number(factRaw);
      let deltaVal = NaN;
      if (it.hasOwnProperty('delta') && isFinite(Number(it.delta))) {
        deltaVal = Number(it.delta);
      } else if (isFinite(fact) && isFinite(plan)) {
        deltaVal = fact - plan;
      }
      rows.push({
        key: key,
        label: LABELS[key] || key,
        unit: unit,
        target: plan,
        actual: fact,
        delta: deltaVal
      });
    }
    return rows;
  }

  function buildDomains(list) {
    let cmMax = 0;
    for (let i = 0; i < list.length; i++) {
      const d = list[i];
      const u = (d.unit || '').trim();
      if (u !== '%') {
        if (isFinite(d.target)) cmMax = Math.max(cmMax, d.target);
        if (isFinite(d.actual)) cmMax = Math.max(cmMax, d.actual);
      }
    }
    return { '%': 100, 'см': cmMax || 1, 'cm': cmMax || 1 };
  }

  function render(el, initialData) {
    const state = { data: initialData };
    const rowsEl = el.querySelector('#pfRows');
    const scroller = el.querySelector('#pfScroller');
    const hint = el.querySelector('#pfScrollHint');
    
    if (!rowsEl || !scroller) {
      return { setData: function() {} };
    }

    let lastScrollTop = scroller.scrollTop || 0;
    let lastDirUp = false;

    function draw() {
      const data = state.data || [];
      const maxByUnit = buildDomains(data);
      rowsEl.innerHTML = '';
      
      for (let i = 0; i < data.length; i++) {
        const d = data[i];
        const unitMax = maxByUnit[(d.unit || '').trim()] || 1;
        const hasPlan = isFinite(d.target);
        const hasFact = isFinite(d.actual);

        const row = document.createElement('div');
        row.className = 'pf-row';
        
        const top = document.createElement('div');
        top.className = 'pf-top';
        
        const deltaStr = isFinite(d.delta) 
          ? fmtDeltaNoUnit(d.delta) + (d.delta > 0 ? ' ▲' : (d.delta < 0 ? ' ▼' : ''))
          : '—';
        
        const nameText = d.key === 'fat' 
          ? (LABELS[d.key] || d.label)
          : (d.label + ' (' + d.unit + ')');
        
        top.innerHTML = '<span class="pf-name">' + nameText + '</span>' +
          '<span class="pf-vals">' +
            '<span class="pf-kv"><span class="pf-lab">Факт:</span> <b class="pf-val">' + fmtNum(d.actual) + '</b></span>' +
            '<span class="pf-dot">•</span>' +
            '<span class="pf-kv"><span class="pf-lab">План:</span> <b class="pf-val">' + fmtNum(d.target) + '</b></span>' +
            '<span class="pf-dot">•</span>' +
            '<span class="pf-kv"><span class="pf-lab">∆:</span> <b class="pf-val">' + deltaStr + '</b></span>' +
          '</span>';

        if (hasPlan || hasFact) {
          const g = document.createElement('div');
          g.className = 'pf-gauge';
          
          if (hasPlan) {
            const wp = Math.max(0, Math.min(100, (d.target / unitMax) * 100));
            const plan = document.createElement('div');
            plan.className = 'pf-plan';
            plan.style.setProperty('--wp', wp + '%');
            g.appendChild(plan);
          }
          
          if (hasFact) {
            const wf = Math.max(0, Math.min(100, (d.actual / unitMax) * 100));
            const fact = document.createElement('div');
            fact.className = 'pf-fact';
            fact.style.setProperty('--wf', wf + '%');
            
            if (isFinite(d.delta)) {
              if (d.key === 'fat' || d.key === 'waist') {
                if (d.actual > d.target && hasPlan) {
                  fact.classList.add('red');
                }
              } else {
                if (hasPlan && d.actual < d.target) {
                  fact.classList.add('orange');
                }
              }
            } else {
              fact.classList.add('neutral');
            }
            
            g.appendChild(fact);
          }
          
          row.appendChild(top);
          row.appendChild(g);
        } else {
          row.appendChild(top);
        }

        rowsEl.appendChild(row);
      }
      
      limitToRows(5);
      updateHint();
    }

    function limitToRows(n) {
      const items = rowsEl.children;
      const rows = [];
      for (let i = 0; i < items.length; i++) {
        if (items[i].classList && items[i].classList.contains('pf-row')) {
          rows.push(items[i]);
        }
      }
      if (!rows.length) return;
      
      const csList = getComputedStyle(rowsEl);
      let maxH = parseFloat(csList.paddingTop) + parseFloat(csList.paddingBottom);
      
      for (let i = 0; i < Math.min(n, rows.length); i++) {
        const r = rows[i];
        const cs = getComputedStyle(r);
        maxH += r.offsetHeight + parseFloat(cs.marginTop || 0) + parseFloat(cs.marginBottom || 0);
      }
      
      maxH += 2;
      scroller.style.maxHeight = Math.ceil(maxH) + 'px';
    }

    function updateHint() {
      if (!hint) return;
      const hasMore = (scroller.scrollHeight - scroller.clientHeight) > 2;
      hint.classList.toggle('hidden', !hasMore);
      if (!hasMore) return;

      const st = scroller.scrollTop;
      if (Math.abs(st - lastScrollTop) > 0.5) {
        lastDirUp = st < lastScrollTop;
      }
      lastScrollTop = st;

      const nearTop = st <= 1;
      const nearBottom = Math.ceil(st + scroller.clientHeight) >= scroller.scrollHeight - 2;

      let showUp = false;
      if (nearTop && !nearBottom) {
        showUp = false;
      } else if (nearBottom && !nearTop) {
        showUp = true;
      } else {
        showUp = lastDirUp;
      }

      const svg = hint.querySelector('svg');
      if (svg) {
        svg.classList.toggle('up', showUp);
      }
    }

    draw();
    scroller.addEventListener('scroll', updateHint, { passive: true });
    window.addEventListener('resize', function() {
      limitToRows(5);
      updateHint();
    }, { passive: true });

    return {
      setData: function(payload) {
        state.data = Array.isArray(payload) ? payload : toRows(payload);
        draw();
      }
    };
  }

  function normalizeSeries(input) {
    if (!input) return { dates: [], rows: [] };
    
    let seriesMap = null;
    if (input.series && typeof input.series === 'object' && !Array.isArray(input.series)) {
      seriesMap = input.series;
    } else {
      return { dates: ['—'], rows: [toRows(input)] };
    }
    
    const dates = Object.keys(seriesMap);
    dates.sort(function(a, b) {
      const da = new Date(a);
      const db = new Date(b);
      if (isFinite(da.getTime()) && isFinite(db.getTime())) {
        return da - db;
      }
      return a > b ? 1 : -1;
    });
    
    const rows = [];
    for (let j = 0; j < dates.length; j++) {
      rows.push(toRows(seriesMap[dates[j]] || {}));
    }
    
    return { dates: dates, rows: rows };
  }

  function formatDateRu(s) {
    const d = new Date(s);
    if (!isFinite(d.getTime())) return s;
    try {
      return d.toLocaleDateString('ru-RU', {
        year: 'numeric',
        month: 'short',
        day: '2-digit'
      });
    } catch (_) {
      return s;
    }
  }

  function setupTimeline(norm, api) {
    const tl = document.getElementById('pfTimeline');
    const wheel = document.getElementById('pfDateWheel');
    const maskEl = tl ? tl.querySelector('.pf-wheel-mask') : null;
    
    if (!tl || !wheel) return;

    const n = (norm && Array.isArray(norm.rows)) ? norm.rows.length : 0;
    if (n === 0) {
      tl.hidden = true;
      return;
    }

    tl.hidden = false;
    wheel.innerHTML = '';
    const items = new Array(n);
    let active = -1;
    let rafId = 0;

    function syncMask() {
      if (!maskEl) return;
      const el = items[Math.max(0, active)] || items[0];
      if (!el) return;
      const rect = el.getBoundingClientRect();
      const wr = wheel.getBoundingClientRect();
      const pr = tl.getBoundingClientRect();
      const padX = 8;
      const padY = 8;
      const scale = 1.5;
      const w = Math.round(rect.width * scale + padX * 2);
      const h = Math.round(rect.height + padY * 2);
      const centerX = wr.left + wr.width / 2;
      const left = Math.round(centerX - w / 2 - pr.left);
      const top = Math.round((wr.top - pr.top) + (wr.height - h) / 2);
      maskEl.style.setProperty('--mask-left', left + 'px');
      maskEl.style.setProperty('--mask-top', top + 'px');
      maskEl.style.setProperty('--mask-w', w + 'px');
      maskEl.style.setProperty('--mask-h', h + 'px');
    }

    function activate(i) {
      if (i === active || i < 0 || i >= n) return;
      if (items[active]) items[active].classList.remove('active');
      active = i;
      if (items[active]) items[active].classList.add('active');
      if (api) api.setData(norm.rows[i] || []);
      syncMask();
    }

    function centerTo(i) {
      i = Math.max(0, Math.min(n - 1, i));
      const el = items[i];
      if (!el) return;
      const target = el.offsetLeft + el.offsetWidth / 2 - wheel.clientWidth / 2;
      wheel.scrollTo({
        left: Math.max(0, target),
        behavior: 'auto'
      });
      activate(i);
      syncMask();
    }

    function onScroll() {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(function() {
        const center = wheel.scrollLeft + wheel.clientWidth / 2;
        let best = -1;
        let bestDist = 1e12;
        for (let k = 0; k < n; k++) {
          const el = items[k];
          const c = el.offsetLeft + el.offsetWidth / 2;
          const d = Math.abs(c - center);
          if (d < bestDist) {
            bestDist = d;
            best = k;
          }
        }
        activate(best);
        syncMask();
      });
    }

    wheel.addEventListener('scroll', onScroll, { passive: true });

    for (let i = 0; i < n; i++) {
      const dateStr = norm.dates[i];
      const btn = document.createElement('button');
      btn.className = 'pf-item';
      btn.type = 'button';
      btn.textContent = formatDateRu(dateStr || String(i));
      btn.addEventListener('click', (function(idx) {
        return function() {
          centerTo(Number(idx));
        };
      })(i));
      wheel.appendChild(btn);
      items[i] = btn;
    }

    function ensureSpacers() {
      const left = document.createElement('div');
      left.className = 'pf-spacer';
      const right = document.createElement('div');
      right.className = 'pf-spacer';
      wheel.prepend(left);
      wheel.appendChild(right);
      const edge = Math.max(0, Math.floor(wheel.clientWidth / 2));
      wheel.style.setProperty('--edge', edge + 'px');
    }

    ensureSpacers();
    centerTo(n - 1);
  }

  const container = document.getElementById('pfHApp');
  let api = null;

  if (container) {
    api = render(container, []);
  }

  window.PlanFactChart = {
    setData: function(json) {
      if (api) api.setData(json);
    },
    setSeries: function(json) {
      const nrm = normalizeSeries(json || {});
      if (api) {
        const l = nrm.rows[(nrm.rows.length - 1) | 0] || [];
        api.setData(l);
      }
      setupTimeline(nrm, api);
    }
  };

  // DEMO DATA
  setTimeout(function(){
    const demoData = {
      "series": {
        "2025-10-18": { "fat": { "unit": "%", "plan": 15, "fact": 24, "delta": -9 }, "neck": { "unit": "см", "plan": 40.6, "fact": 42, "delta": -1.4 }, "shoulders": { "unit": "см", "plan": 135.4, "fact": 125, "delta": 10.4 }, "chest": { "unit": "см", "plan": 115.5, "fact": 115, "delta": 0.5 }, "waist": { "unit": "см", "plan": 90.2, "fact": 95, "delta": -4.8 }, "hips": { "unit": "см", "plan": 103.7, "fact": 100, "delta": 3.7 }, "thigh": { "unit": "см", "plan": 62.8, "fact": 58, "delta": 4.8 }, "calf": { "unit": "см", "plan": 40.5, "fact": 35, "delta": 5.5 }, "bicep": { "unit": "см", "plan": 43.3, "fact": 42, "delta": 1.3 } },
        "2025-10-23": { "fat": { "unit": "%", "plan": 15, "fact": 24, "delta": -9 }, "neck": { "unit": "см", "plan": 40.6, "fact": 42, "delta": -1.4 }, "shoulders": { "unit": "см", "plan": 135.4, "fact": 125, "delta": 10.4 }, "chest": { "unit": "см", "plan": 115.5, "fact": 115, "delta": 0.5 }, "waist": { "unit": "см", "plan": 90.2, "fact": 94, "delta": -3.8 }, "hips": { "unit": "см", "plan": 103.7, "fact": 100, "delta": 3.7 }, "thigh": { "unit": "см", "plan": 62.8, "fact": 58, "delta": 4.8 }, "calf": { "unit": "см", "plan": 40.5, "fact": 35, "delta": 5.5 }, "bicep": { "unit": "см", "plan": 43.3, "fact": 42, "delta": 1.3 } },
        "2025-11-09": { "fat": { "unit": "%", "plan": 15, "fact": 23.8, "delta": -8.8 }, "neck": { "unit": "см", "plan": 40.6, "fact": 42, "delta": -1.4 }, "shoulders": { "unit": "см", "plan": 135.4, "fact": 127, "delta": 8.4 }, "chest": { "unit": "см", "plan": 115.5, "fact": 115, "delta": 0.5 }, "waist": { "unit": "см", "plan": 90.2, "fact": 91, "delta": -0.8 }, "hips": { "unit": "см", "plan": 103.7, "fact": 100, "delta": 3.7 }, "thigh": { "unit": "см", "plan": 62.8, "fact": 58, "delta": 4.8 }, "calf": { "unit": "см", "plan": 40.5, "fact": 35, "delta": 5.5 }, "bicep": { "unit": "см", "plan": 43.3, "fact": 42, "delta": 1.3 } }
      }
    };
    
    if (window.PlanFactChart) {
      window.PlanFactChart.setSeries(demoData);
      const hint = document.getElementById('pf-hint');
      if (hint) hint.textContent = 'Динамика ваших замеров план/факт (демо-данные)';
    }
  }, 500);

})();

// ACCORDIONS
(function(){
  function toggleSection(h){
    const id = h.getAttribute('data-toggle');
    const sec = document.getElementById(id);
    if (!sec) return;
    sec.classList.toggle('collapsed');
  }

  document.addEventListener('click', function(e){
    const h = e.target.closest?.('.section-h');
    if (!h) return;
    toggleSection(h);
  }, { passive:true });
})();
</script>

</body>
</html>