<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Ultima FoodCam Pro</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root {
    --bg-core: #050505;
    --surface-glass: rgba(20, 20, 20, 0.6);
    --surface-border: rgba(255, 255, 255, 0.15);
    --acc-green: #30d158;
    --acc-red: #ff453a;
    --acc-orange: #ff9f0a;
    --acc-blue: #0a84ff;
    --text-main: #ffffff;
    --text-muted: rgba(255, 255, 255, 0.6);
    --font-stack: -apple-system, BlinkMacSystemFont, 'SF Pro Text', Roboto, sans-serif;
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  body {
    margin: 0; padding: 0;
    background: #000;
    color: var(--text-main);
    font-family: var(--font-stack);
    height: 100vh; overflow: hidden;
    display: flex; flex-direction: column;
    overscroll-behavior-y: none;
  }

  /* === CAMERA VIEWPORT === */
  .cam-viewport {
    position: relative;
    flex: 1;
    width: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
  }

  video {
    position: absolute;
    width: 100%; height: 100%;
    object-fit: cover; 
    z-index: 1;
  }

  #uiCanvas {
    position: absolute;
    inset: 0;
    width: 100%; height: 100%;
    z-index: 10;
    pointer-events: none;
  }

  /* Focus Box Animation */
  .focus-box {
    position: absolute;
    width: 70px; height: 70px;
    border: 2px solid var(--acc-orange);
    border-radius: 8px;
    transform: translate(-50%, -50%) scale(1.3);
    opacity: 0;
    pointer-events: none;
    z-index: 50;
    transition: transform 0.2s ease-out, opacity 0.2s ease-out;
    box-shadow: 0 0 15px rgba(255, 159, 10, 0.4);
  }
  .focus-box.active {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  /* === UI LAYERS === */
  .ui-layer {
    position: absolute;
    inset: 0;
    z-index: 20;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: calc(16px + env(safe-area-inset-top)) 16px calc(32px + env(safe-area-inset-bottom)) 16px;
    pointer-events: none;
  }

  /* Top Bar */
  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    pointer-events: auto;
  }

  .status-chip {
    background: var(--surface-glass);
    border: 1px solid var(--surface-border);
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 8px 16px;
    border-radius: 20px;
    display: flex;
    align-items: center; gap: 8px;
    font-size: 13px; font-weight: 600;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    transition: all 0.3s ease;
  }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--acc-orange); box-shadow: 0 0 8px var(--acc-orange); transition: 0.3s; }
  .status-dot.ok { background: var(--acc-green); box-shadow: 0 0 8px var(--acc-green); }

  .icon-btn {
    width: 44px; height: 44px;
    border-radius: 50%;
    background: rgba(40,40,40,0.5);
    border: 1px solid var(--surface-border);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
    color: #fff; cursor: pointer;
    transition: transform 0.1s;
  }
  .icon-btn:active { transform: scale(0.9); background: rgba(80,80,80,0.6); }

  /* Guide overlay */
  .card-guide {
    position: absolute;
    right: 20px; top: 50%; transform: translateY(-50%);
    width: 100px; height: 160px; 
    border: 2px dashed rgba(255,255,255,0.4);
    border-radius: 12px;
    background: rgba(255,255,255,0.05);
    display: flex; align-items: center; justify-content: center;
    text-align: center;
    padding: 8px; 
    pointer-events: none;
  }
  .card-guide span { font-size: 11px; color: rgba(255,255,255,0.7); font-weight: 600; }

  /* Bottom Controls */
  .controls-area {
    display: flex;
    align-items: center;
    justify-content: space-between; 
    pointer-events: auto;
    position: relative;
  }

  .shutter-outer {
    width: 84px; height: 84px;
    border-radius: 50%;
    border: 4px solid rgba(255,255,255,0.3);
    display:flex; align-items:center; justify-content:center;
    transition: 0.3s;
  }
  .shutter-inner {
    width: 64px; height: 64px;
    border-radius: 50%;
    background: #fff;
    transition: 0.3s;
    cursor: pointer;
  }
  
  .shutter-outer.disabled { opacity: 0.5; border-color: var(--acc-red); }
  .shutter-outer.disabled .shutter-inner { background: var(--acc-red); transform: scale(0.4); }
  .shutter-outer.active { border-color: var(--acc-green); transform: scale(1.05); }
  .shutter-outer:active:not(.disabled) .shutter-inner { transform: scale(0.9); }

  /* Permission Overlay */
  .perm-overlay {
    position: absolute; inset: 0; z-index: 100;
    background: rgba(5,5,5,0.85);
    backdrop-filter: blur(20px);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center; padding: 32px; gap: 24px;
  }
  .perm-btn {
    background: var(--acc-blue); color: #fff;
    border: none; padding: 16px 32px;
    border-radius: 16px; font-size: 17px; font-weight: 700;
    cursor: pointer;
  }

  /* === RESULT PREVIEW === */
  .preview-overlay {
    position: absolute; inset: 0; z-index: 200;
    background: #000;
    display: none; 
    flex-direction: column;
  }
  
  .preview-img { 
    flex: 1; 
    width: 100%; 
    min-height: 0; 
    object-fit: contain; 
    background: #111; 
    margin-bottom: 12px;
  }

  .comment-wrap {
    padding: 0 24px 16px 24px;
    width: 100%;
  }
  
  .comment-label {
    display: block;
    color: var(--text-muted);
    font-size: 13px;
    margin-bottom: 8px;
    margin-left: 4px;
    font-weight: 500;
  }

  .comment-input {
    width: 100%;
    height: 80px;
    background: rgba(255,255,255,0.1);
    border: 1px solid var(--surface-border);
    border-radius: 16px;
    padding: 12px 16px;
    color: #fff;
    font-size: 16px;
    font-family: var(--font-stack);
    resize: none;
    outline: none;
    -webkit-appearance: none;
    transition: 0.2s;
  }
  .comment-input::placeholder { color: rgba(255,255,255,0.3); }
  .comment-input:focus { background: rgba(255,255,255,0.15); border-color: var(--acc-blue); }

  .preview-controls {
    padding: 0 24px 34px 24px;
    display: flex; gap: 16px;
    background: #000;
  }
  
  .btn {
    flex: 1; padding: 14px;
    border-radius: 14px;
    font-weight: 600; font-size: 16px;
    border: 1px solid var(--surface-border);
    background: var(--surface-glass);
    color: #fff; cursor: pointer; text-align: center;
  }
  .btn.primary { background: var(--acc-blue); border-color: transparent; }

  .hidden { display: none !important; }
</style>
</head>
<body>

  <div class="cam-viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="uiCanvas"></canvas>
    <div id="focusBox" class="focus-box"></div> <div class="ui-layer">
      <div class="top-bar">
        <div class="icon-btn" id="btnClose">‚úï</div>
        <div class="status-chip" id="lvlChip">
          <div class="status-dot" id="lvlDot"></div>
          <span id="lvlText">–ó–∞–≥—Ä—É–∑–∫–∞...</span>
        </div>
        <div class="icon-btn" id="btnTorch">‚ö°</div>
      </div>

      <div class="card-guide">
        <span>–ë–∞–Ω–∫–æ–≤—Å–∫–∞—è –∫–∞—Ä—Ç–∞ (–¥–ª—è –º–∞—Å—à—Ç–∞–±–∞)</span>
      </div>

      <div class="controls-area">
        <div class="icon-btn" style="opacity:0; pointer-events:none"></div>
        <div class="shutter-outer disabled" id="shutterBtn">
          <div class="shutter-inner"></div>
        </div>
        <div class="icon-btn" id="btnGallery">üñºÔ∏è</div>
      </div>
    </div>
  </div>

  <div id="permReq" class="perm-overlay hidden">
    <div style="font-size:48px; margin-bottom:10px">üìê</div>
    <h2 style="margin:0">–ö–∞–ª–∏–±—Ä–æ–≤–∫–∞</h2>
    <p style="color:var(--text-muted)">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º, —á—Ç–æ–±—ã —É—Ä–æ–≤–µ–Ω—å –∏ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏—è —Ä–∞–±–æ—Ç–∞–ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ.</p>
    <button class="perm-btn" onclick="requestSensors()">–†–∞–∑—Ä–µ—à–∏—Ç—å</button>
  </div>

  <div id="previewScreen" class="preview-overlay">
    <img id="finalPhoto" class="preview-img">
    
    <div class="comment-wrap">
      <label class="comment-label">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π (–≤–µ—Å, —Å–æ—Å—Ç–∞–≤, –Ω—é–∞–Ω—Å—ã)</label>
      <textarea id="commentInput" class="comment-input" placeholder="–ù–∞–ø—Ä–∏–º–µ—Ä: –∫–æ—Ñ–µ –Ω–∞ –∫–æ–∫–æ—Å–æ–≤–æ–º, 300–º–ª"></textarea>
    </div>

    <div class="preview-controls">
      <button class="btn" onclick="retake()">–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
      <button class="btn primary" id="btnSend" onclick="sendPhoto()">–ì–æ—Ç–æ–≤–æ</button>
    </div>
  </div>

  <input type="file" id="fileInput" accept="image/*" class="hidden">

<script>
  // === TELEGRAM INIT ===
  const tg = window.Telegram?.WebApp;
  if(tg) {
    tg.ready(); tg.expand();
    tg.setHeaderColor('#000000');
    if(tg.disableVerticalSwipes) tg.disableVerticalSwipes();
  }

  // === CONFIG ===
  const MAX_TILT = 5; 
  const MAX_SHAKE = 2.0; // –ü–æ—Ä–æ–≥ —Ç—Ä—è—Å–∫–∏ (–º–µ–Ω—å—à–µ = —Å—Ç—Ä–æ–∂–µ)
  const TARGET_ASPECT = 0.75; 

  // === STATE ===
  const state = {
    stream: null,
    track: null,
    levelOK: false,
    shake: 0, 
    angleX: 0,
    angleY: 0,
    photoBlob: null,
    isCapturing: false 
  };

  const DOM = {
    video: document.getElementById('video'),
    canvas: document.getElementById('uiCanvas'),
    ctx: document.getElementById('uiCanvas').getContext('2d'),
    shutter: document.getElementById('shutterBtn'),
    lvlDot: document.getElementById('lvlDot'),
    lvlText: document.getElementById('lvlText'),
    permReq: document.getElementById('permReq'),
    preview: document.getElementById('previewScreen'),
    finalImg: document.getElementById('finalPhoto'),
    btnSend: document.getElementById('btnSend'),
    fileInput: document.getElementById('fileInput'),
    commentInput: document.getElementById('commentInput'),
    focusBox: document.getElementById('focusBox')
  };

  // --- 1. CAMERA INIT ---
  async function initCamera() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const hasBack = devices.some(d => d.kind === 'videoinput' && d.label.toLowerCase().includes('back'));
      const facing = hasBack ? { ideal: 'environment' } : 'environment';

      const constraints = {
        audio: false,
        video: {
          facingMode: facing,
          aspectRatio: { ideal: TARGET_ASPECT },
          width: { ideal: 1920 }, // Full HD –¥–ª—è Smart Burst
          height: { ideal: 2560 }
        }
      };

      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      state.stream = stream;
      state.track = stream.getVideoTracks()[0];
      DOM.video.srcObject = stream;

      const caps = state.track.getCapabilities();
      if (caps.focusMode && caps.focusMode.includes('continuous')) {
        try { await state.track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] }); } catch(e){}
      }

      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      requestAnimationFrame(drawLoop);
      checkSensorPerms();
      
      // –í–∫–ª—é—á–∞–µ–º Tap to Focus
      initTapToFocus();

    } catch (e) {
      console.warn("Camera Init Error", e);
      alert("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: " + e.message);
    }
  }

  // --- 2. SENSORS (Motion & Orientation) ---
  function checkSensorPerms() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DOM.permReq.classList.remove('hidden'); 
    } else {
      window.addEventListener('deviceorientation', handleOrientation);
      window.addEventListener('devicemotion', handleMotion);
    }
  }

  async function requestSensors() {
    try {
      const resp = await DeviceOrientationEvent.requestPermission();
      if (resp === 'granted') {
        DOM.permReq.classList.add('hidden');
        window.addEventListener('deviceorientation', handleOrientation);
        window.addEventListener('devicemotion', handleMotion);
      } else {
        alert("–ë–µ–∑ –¥–∞—Ç—á–∏–∫–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —É—Ä–æ–≤–Ω—è —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–µ –±—É–¥—É—Ç");
        DOM.permReq.classList.add('hidden');
      }
    } catch (e) { alert(e); }
  }

  function handleOrientation(e) {
    if (e.beta === null || e.gamma === null) return;
    state.angleX = e.beta; 
    state.angleY = e.gamma; 
  }

  function handleMotion(e) {
    if (!e.acceleration) return;
    const {x, y, z} = e.acceleration;
    state.shake = Math.hypot(x || 0, y || 0, z || 0);
  }

  // --- 3. UI LOOP ---
  function updateUI() {
    if (state.isCapturing) return;

    if (state.levelOK) {
      DOM.lvlDot.classList.add('ok');
      DOM.lvlText.textContent = "–ò–¥–µ–∞–ª—å–Ω–æ";
      DOM.shutter.classList.remove('disabled');
      DOM.shutter.classList.add('active');
    } else {
      DOM.lvlDot.classList.remove('ok');
      
      if (state.shake > MAX_SHAKE) {
          DOM.lvlText.textContent = "–ù–µ —Ç—Ä—è—Å–∏!";
      } else {
          DOM.lvlText.textContent = "–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ";
      }
      
      DOM.shutter.classList.add('disabled');
      DOM.shutter.classList.remove('active');
    }
  }

  function resizeCanvas() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    if (DOM.canvas.width !== w || DOM.canvas.height !== h) {
        DOM.canvas.width = w;
        DOM.canvas.height = h;
    }
  }

  function drawLoop() {
    const ctx = DOM.ctx;
    const w = DOM.canvas.width;
    const h = DOM.canvas.height;
    ctx.clearRect(0, 0, w, h);
    const cx = w / 2;
    const cy = h / 2;

    const rBubble = 14; 
    const rTarget = 16;
    const maxOffset = 60; 
    
    const rawX = state.angleY || 0;
    const rawY = state.angleX || 0;
    
    const clamp = (val) => Math.max(-20, Math.min(20, val));
    const dx = (clamp(rawX) / 20) * maxOffset; 
    const dy = (clamp(rawY) / 20) * maxOffset;

    const dist = Math.hypot(dx, dy);
    
    // –õ–û–ì–ò–ö–ê –ì–û–¢–û–í–ù–û–°–¢–ò
    const isLevel = (dist + rBubble) <= rTarget;
    const isStable = state.shake < MAX_SHAKE;
    const isReady = isLevel && isStable;

    if (state.levelOK !== isReady && !state.isCapturing) {
      state.levelOK = isReady;
      updateUI();
      if(isReady) haptic('medium');
    }

    // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —É—Ä–æ–≤–Ω—è
    ctx.shadowBlur = 4;
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    
    ctx.beginPath();
    ctx.arc(cx, cy, rTarget, 0, Math.PI * 2); 
    const color = (state.levelOK || state.isCapturing) ? '#30d158' : 'rgba(255,255,255,0.85)';
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(cx + dx, cy + dy, rBubble, 0, Math.PI * 2); 
    ctx.fillStyle = color;
    ctx.fill();
    ctx.shadowBlur = 0;

    requestAnimationFrame(drawLoop);
  }

  // --- 4. SMART BURST CAPTURE ---
  DOM.shutter.addEventListener('click', async () => {
    if (state.isCapturing) return; 
    if (!state.levelOK) { 
        haptic('error'); 
        if (state.shake > MAX_SHAKE) alert("–î–µ—Ä–∂–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ!");
        return; 
    }

    try {
        state.isCapturing = true; 
        haptic('heavy');
        
        DOM.shutter.style.transform = 'scale(0.8)';
        DOM.shutter.style.opacity = '0.5'; 
        DOM.btnSend.textContent = '–í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ...';

        const vid = DOM.video;
        const canvas = document.createElement('canvas');
        canvas.width = vid.videoWidth; 
        canvas.height = vid.videoHeight;
        const ctx = canvas.getContext('2d', { willReadFrequently: true });

        const BURST_COUNT = 5; 
        const BURST_DELAY = 50; 
        let bestScore = -1;
        let bestBlob = null;

        // –°–µ—Ä–∏—è —Å–Ω–∏–º–∫–æ–≤
        for (let i = 0; i < BURST_COUNT; i++) {
            ctx.drawImage(vid, 0, 0);
            const score = getSharpnessScore(ctx, canvas.width, canvas.height);
            console.log(`–ö–∞–¥—Ä ${i+1}: –†–µ–∑–∫–æ—Å—Ç—å ${score}`);

            if (score > bestScore) {
                bestScore = score;
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ª–∏–¥–µ—Ä–∞
                await new Promise(resolve => {
                    canvas.toBlob(blob => {
                        bestBlob = blob;
                        resolve();
                    }, 'image/jpeg', 0.95);
                });
            }
            await new Promise(r => setTimeout(r, BURST_DELAY));
        }
        
        if (bestBlob) {
            showPreview(bestBlob);
        } else {
            throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–¥–µ–ª–∞—Ç—å —Å–Ω–∏–º–æ–∫");
        }

    } catch(err) {
        console.error("Burst error:", err);
        haptic('error');
        alert("–û—à–∏–±–∫–∞: " + err.message);
    } finally {
        state.isCapturing = false;
        DOM.shutter.style.transform = '';
        DOM.shutter.style.opacity = '';
        updateUI(); 
    }
  });

  function showPreview(blob) {
    if(!blob) return;
    state.photoBlob = blob;
    DOM.finalImg.src = URL.createObjectURL(blob);
    DOM.preview.style.display = 'flex';
    DOM.btnSend.textContent = '–ì–æ—Ç–æ–≤–æ'; 
    DOM.btnSend.disabled = false;
  }

  function retake() {
    DOM.preview.style.display = 'none';
    if(DOM.finalImg.src) URL.revokeObjectURL(DOM.finalImg.src);
    DOM.finalImg.src = '';
    state.photoBlob = null;
    DOM.commentInput.value = ''; 
    DOM.btnSend.textContent = '–ì–æ—Ç–æ–≤–æ';
    DOM.btnSend.disabled = false;
  }

  // --- 5. COMPRESSION & SENDING ---
  
  function compressImage(blob, maxWidth, quality) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(blob);
      reader.onload = event => {
        const img = new Image();
        img.src = event.target.result;
        img.onload = () => {
          const elem = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          if (width > maxWidth) {
            height = Math.round(height * (maxWidth / width));
            width = maxWidth;
          }

          elem.width = width;
          elem.height = height;
          const ctx = elem.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          const dataUrl = elem.toDataURL('image/jpeg', quality);
          resolve(dataUrl.split(',')[1]); 
        };
        img.onerror = error => reject(error);
      };
      reader.onerror = error => reject(error);
    });
  }

  async function sendPhoto() {
    // =========================================================
    // !!! –í–ê–ñ–ù–û: –í–°–¢–ê–í–¨ –°–í–û–Æ –°–°–´–õ–ö–£ GAS –°–Æ–î–ê !!!
    const GAS_URL = '–í–°–¢–ê–í–¨_–°–Æ–î–ê_–¢–í–û–ô_GAS_URL'; 
    // =========================================================

    if (GAS_URL.includes('–í–°–¢–ê–í–¨')) {
        alert("–û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏: –Ω–µ —É–∫–∞–∑–∞–Ω URL —Å–∫—Ä–∏–ø—Ç–∞!");
        return;
    }

    const comment = DOM.commentInput.value.trim();
    const btn = DOM.btnSend;
    
    btn.textContent = '–°–∂–∞—Ç–∏–µ...';
    btn.disabled = true;
    haptic('light');

    try {
      // –°–∂–∏–º–∞–µ–º –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ (1280px / 0.8 quality)
      const base64ForServer = await compressImage(state.photoBlob, 1280, 0.8);
      
      btn.textContent = '–ê–Ω–∞–ª–∏–∑ AI...';

      const payload = {
          action: "analyze_food", 
          image_base64: base64ForServer,
          user_comment: comment,
          user_id: tg?.initDataUnsafe?.user?.id || 'debug_user'
      };

      const response = await fetch(GAS_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'text/plain;charset=utf-8' },
          body: JSON.stringify(payload)
      });

      const result = await response.json();

      if (!result.success) throw new Error(result.error || "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞");

      console.log("Success:", result.data);
      haptic('success');
      btn.textContent = '–£—Å–ø–µ—à–Ω–æ!';
      
      setTimeout(() => {
          // –í—ã–±–µ—Ä–∏ –ø–æ–≤–µ–¥–µ–Ω–∏–µ: –∑–∞–∫—Ä—ã—Ç—å –∏–ª–∏ –ø–µ—Ä–µ—Å–Ω—è—Ç—å
          retake(); 
          // tg.close(); 
      }, 1500);

    } catch (error) {
      console.error(error);
      btn.textContent = '–û—à–∏–±–∫–∞';
      haptic('error');
      alert("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å: " + error.message);
      btn.disabled = false;
    }
  }

  // --- 6. UTILS (Focus, Sharpness, Haptic) ---

  // Tap-to-Focus Logic
  function initTapToFocus() {
    const box = DOM.focusBox;
    const viewport = document.querySelector('.cam-viewport');

    viewport.addEventListener('click', async (e) => {
      // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º UI
      if (e.target.closest('.icon-btn') || e.target.closest('.shutter-outer')) return;

      const rect = viewport.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // –ê–Ω–∏–º–∞—Ü–∏—è
      box.style.left = x + 'px';
      box.style.top = y + 'px';
      box.classList.add('active');
      haptic('light');

      setTimeout(() => box.classList.remove('active'), 1500);

      if (!state.track) return;

      try {
        const capabilities = state.track.getCapabilities();
        if (capabilities.pointsOfInterest) {
          // Android API
          const normX = x / rect.width;
          const normY = y / rect.height;
          await state.track.applyConstraints({
            advanced: [{ pointsOfInterest: [{ x: normX, y: normY }] }]
          });
        } else {
            // iOS Hack (reset focus)
            await state.track.applyConstraints({ advanced: [{ focusMode: 'manual' }] });
            setTimeout(async () => {
                await state.track.applyConstraints({ advanced: [{ focusMode: 'continuous' }] });
            }, 200);
        }
      } catch (err) { }
    });
  }

  function getSharpnessScore(ctx, width, height) {
    const w = Math.floor(width / 2);
    const h = Math.floor(height / 2);
    const offsetX = Math.floor(width / 4);
    const offsetY = Math.floor(height / 4);

    const imageData = ctx.getImageData(offsetX, offsetY, w, h);
    const data = imageData.data;
    let score = 0;

    for (let y = 0; y < h; y += 4) {
      for (let x = 0; x < w; x += 4) {
        const i = (y * w + x) * 4;
        const lum = (data[i] + data[i+1] + data[i+2]) / 3;
        const right = (data[i+4] + data[i+5] + data[i+6]) / 3 || lum;
        const bottom = (data[i + w*4] + data[i + w*4 + 1] + data[i + w*4 + 2]) / 3 || lum;
        score += Math.abs(lum - right) + Math.abs(lum - bottom);
      }
    }
    return score;
  }

  function haptic(style) { if (tg?.HapticFeedback) tg.HapticFeedback.impactOccurred(style); }
  
  let torchState = false;
  document.getElementById('btnTorch').onclick = async () => {
    if(!state.track) return;
    torchState = !torchState;
    try { await state.track.applyConstraints({ advanced: [{ torch: torchState }] }); } catch(e){}
    haptic('light');
  };

  document.getElementById('btnGallery').onclick = () => DOM.fileInput.click();
  DOM.fileInput.onchange = (e) => {
    const file = e.target.files[0];
    if(file) showPreview(file);
    e.target.value = '';
  };

  document.getElementById('btnClose').onclick = () => window.history.back();

  initCamera();

</script>
</body>
</html>
