<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<title>Ultima FoodCam</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root {
    --bg-core: #000000;
    --surface-glass: rgba(20, 20, 20, 0.6);
    --surface-border: rgba(255, 255, 255, 0.15);
    --acc-green: #30d158;
    --acc-red: #ff453a;
    --acc-orange: #ff9f0a;
    --acc-blue: #0a84ff;
    --text-main: #ffffff;
    --text-muted: rgba(255, 255, 255, 0.6);
    --font-stack: -apple-system, BlinkMacSystemFont, 'SF Pro Text', Roboto, sans-serif;
  }

  * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
  body {
    margin: 0; padding: 0;
    background: var(--bg-core);
    color: var(--text-main);
    font-family: var(--font-stack);
    height: 100vh; overflow: hidden;
    display: flex; flex-direction: column;
    overscroll-behavior-y: none;
  }

  /* === CAMERA VIEWPORT === */
  .cam-viewport {
    position: relative;
    flex: 1;
    width: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
  }

  /* –í–ê–ñ–ù–û: contain —É–±–∏—Ä–∞–µ—Ç –∑—É–º, –¥–æ–±–∞–≤–ª—è—è –ø–æ–ª–æ—Å—ã */
  video {
    position: absolute;
    width: 100%; height: 100%;
    object-fit: contain; 
    z-index: 1;
  }

  /* Canvas –¥–ª—è —É—Ä–æ–≤–Ω—è */
  #uiCanvas {
    position: absolute;
    inset: 0;
    width: 100%; height: 100%;
    z-index: 10;
    pointer-events: none;
  }

  /* === UI LAYERS === */
  .ui-layer {
    position: absolute;
    inset: 0;
    z-index: 20;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: calc(16px + env(safe-area-inset-top)) 16px calc(32px + env(safe-area-inset-bottom)) 16px;
    pointer-events: none;
  }

  /* Top Bar */
  .top-bar {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    pointer-events: auto;
  }

  .status-chip {
    background: var(--surface-glass);
    border: 1px solid var(--surface-border);
    backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 8px 16px;
    border-radius: 20px;
    display: flex;
    align-items: center; gap: 8px;
    font-size: 13px; font-weight: 600;
    transition: all 0.3s ease;
  }
  .status-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--acc-orange); box-shadow: 0 0 8px var(--acc-orange); transition: 0.3s; }
  .status-dot.ok { background: var(--acc-green); box-shadow: 0 0 8px var(--acc-green); }

  .icon-btn {
    width: 44px; height: 44px;
    border-radius: 50%;
    background: rgba(40,40,40,0.5);
    border: 1px solid var(--surface-border);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
    color: #fff; cursor: pointer;
    transition: transform 0.1s;
    font-size: 18px;
  }
  .icon-btn:active { transform: scale(0.9); background: rgba(80,80,80,0.6); }

  /* Guide overlay */
  .card-guide {
    position: absolute;
    right: 20px; top: 50%; transform: translateY(-50%);
    width: 100px; height: 160px; 
    border: 2px dashed rgba(255,255,255,0.4);
    border-radius: 12px;
    background: rgba(255,255,255,0.05);
    display: flex; align-items: center; justify-content: center;
    text-align: center;
    padding: 8px; 
    pointer-events: none;
  }
  .card-guide span { font-size: 11px; color: rgba(255,255,255,0.7); font-weight: 600; }

  /* Bottom Controls */
  .controls-area {
    display: flex;
    align-items: center;
    justify-content: space-between;
    pointer-events: auto;
    padding: 0 20px;
  }

  .shutter-outer {
    width: 84px; height: 84px;
    border-radius: 50%;
    border: 4px solid rgba(255,255,255,0.3);
    display:flex; align-items:center; justify-content:center;
    transition: 0.3s;
  }
  .shutter-inner {
    width: 64px; height: 64px;
    border-radius: 50%;
    background: #fff;
    transition: 0.3s;
    cursor: pointer;
  }
  
  .shutter-outer.disabled { opacity: 0.5; border-color: var(--acc-red); }
  .shutter-outer.disabled .shutter-inner { background: var(--acc-red); transform: scale(0.4); }
  .shutter-outer.active { border-color: var(--acc-green); transform: scale(1.05); }
  .shutter-outer:active:not(.disabled) .shutter-inner { transform: scale(0.9); }

  /* Permission Overlay */
  .perm-overlay {
    position: absolute; inset: 0; z-index: 100;
    background: rgba(5,5,5,0.85);
    backdrop-filter: blur(20px);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    text-align: center; padding: 32px; gap: 24px;
  }
  .perm-btn {
    background: var(--acc-blue); color: #fff;
    border: none; padding: 16px 32px;
    border-radius: 16px; font-size: 17px; font-weight: 700;
    cursor: pointer;
  }

  /* === RESULT PREVIEW === */
  .preview-overlay {
    position: absolute; inset: 0; z-index: 200;
    background: #000;
    display: none; 
    flex-direction: column;
  }
  
  .preview-img { 
    flex: 1; width: 100%; min-height: 0;
    object-fit: contain; background: #111; 
    margin-bottom: 12px;
  }

  .comment-wrap { padding: 0 24px 16px 24px; width: 100%; }
  .comment-label { display: block; color: var(--text-muted); font-size: 13px; margin-bottom: 8px; margin-left: 4px; font-weight: 500; }

  .comment-input {
    width: 100%; height: 80px;
    background: rgba(255,255,255,0.1);
    border: 1px solid var(--surface-border); border-radius: 16px;
    padding: 12px 16px; color: #fff; font-size: 16px;
    font-family: var(--font-stack);
    resize: none; outline: none; -webkit-appearance: none;
    transition: 0.2s;
  }
  .comment-input:focus { background: rgba(255,255,255,0.15); border-color: var(--acc-blue); }

  .preview-controls {
    padding: 0 24px 34px 24px;
    display: flex; gap: 16px;
    background: #000;
  }
  
  .btn {
    flex: 1; padding: 14px;
    border-radius: 14px;
    font-weight: 600; font-size: 16px;
    border: 1px solid var(--surface-border);
    background: var(--surface-glass);
    color: #fff; cursor: pointer; text-align: center;
  }
  .btn.primary { background: var(--acc-blue); border-color: transparent; }
  .hidden { display: none !important; }

</style>
</head>
<body>

  <div class="cam-viewport">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="uiCanvas"></canvas>
    
    <div class="ui-layer">
      <div class="top-bar">
        <div class="icon-btn" id="btnClose">‚úï</div>
        <div class="status-chip" id="lvlChip">
          <div class="status-dot" id="lvlDot"></div>
          <span id="lvlText">–£—Ä–æ–≤–µ–Ω—å</span>
        </div>
        <div class="icon-btn" id="btnTorch">‚ö°</div>
      </div>

      <div class="card-guide">
        <span>–ö–∞—Ä—Ç–∞ –¥–ª—è –º–∞—Å—à—Ç–∞–±–∞</span>
      </div>

      <div class="controls-area">
        <div style="width: 44px"></div>
        
        <div class="shutter-outer disabled" id="shutterBtn">
          <div class="shutter-inner"></div>
        </div>

        <div class="icon-btn" id="btnSwitchCam" style="display:none">üîÑ</div>
      </div>
    </div>
  </div>

  <div id="permReq" class="perm-overlay hidden">
    <div style="font-size:48px; margin-bottom:10px">üìê</div>
    <h2 style="margin:0">–ù–∞—Å—Ç—Ä–æ–π–∫–∞</h2>
    <p style="color:var(--text-muted)">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –¥–∞—Ç—á–∏–∫–∞–º –¥–ª—è —É—Ä–æ–≤–Ω—è.</p>
    <button class="perm-btn" onclick="requestSensors()">–†–∞–∑—Ä–µ—à–∏—Ç—å</button>
  </div>

  <div id="previewScreen" class="preview-overlay">
    <img id="finalPhoto" class="preview-img">
    
    <div class="comment-wrap">
      <label class="comment-label">–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π</label>
      <textarea id="commentInput" class="comment-input" placeholder="–í–µ—Å, —Å–æ—Å—Ç–∞–≤..."></textarea>
    </div>

    <div class="preview-controls">
      <button class="btn" onclick="retake()">–ü–µ—Ä–µ—Å–Ω—è—Ç—å</button>
      <button class="btn primary" id="btnSend" onclick="sendPhoto()">–ì–æ—Ç–æ–≤–æ</button>
    </div>
  </div>

<script>
  // === 0. INIT ===
  const tg = window.Telegram?.WebApp;
  if(tg) {
    tg.ready(); tg.expand();
    tg.setHeaderColor('#000000');
    if(tg.disableVerticalSwipes) tg.disableVerticalSwipes();
  }

  // === 1. CONFIG & STATE ===
  const STORAGE_KEY = 'ultima_cam_id_final';
  const state = {
    stream: null,
    track: null,
    imageCapture: null,
    levelOK: false,
    angleX: 0,
    angleY: 0,
    photoBlob: null,
    isCapturing: false,
    
    videoDevices: [],
    currentCamIndex: 0
  };

  const DOM = {
    video: document.getElementById('video'),
    canvas: document.getElementById('uiCanvas'),
    ctx: document.getElementById('uiCanvas').getContext('2d'),
    shutter: document.getElementById('shutterBtn'),
    lvlDot: document.getElementById('lvlDot'),
    lvlText: document.getElementById('lvlText'),
    permReq: document.getElementById('permReq'),
    preview: document.getElementById('previewScreen'),
    finalImg: document.getElementById('finalPhoto'),
    btnSend: document.getElementById('btnSend'),
    commentInput: document.getElementById('commentInput'),
    btnSwitch: document.getElementById('btnSwitchCam')
  };

  // === 2. CAMERA LOGIC (THE BRAIN) ===
  async function initCamera() {
    try {
      // 1. –ü—Ä–æ–±—É–µ–º –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—É—é –∫–∞–º–µ—Ä—É
      const savedId = localStorage.getItem(STORAGE_KEY);
      let constraints = { audio: false };

      if (savedId) {
        constraints.video = { deviceId: { exact: savedId } };
      } else {
        // –ï—Å–ª–∏ –Ω–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è, –ø—Ä–æ—Å–∏–º –∑–∞–¥–Ω—é—é (–≤–∞–∂–Ω–æ –¥–ª—è iOS)
        constraints.video = { facingMode: 'environment' };
      }

      // 2. –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫
      try {
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          applyStream(stream);
      } catch (e) {
          // –ï—Å–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π ID —Å–ª–æ–º–∞–ª—Å—è - —Å–±—Ä–∞—Å –∏ —Ä–µ—Å—Ç–∞—Ä—Ç
          if (savedId) {
              localStorage.removeItem(STORAGE_KEY);
              initCamera(); 
              return;
          }
          throw e;
      }

      // 3. –°–∫–∞–Ω–∏—Ä—É–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
      await scanDevices();

    } catch (e) {
      alert("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã: " + e.message);
    }
  }

  function applyStream(stream) {
    if(state.stream) state.stream.getTracks().forEach(t => t.stop());
    
    state.stream = stream;
    state.track = stream.getVideoTracks()[0];
    DOM.video.srcObject = stream;

    if (window.ImageCapture) {
        state.imageCapture = new ImageCapture(state.track);
    }

    // –ó–∞–ø—É—Å–∫ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    requestAnimationFrame(drawLoop);
    checkSensorPerms();
  }

  async function scanDevices() {
    try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoInputs = devices.filter(d => d.kind === 'videoinput');

        // –§–∏–ª—å—Ç—Ä: —É–±–∏—Ä–∞–µ–º —Ñ—Ä–æ–Ω—Ç–∞–ª–∫–∏
        const backCams = videoInputs.filter(d => {
            const l = d.label.toLowerCase();
            return !l.includes('front') && !l.includes('user') && !l.includes('selfie');
        });

        // –ï—Å–ª–∏ –∑–∞–¥–Ω–∏—Ö –Ω–µ –Ω–∞—à–ª–∏ (–±—ã–≤–∞–µ—Ç –±–∞–≥), –±–µ—Ä–µ–º –≤—Å–µ
        state.videoDevices = backCams.length > 0 ? backCams : videoInputs;

        // –ï—Å–ª–∏ –∫–∞–º–µ—Ä > 1, –≤–∫–ª—é—á–∞–µ–º –∫–Ω–æ–ø–∫—É —Å–º–µ–Ω—ã
        if (state.videoDevices.length > 1) {
            DOM.btnSwitch.style.display = 'flex';
            
            // –ù–∞—Ö–æ–¥–∏–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å
            const currentId = state.track.getSettings().deviceId;
            const idx = state.videoDevices.findIndex(d => d.deviceId === currentId);
            if(idx !== -1) state.currentCamIndex = idx;
        }
    } catch(e) { console.error(e); }
  }

  // === 3. SWITCH HANDLER ===
  DOM.btnSwitch.onclick = async () => {
    if (state.videoDevices.length < 2) return;
    haptic('selection');

    // –°–ª–µ–¥—É—é—â–∞—è –∫–∞–º–µ—Ä–∞
    state.currentCamIndex = (state.currentCamIndex + 1) % state.videoDevices.length;
    const nextCam = state.videoDevices[state.currentCamIndex];

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—ã–±–æ—Ä
    localStorage.setItem(STORAGE_KEY, nextCam.deviceId);

    // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫
    try {
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: false,
            video: { deviceId: { exact: nextCam.deviceId } }
        });
        applyStream(stream);
    } catch(e) { alert("–°–º–µ–Ω–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å"); }
  };

  // === 4. LEVEL & SENSORS ===
  function checkSensorPerms() {
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      DOM.permReq.classList.remove('hidden'); 
    } else {
      window.addEventListener('deviceorientation', handleOrientation);
    }
  }

  async function requestSensors() {
    try {
      const resp = await DeviceOrientationEvent.requestPermission();
      if (resp === 'granted') {
        DOM.permReq.classList.add('hidden');
        window.addEventListener('deviceorientation', handleOrientation);
      } else {
        alert("–£—Ä–æ–≤–µ–Ω—å –Ω–µ –±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å –±–µ–∑ –ø—Ä–∞–≤");
        DOM.permReq.classList.add('hidden');
      }
    } catch (e) { alert(e); }
  }

  function handleOrientation(e) {
    if (e.beta !== null) {
        state.angleX = e.gamma; 
        state.angleY = e.beta;  
    }
  }

  // === 5. DRAWING LOOP ===
  function drawLoop() {
    const ctx = DOM.ctx;
    const w = DOM.canvas.width;
    const h = DOM.canvas.height;
    ctx.clearRect(0, 0, w, h);
    
    // –¶–µ–Ω—Ç—Ä
    const cx = w / 2;
    const cy = h / 2;

    // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É—Ä–æ–≤–Ω—è
    const rBubble = 14; 
    const rTarget = 16;
    const sensitivity = 4; // –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
    
    const rawX = state.angleX || 0;
    const rawY = state.angleY || 0;
    
    const clamp = (val, max) => Math.max(-max, Math.min(max, val));
    const dx = clamp(rawX * sensitivity, 50);
    const dy = clamp(rawY * sensitivity, 50);

    const dist = Math.hypot(dx, dy);
    const isInside = dist <= 20; // –î–æ–ø—É—Å–∫

    if (state.levelOK !== isInside && !state.isCapturing) {
      state.levelOK = isInside;
      updateUI();
      if(isInside) haptic('medium');
    }

    // –†–∏—Å—É–µ–º
    ctx.shadowBlur = 4;
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    
    // –ö–æ–ª—å—Ü–æ
    ctx.beginPath();
    ctx.arc(cx, cy, rTarget, 0, Math.PI * 2); 
    const color = (state.levelOK || state.isCapturing) ? '#30d158' : 'rgba(255,255,255,0.85)';
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();

    // –ü—É–∑—ã—Ä–µ–∫
    ctx.beginPath();
    ctx.arc(cx + dx, cy + dy, rBubble, 0, Math.PI * 2); 
    ctx.fillStyle = color;
    ctx.fill();
    ctx.shadowBlur = 0;

    requestAnimationFrame(drawLoop);
  }
  
  function updateUI() {
    if (state.isCapturing) return;
    if (state.levelOK) {
      DOM.lvlDot.classList.add('ok');
      DOM.lvlText.textContent = "–†–æ–≤–Ω–æ";
      DOM.shutter.classList.remove('disabled');
      DOM.shutter.classList.add('active');
    } else {
      DOM.lvlDot.classList.remove('ok');
      DOM.lvlText.textContent = "–í—ã—Ä–æ–≤–Ω—è–π—Ç–µ";
      DOM.shutter.classList.add('disabled');
      DOM.shutter.classList.remove('active');
    }
  }

  function resizeCanvas() {
    if (DOM.canvas.width !== window.innerWidth) {
        DOM.canvas.width = window.innerWidth;
        DOM.canvas.height = window.innerHeight;
    }
  }

  // === 6. CAPTURE ===
  DOM.shutter.onclick = async () => {
    if (state.isCapturing) return; 
    if (!state.levelOK) { haptic('error'); return; }

    try {
        state.isCapturing = true; 
        haptic('heavy');
        DOM.shutter.style.opacity = '0.5';

        await new Promise(r => setTimeout(r, 50));

        // 1. ImageCapture
        if (state.imageCapture) {
          try {
            const blob = await state.imageCapture.takePhoto();
            showPreview(blob);
            return;
          } catch(e) {}
        }

        // 2. Canvas Fallback
        const c = document.createElement('canvas');
        // –í–∞–∂–Ω–æ: –±–µ—Ä–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã –≤–∏–¥–µ–æ, –∞ –Ω–µ —ç–∫—Ä–∞–Ω–∞
        c.width = DOM.video.videoWidth;
        c.height = DOM.video.videoHeight;
        c.getContext('2d').drawImage(DOM.video, 0, 0);
        
        c.toBlob(blob => {
            showPreview(blob);
        }, 'image/jpeg', 0.95);

    } catch(e) {
        haptic('error');
    } finally {
        state.isCapturing = false;
        DOM.shutter.style.opacity = '';
        updateUI();
    }
  };

  function showPreview(blob) {
    state.photoBlob = blob;
    DOM.finalImg.src = URL.createObjectURL(blob);
    DOM.preview.style.display = 'flex';
  }

  function retake() {
    DOM.preview.style.display = 'none';
    URL.revokeObjectURL(DOM.finalImg.src);
    DOM.finalImg.src = '';
  }

  function sendPhoto() {
    haptic('success');
    DOM.btnSend.textContent = '–ì–æ—Ç–æ–≤–æ!';
    setTimeout(() => { tg.close(); }, 500);
  }

  function haptic(style) { 
      if (tg?.HapticFeedback) {
         if(style==='selection') tg.HapticFeedback.selectionChanged();
         else if(style==='success'||style==='error') tg.HapticFeedback.notificationOccurred(style);
         else tg.HapticFeedback.impactOccurred(style);
      }
  }

  // Torch
  let torchOn = false;
  document.getElementById('btnTorch').onclick = async () => {
    if(!state.track) return;
    torchOn = !torchOn;
    try { await state.track.applyConstraints({ advanced: [{ torch: torchOn }] }); } catch(e){}
    haptic('light');
  };

  document.getElementById('btnClose').onclick = () => window.history.back();

  // START
  initCamera();

</script>
</body>
</html>
