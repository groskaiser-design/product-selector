<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="tma:home-url" content="./index.html" />
<meta name="tma:home-hash" content="" />
<title>Замеры — анкета</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  /* === BLOCK A: DESIGN / UI (без изменений в вашей вёрстке) === */
  :root{
    --bg: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    --cardA: rgba(255,255,255,.18);
    --cardB: rgba(255,255,255,.16);
    --border: rgba(255,255,255,.28);
    --shadow: 0 8px 28px rgba(0,0,0,.18);
    --okA:#fbbf24; --okB:#f59e0b;
    --row: 36px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  html{background:transparent;}
  body{
    min-height:100svh;
    background:transparent;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
    color:#fff;
    position:relative;
    isolation:isolate;
  }
  body::before{content:"";position:fixed;inset:0;background:var(--bg);z-index:0;pointer-events:none;transform:translateZ(0);}
  .page{max-width:560px;margin:0 auto;padding:18px 14px 24px;position:relative;z-index:1}

  .section{background:linear-gradient(180deg,var(--cardA),var(--cardB));border:1px solid var(--border);border-radius:18px;box-shadow:var(--shadow);backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);overflow:hidden;margin-bottom:14px;}
  .section-h{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer;user-select:none}
  .section-h h2{font-size:16px;font-weight:800;flex:1}
  .meta{font-size:11px;opacity:.9}
  .toggle{width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:.9}
  .toggle svg{transition:transform .18s ease}
  .section.collapsed .toggle svg{transform:rotate(-90deg)}
  .section-content{padding:0}
  .section.collapsed .section-content{display:none}

  .field{padding:12px}
  .field + .field{border-top:1px solid rgba(255,255,255,.14)}
  .row{display:flex;align-items:center;justify-content:space-between}
  .label{font-size:13px;font-weight:800}
  .unit{font-size:12px;opacity:.9}
  .help{margin-top:6px;text-align:center;font-size:12px;opacity:.8}

  .duo{position:relative;display:flex;gap:6px;padding:12px;border-radius:14px;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.24);max-width:320px;margin:8px auto 0;justify-content:center;}
  .duo::after{content:"";position:absolute;left:4px;right:4px;top:50%;height:var(--row);transform:translateY(-50%);background:rgba(255,255,255,.14);border:1px solid rgba(255,255,255,.35);border-radius:10px;pointer-events:none;}
  .col{flex:0 0 92px;height:180px;overflow:auto;-webkit-overflow-scrolling:touch;overscroll-behavior: contain;scrollbar-width:none;scroll-snap-type:y mandatory;mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);-webkit-mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);}
  .col::-webkit-scrollbar{display:none}
  .option{height:var(--row);display:flex;align-items:center;justify-content:center;font-weight:900;font-size:18px;color:#eef2ff;opacity:.55;scroll-snap-align:center;}
  .option.active{color:#fff;opacity:1;text-shadow:0 1px 0 rgba(0,0,0,.2);}
  .sep{display:flex;align-items:center;justify-content:center;width:10px;color:#e5e7eb;font-weight:800}
  .optline{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:8px}
  .optline input{width:18px;height:18px}

  .savebar{display:flex;justify-content:center;padding:12px;border-top:1px solid rgba(255,255,255,.14);padding-bottom: calc(12px + env(safe-area-inset-bottom));}
  .btn{min-width:160px;padding:12px 16px;border:0;border-radius:14px;background:linear-gradient(135deg,var(--okA),var(--okB));color:#fff;font-weight:900;box-shadow:var(--shadow);transition: transform .08s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;-webkit-tap-highlight-color:transparent;touch-action: manipulation;display:inline-flex;align-items:center;justify-content:center;gap:10px;}
  .btn:focus-visible{outline:2px solid rgba(255,255,255,.7);outline-offset:2px;border-radius:16px}
  @media (prefers-reduced-motion: reduce){ .btn{transition:none;} }
  .btn.pressed{transform:translateY(1px) scale(.98);box-shadow:var(--shadow);filter:saturate(.95);}
  .btn.loading{opacity:.9;pointer-events:none;}
  .spinner{width:16px;height:16px;border:2px solid rgba(255,255,255,.55);border-top-color:#fff;border-radius:50%;animation:spin .8s linear infinite;}
  @keyframes spin{to{transform:rotate(360deg);}}
  .disabled{opacity:.4;filter:saturate(.6)}

  #ai-comment .field h4{margin:8px 0 6px;font-weight:900;}
  #ai-comment .field h3{margin:10px 0 6px;font-weight:900;}
  #ai-comment .field p{margin:8px 0;}
  #ai-comment .field ul,#ai-comment .field ol{margin:8px 0 8px 18px;}
  #ai-comment .field li{margin:4px 0;}
  #ai-comment .field hr{border:0;border-top:1px solid rgba(255,255,255,.22);margin:10px 0;}
  #ai-comment .field a{color:#fff;text-decoration:underline;}
</style>
</head>
<body>
  <div class="page">

    <section class="section collapsed" id="sec-measures">
      <div class="section-h" data-toggle="sec-measures" role="button" tabindex="0" aria-controls="sec-measures" aria-expanded="false">
        <h2>Замеры</h2>
        <div class="meta" id="lastTime">Последний замер: нет данных</div>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
      </div>
      <div class="section-content">
        <div id="fields"></div>
        <div class="savebar">
          <button class="btn" id="saveBtn" aria-busy="false">
            <span class="btn-label">Сохранить</span>
            <span class="spinner" aria-hidden="true" hidden></span>
          </button>
        </div>
      </div>
    </section>

    <section class="section" id="sec-analytics">
      <div class="section-h" data-toggle="sec-analytics" role="button" tabindex="0" aria-controls="sec-analytics" aria-expanded="true">
        <h2>Аналитика</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
      </div>
      <div class="section-content" id="analytics">
        <div class="field"><div class="help">После сохранения появятся графики.</div></div>
      </div>
    </section>

    <section class="section" id="sec-ai">
      <div class="section-h" data-toggle="sec-ai" role="button" tabindex="0" aria-controls="sec-ai" aria-expanded="true">
        <h2>Комментарий</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        </div>
      </div>
      <div class="section-content" id="ai-comment">
        <div class="field"><div class="help">Подключите бэкенд — здесь будет текст.</div></div>
      </div>
    </section>

  </div>

<script>
/* ============================================================
 *  BLOCK 0: TMA boot (цвета/назад)
 * ============================================================ */
(function initTMA(){
  const tg = window.Telegram?.WebApp;
  if (!tg) return;
  try { tg.ready(); tg.expand(); tg.setHeaderColor('secondary_bg_color'); } catch(e){}
  try {
    tg.BackButton?.offClick?.();
    tg.BackButton?.show();
    tg.BackButton?.onClick(()=>{ try{ window.location.href='router.html'; }catch(_){} });
  } catch(e){}
})();

/* ============================================================
 *  BLOCK A: Общие утилиты UI
 * ============================================================ */
const ROW_VAR = getComputedStyle(document.documentElement).getPropertyValue('--row').trim();
const rowH = ROW_VAR.endsWith('px') ? parseFloat(ROW_VAR) : (parseFloat(ROW_VAR) || 36);
const pad = 4;
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));

/* ============================================================
 *  BLOCK A1: Компонент "колёса"
 * ============================================================ */
function buildWheel(fieldEl, initial){
  const min = +fieldEl.dataset.min;
  const max = +fieldEl.dataset.max;
  const minInt = Math.floor(min);
  const maxInt = Math.floor(max);
  const intRange = maxInt - minInt;

  const intCol = fieldEl.querySelector('.col-int');
  const fracCol = fieldEl.querySelector('.col-frac');
  const duo = fieldEl.querySelector('.duo');
  const key = fieldEl.dataset.key;

  const opt = t => { const d=document.createElement('div'); d.className='option'; d.textContent=t; return d; };
  function fillCol(col, from, to){
    const frag=document.createDocumentFragment();
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    for(let i=from;i<=to;i++) frag.appendChild(opt(i));
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    col.innerHTML=''; col.appendChild(frag);
  }
  fillCol(intCol, minInt, maxInt);
  fillCol(fracCol, 0, 9);

  const nearestIndex = col =>
    Math.round((col.scrollTop + (col.clientHeight-rowH)/2)/rowH) - pad;

  const lastActiveIdx = new WeakMap();
  function markActive(col){
    const idx = nearestIndex(col) + pad;
    const prev = lastActiveIdx.get(col);
    if (typeof prev === 'number' && col.children[prev]) col.children[prev].classList.remove('active');
    const el = col.children[idx];
    if (el) el.classList.add('active');
    lastActiveIdx.set(col, idx);
  }

  const setScrollInstant = (col, idx) => {
    const top = (idx + pad) * rowH - (col.clientHeight-rowH)/2;
    col.scrollTop = top;
  };

  function withNoSnap(fn){
    const prevInt = intCol.style.scrollSnapType;
    const prevFrac = fracCol.style.scrollSnapType;
    intCol.style.scrollSnapType = 'none';
    fracCol.style.scrollSnapType = 'none';
    try { fn(); }
    finally {
      requestAnimationFrame(()=>{
        intCol.style.scrollSnapType = prevInt || '';
        fracCol.style.scrollSnapType = prevFrac || '';
        markActive(intCol); markActive(fracCol);
      });
    }
  }

  let isProgrammatic = false;
  let rafInt = 0, rafFrac = 0;
  let snapTimer=null;
  const supportsScrollEnd = 'onscrollend' in window;
  let disabled = false;

  function applyFracLock(iVal){
    if (disabled) return;
    const lock = (iVal === maxInt);
    fracCol.style.pointerEvents = lock ? 'none' : 'auto';
    fracCol.style.opacity = lock ? 0.5 : 1;
  }

  function dispatchChange(){
    const v = api.value;
    document.dispatchEvent(new CustomEvent('wheelchange', {
      detail:{ key, value: v, programmatic: isProgrammatic }
    }));
  }

  function setValue(v){
    const clamped = clamp(+v, min, max);
    const rounded = Math.round(clamped * 10) / 10;
    const iVal = Math.trunc(rounded);
    let f = Math.round((rounded - iVal) * 10);
    if (iVal === maxInt) f = 0;
    const iIdx = iVal - minInt;

    const prev = isProgrammatic; isProgrammatic = true;
    withNoSnap(()=>{
      setScrollInstant(intCol, iIdx);
      setScrollInstant(fracCol, f);
    });
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = prev; dispatchChange(); });
  }

  function snapNow(){
    if (isProgrammatic) return;
    let iIdx = clamp(nearestIndex(intCol), 0, intRange);
    let f = clamp(nearestIndex(fracCol), 0, 9);
    const iVal = minInt + iIdx;
    if (iVal === maxInt) f = 0;

    const prev = isProgrammatic; isProgrammatic = true;
    setScrollInstant(intCol, iIdx);
    setScrollInstant(fracCol, f);
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = prev; dispatchChange(); });
  }

  function onScrollInt(){
    if (isProgrammatic) return;
    if (rafInt) cancelAnimationFrame(rafInt);
    rafInt = requestAnimationFrame(()=>markActive(intCol));
    scheduleSnap();
  }
  function onScrollFrac(){
    if (isProgrammatic) return;
    if (rafFrac) cancelAnimationFrame(rafFrac);
    rafFrac = requestAnimationFrame(()=>markActive(fracCol));
    scheduleSnap();
  }
  function scheduleSnap(){
    if (supportsScrollEnd) return;
    clearTimeout(snapTimer);
    snapTimer = setTimeout(snapNow, 80);
  }

  intCol.addEventListener('scroll', onScrollInt, {passive:true});
  fracCol.addEventListener('scroll', onScrollFrac, {passive:true});
  if (supportsScrollEnd){
    intCol.addEventListener('scrollend', snapNow, {passive:true});
    fracCol.addEventListener('scrollend', snapNow, {passive:true});
  }

  function setDisabled(dis, programmatic=false){
    const prev = isProgrammatic; if (programmatic) isProgrammatic = true;
    disabled = dis;
    duo.classList.toggle('disabled', dis);
    duo.setAttribute('aria-disabled', String(dis));
    [intCol, fracCol].forEach(c=>c.style.pointerEvents = dis ? 'none':'auto');
    if (!dis){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      const iVal = minInt + iIdx;
      applyFracLock(iVal);
    }
    dispatchChange();
    isProgrammatic = prev;
  }

  const initVal = (typeof initial==='number') ? initial : (min + (max - min) / 2);
  requestAnimationFrame(()=>requestAnimationFrame(()=>setValue(initVal)));

  const api = {
    setValue,
    get value(){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      let f = clamp(nearestIndex(fracCol), 0, 9);
      const iVal = minInt + iIdx;
      if (iVal === maxInt) f = 0;
      return +(iVal + f/10).toFixed(1);
    },
    setDisabled,
    destroy(){
      clearTimeout(snapTimer);
      intCol.removeEventListener('scroll', onScrollInt);
      fracCol.removeEventListener('scroll', onScrollFrac);
      if (supportsScrollEnd){
        intCol.removeEventListener('scrollend', snapNow);
        fracCol.removeEventListener('scrollend', snapNow);
      }
    }
  };
  return api;
}

/* ============================================================
 *  BLOCK B: Модель данных (конфиг полей + рендер)
 * ============================================================ */
const FIELDS = [
  { key:'weight', label:'Вес', unit:'кг', min:40, max:250, initial:70.0 },
  { key:'height', label:'Рост', unit:'см', min:120, max:230, initial:160.0 },
  { key:'fat',    label:'% жира', unit:'%', min:3,  max:60,  initial:20.0, optional:true },

  { key:'neck',   label:'Шея', unit:'см', min:20, max:70, initial:38 },
  { key:'shoulders',label:'Плечи обхват', unit:'см', min:60, max:180, initial:90.0 },
  { key:'chest',  label:'Грудь', unit:'см', min:60, max:160, initial:100 },
  { key:'waist',  label:'Талия', unit:'см', min:40, max:160, initial:70 },

  { key:'bicep_l_rel', label:'Бицепс левый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_rel', label:'Бицепс правый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_l_flex',label:'Бицепс левый (напряж.)',  unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_flex',label:'Бицепс правый (напряж.)', unit:'см', min:15, max:70, initial:31 },

  { key:'thigh_l', label:'Бедро левое', unit:'см', min:30, max:100, initial:50 },
  { key:'thigh_r', label:'Бедро правое', unit:'см', min:30, max:100, initial:50 },

  { key:'calf_l',  label:'Икра левая', unit:'см', min:25, max:70, initial:35 },
  { key:'calf_r',  label:'Икра правая', unit:'см', min:25, max:70, initial:35 },

  { key:'hips',    label:'Ягодицы', unit:'см', min:70, max:160, initial:90 },
  { key:'wrist',   label:'Обхват запястья', unit:'см', min:10, max:30, initial:17 },
  { key:'knee',    label:'Обхват колена',   unit:'см', min:25, max:60, initial:36 },
  { key:'ankle',   label:'Обхват лодыжки',  unit:'см', min:15, max:35, initial:22 },
];
const CFG = Object.fromEntries(FIELDS.map(f=>[f.key, f]));
const fieldsWrap = document.getElementById('fields');
const wheels = {};
const wheelMap = new WeakMap();
const fieldByKey = Object.create(null);

function ensureWheel(fieldEl, cfg){
  let w = wheelMap.get(fieldEl);
  if (!w){
    const initVal = cfg.initial;
    w = buildWheel(fieldEl, initVal);
    wheelMap.set(fieldEl, w);
    wheels[cfg.key] = w;

    if (cfg.optional){
      let cb = fieldEl.querySelector('#opt_'+cfg.key);
      if (!cb){
        const opt = document.createElement('div');
        opt.className = 'optline';
        opt.innerHTML = `<label style="display:flex;align-items:center;gap:8px;opacity:.95">
            <input type="checkbox" id="opt_${cfg.key}"> нет данных
          </label>`;
        fieldEl.appendChild(opt);
        cb = opt.querySelector('input');
      }
      cb.checked = false;
      if (!cb._bound){
        cb.addEventListener('change', ()=>{ w.setDisabled(cb.checked); }, {passive:true});
        cb._bound = true;
      }
    }
  }
  return w;
}

for (const cfg of FIELDS){
  const f = document.createElement('div');
  f.className = 'field';
  f.dataset.key = cfg.key;
  f.dataset.min = cfg.min;
  f.dataset.max = cfg.max;

  f.innerHTML = `
    <div class="row"><div class="label">${cfg.label}</div><div class="unit">${cfg.unit}</div></div>
    <div class="duo"><div class="col col-int"></div><div class="sep">,</div><div class="col col-frac"></div></div>
  `;
  const h = document.createElement('div');
  h.className = 'help';
  h.textContent = cfg.unit==='кг' ? 'кг: целые и десятые' :
                  cfg.unit==='см' ? 'см: целые и десятые (1 десятая = 1 мм)' :
                  'проценты: целые и десятые';
  f.appendChild(h);

  fieldsWrap.appendChild(f);
  fieldByKey[cfg.key] = f;
}

/* Lazy init колёс — только при раскрытии секции */
const allFields = Array.from(fieldsWrap.querySelectorAll('.field'));
const canObserve = 'IntersectionObserver' in window;
function observeFields(){
  if (!canObserve){
    for (const f of allFields){ ensureWheel(f, CFG[f.dataset.key]); }
    return;
  }
  const io = new IntersectionObserver((entries)=>{
    for (const e of entries){
      if (e.isIntersecting){
        const f = e.target;
        ensureWheel(f, CFG[f.dataset.key]);
        io.unobserve(f);
      }
    }
  }, {root:null, rootMargin:'100px 0px', threshold:0});

  for (const f of allFields){
    const rect = f.getBoundingClientRect();
    if (rect.top < (window.innerHeight + 100) && rect.bottom > -100){
      ensureWheel(f, CFG[f.dataset.key]);
    } else {
      io.observe(f);
    }
  }
}
if (!document.getElementById('sec-measures').classList.contains('collapsed')){
  observeFields(); fieldsWrap._observed = true;
}

  
/* ===========================
 * BLOCK C — SAVE TO DB (Apps Script, no preflight, pure logic)
 * =========================== */

const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbwjvkS5P7IcvTCFRbAb9jflLuD-R2IN3Azhg5_niKywHN3pJLDTBCL4kD2W-eDjKNnJmA/exec';
const APP_VERSION  = 'frontend-2025-10-21';
const REQUEST_TIMEOUT_MS = 15000;

function nowIso(){ return new Date().toISOString(); }
function todayLocalISO(tz){
  try{
    const d = new Date();
    const y  = new Intl.DateTimeFormat('en-CA',{timeZone:tz,year:'numeric'}).format(d);
    const m  = new Intl.DateTimeFormat('en-CA',{timeZone:tz,month:'2-digit'}).format(d);
    const da = new Intl.DateTimeFormat('en-CA',{timeZone:tz,day:'2-digit'}).format(d);
    return `${y}-${m}-${da}`;
  }catch{ return new Date().toISOString().slice(0,10); }
}
function clientTZ(){
  try{ return Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC'; }
  catch{ return 'UTC'; }
}
function genSaveId(){ return Date.now() + '_' + Math.random().toString(36).slice(2,10); }

/**
 * Отправка в Apps Script
 * @param {Object} values — значения крутилок (обязательны)
 * @returns {Promise<{ok:boolean,row_all:number,row_calc:number,day_local:string,ts_iso:string}>}
 */
async function saveMeasurementsToDB(values){
  if (!values || typeof values !== 'object') {
    throw new Error('Нет данных для сохранения.');
  }

  const tg       = window.Telegram?.WebApp;
  const tz       = clientTZ();
  const dayLocal = todayLocalISO(tz);

  const payload = {
    action: 'save',
    init_data: String(tg?.initData || ''),
    tz,
    client_day_local: dayLocal,
    locale: tg?.initDataUnsafe?.user?.language_code || '',
    source: 'webapp',
    app_version: APP_VERSION,
    t_client: nowIso(),
    save_id: genSaveId(),
    data: values
  };

  const controller = new AbortController();
  const t = setTimeout(() => controller.abort(new Error('timeout')), REQUEST_TIMEOUT_MS);

  let resp, raw, json = null;
  try{
    resp = await fetch(BACKEND_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'text/plain;charset=UTF-8' }, // без preflight
      body: JSON.stringify(payload),
      redirect: 'follow',
      cache: 'no-store',
      credentials: 'omit',
      mode: 'cors',
      signal: controller.signal
    });
    raw = await resp.text();
    try { json = raw ? JSON.parse(raw) : null; } catch {}
  } finally {
    clearTimeout(t);
  }

  // --- расширенный детект лимита ---
  const isRateLimited =
    resp?.status === 429 ||
    (json && (json.code === 429 || json.status === 429)) ||
    /(?:too\s*many\s*requests|rate[-_\s]*limit|429|слишком\s+часто)/i.test(
      String(json?.error || raw || resp?.statusText || '')
    );

  if (!resp?.ok || !json || json.ok !== true) {
    const msg = (json && json.error) ? json.error : `HTTP ${resp?.status ?? '0'} ${resp?.statusText ?? ''}`.trim();
    if (isRateLimited) { const e = new Error('Too many requests'); e.code = 429; throw e; }
    if (msg === 'timeout' || /timeout|network/i.test(String(msg))) { const e = new Error('Сервер не ответил вовремя'); e.code = 408; throw e; }
    const e = new Error(msg || 'Save failed'); e.code = resp?.status ?? 0; throw e;
  }

  return {
    ok: true,
    day_local: json.day_local,
    ts_iso:    json.ts_iso,
    row_all:   Number(json.row_all),
    row_calc:  Number(json.row_calc)
  };
}

/* ============================================================
 * BLOCK D — один хендлер «Сохранить», ЖЁСТКИЙ кулдаун 10с,
 * попап при частых кликах, без disabled, с вибро,
 * работает даже с оверлеями (хит-тест), схлоп аккордеона.
 * ============================================================ */

var savingInFlight = false;

/* --- кулдаун: следующее разрешённое нажатие не раньше __unlockAt --- */
var COOLDOWN_MS = 10000;
var __unlockAt = 0; // timestamp (ms), когда снова можно сохранять

/* --- per-user memory for row_calc --- */
var ROWCALC_KEY_PREFIX = 'macros:last_row_calc:';
function currentUserId(){ 
  try { return (window.Telegram && window.Telegram.WebApp && window.Telegram.WebApp.initDataUnsafe && window.Telegram.WebApp.initDataUnsafe.user && window.Telegram.WebApp.initDataUnsafe.user.id) || 'anon'; }
  catch(e){ return 'anon'; }
}
function rowCalcKey(uid){ return ROWCALC_KEY_PREFIX + String(uid); }
function setRowCalcForUser(rowCalc, uid){
  if (typeof uid === 'undefined') uid = currentUserId();
  try { localStorage.setItem(rowCalcKey(uid), String(rowCalc)); }
  catch(e) { try { sessionStorage.setItem(rowCalcKey(uid), String(rowCalc)); } catch(e2){} }
  if (!window.__rowCalcByUid) window.__rowCalcByUid = {};
  window.__rowCalcByUid[String(uid)] = Number(rowCalc);
}
function getRowCalcForUser(uid){
  if (typeof uid === 'undefined') uid = currentUserId();
  if (window.__rowCalcByUid && (String(uid) in window.__rowCalcByUid)) return window.__rowCalcByUid[String(uid)];
  var v = null; try { v = localStorage.getItem(rowCalcKey(uid)); } catch(e) { try { v = sessionStorage.getItem(rowCalcKey(uid)); } catch(e2){} }
  var n = (v == null) ? null : Number(v);
  if (!window.__rowCalcByUid) window.__rowCalcByUid = {};
  window.__rowCalcByUid[String(uid)] = isNaN(n) ? null : n;
  return window.__rowCalcByUid[String(uid)];
}
window.getRowCalcForUser = getRowCalcForUser;
window.setRowCalcForUser = setRowCalcForUser;

/* --- кнопка --- */
var SAVE_BTN_SELECTOR = '#saveBtn';
function getSaveBtn(){ return document.getElementById('saveBtn'); }

function setSavingState(isSaving){
  var btn = getSaveBtn(); if (!btn) return;
  var label = btn.querySelector('.btn-label');
  var sp    = btn.querySelector('.spinner');

  // ВАЖНО: не используем disabled и не даём стилям вырубить события
  if (isSaving) { btn.classList.add('loading'); } else { btn.classList.remove('loading'); }
  try { btn.style.setProperty('pointer-events', 'auto', 'important'); } catch(e){}
  btn.setAttribute('aria-busy', String(isSaving));
  btn.setAttribute('data-saving', String(isSaving));
  if (sp)    sp.hidden = !isSaving;
  if (label) label.textContent = isSaving ? 'Обработка…' : 'Сохранить';
}

/* --- popup helper + вибро --- */
async function showPopupSafe(title, message, haptic){
  try {
    var tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
    if (haptic && tg && tg.HapticFeedback && tg.HapticFeedback.notificationOccurred) {
      // 'success' | 'warning' | 'error'
      tg.HapticFeedback.notificationOccurred(haptic);
    }
    if (!(tg && tg.showPopup)){ alert(title + '\n\n' + message); return; }
    if (window.__popupOpen) return;
    window.__popupOpen = true;
    try{
      await new Promise(function(resolve){
        var onClose = function(){ try{tg.offEvent('popup_closed', onClose);}catch(e){} window.__popupOpen=false; resolve(); };
        try{ tg.onEvent('popup_closed', onClose); }catch(e){}
        tg.showPopup({ title:title, message:message, buttons:[{type:'ok'}] });
      });
    }finally{ window.__popupOpen = false; }
  } catch(e) {
    try { alert(title + '\n\n' + message); } catch(_) {}
  }
}

/* --- схлоп аккордеона --- */
function collapseAccordionSafe(){
  var act = function(){
    if (typeof window.collapseMeasures === 'function') { try{ window.collapseMeasures(); return; }catch(e){} }
    var list1 = document.querySelectorAll('details[open]#sec-measures, details[open][data-section="measures"], #sec-measures details[open]');
    Array.prototype.forEach.call(list1, function(d){ d.open = false; });
    var list2 = document.querySelectorAll('#sec-measures .collapse.show, [data-section="measures"] .collapse.show, .accordion .collapse.show');
    Array.prototype.forEach.call(list2, function(p){ p.classList.remove('show'); p.style.height=''; p.setAttribute('aria-hidden','true'); });
    var list3 = document.querySelectorAll('[data-bs-toggle="collapse"][aria-expanded="true"], [aria-controls="sec-measures"][aria-expanded="true"]');
    Array.prototype.forEach.call(list3, function(t){ t.setAttribute('aria-expanded','false'); try{ t.dispatchEvent(new Event('click',{bubbles:true})); }catch(e){} });
    var section = document.getElementById('sec-measures') || document.querySelector('[data-section="measures"]');
    if (section){ section.classList.add('collapsed'); section.setAttribute('aria-hidden','true'); }
  };
  try { requestAnimationFrame(function(){ requestAnimationFrame(act); }); } catch(e) { act(); }
}

/* --- сбор значений --- */
function collectWheelValues(){
  if (typeof window._collectWheelValues === 'function') return window._collectWheelValues();
  var out = {};
  for (var i=0; i<FIELDS.length; i++){
    var cfg = FIELDS[i];
    var fieldEl = fieldByKey[cfg.key];
    var w  = (wheels[cfg.key] || ensureWheel(fieldEl, cfg));
    var cb = fieldEl ? fieldEl.querySelector('#opt_' + cfg.key) : null;
    out[cfg.key] = (cfg.optional && cb && cb.checked) ? null : w.value;
  }
  return out;
}

/* --- утилиты гейта: определяем, что пользователь действительно тыкнул по кнопке --- */
function _pointFromEvent(e){
  try{
    if (e && e.touches && e.touches[0]) return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    if (e && e.changedTouches && e.changedTouches[0]) return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    return { x: e.clientX, y: e.clientY };
  }catch(ex){ return null; }
}
function _isEventOnSave(e){
  var btn = getSaveBtn(); if (!btn) return false;
  if (e && e.target && e.target.closest) {
    try { if (e.target.closest(SAVE_BTN_SELECTOR)) return true; } catch(ex){}
  }
  // хит-тест по координатам (если сверху оверлей)
  var p = _pointFromEvent(e); if (!p) return false;
  var r = btn.getBoundingClientRect(); if (!r) return false;
  return (p.x >= r.left && p.x <= r.right && p.y >= r.top && p.y <= r.bottom);
}

/* --- делегация + CAPTURE-гейт: показываем попап ВСЕГДА внутри 10с и во время сохранения --- */
(function bindSaveDelegation(){
  if (window.__saveDelegationInstalled) return; 
  window.__saveDelegationInstalled = true;

  function gate(e){
    if (!_isEventOnSave(e)) return;
    var now = Date.now();
    if (savingInFlight || (now < __unlockAt)){
      // мгновенный попап + вибро «error», блокируем событие
      try { e.preventDefault(); } catch(ex){}
      try { if (e.stopImmediatePropagation) e.stopImmediatePropagation(); else if (e.stopPropagation) e.stopPropagation(); } catch(ex){}
      // без await, чтобы быть в синхронном жесте пользователя
      showPopupSafe('Слишком часто', 'Не чаще одного раза в 10 секунд.', 'error');
    }
  }

  // Ставим capture-слушатели максимально рано (и на window, и на document)
  ['pointerdown','touchstart','mousedown','click'].forEach(function(ev){
    try { window.addEventListener(ev, gate, true); } catch(ex){}
    try { document.addEventListener(ev, gate, true); } catch(ex2){}
  });

  // Основной «клик» запуска сохранения (пузыри)
  document.addEventListener('click', function(e){
    if (!_isEventOnSave(e)) return;
    onSaveClick(e);
  });
})();

async function onSaveClick(e){
  if (e && e.preventDefault) try{ e.preventDefault(); }catch(ex){}
  var tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
  var now = Date.now();

  // дубль-проверка на всякий случай
  if (savingInFlight || (now < __unlockAt)){
    showPopupSafe('Слишком часто', 'Не чаще одного раза в 10 секунд.', 'error');
    return;
  }

  // старт: ставим окно кулдауна НА ВПЕРЁД
  __unlockAt = now + COOLDOWN_MS;
  savingInFlight = true;
  setSavingState(true);
  try { if (tg && tg.HapticFeedback && tg.HapticFeedback.impactOccurred) tg.HapticFeedback.impactOccurred('light'); } catch(_){}

  try{
    var values = collectWheelValues();
    var res    = await saveMeasurementsToDB(values);
    setRowCalcForUser(res.row_calc);

    setSavingState(false);
    collapseAccordionSafe();

    try { if (tg && tg.HapticFeedback && tg.HapticFeedback.notificationOccurred) tg.HapticFeedback.notificationOccurred('success'); } catch(_){}
    await showPopupSafe('Готово', 'Данные сохранены.');
  }catch(err){
    setSavingState(false);
    var msg = String((err && err.message) || err || '');
    if ((err && err.code === 429) || /too\s*many\s*requests|rate[-_\s]*limit|слишком\s+часто|429/i.test(msg)){
      // правило одно: 10с; просто сигналим
      showPopupSafe('Слишком часто', 'Не чаще одного раза в 10 секунд.', 'error');
    } else if ((err && err.code === 408) || /timeout/i.test(msg)) {
      showPopupSafe('Не сохранено', 'Сервер не ответил вовремя. Повторите позже.', 'error');
      // при таймауте кулдаун уже выставлен — оставляем как есть
    } else {
      showPopupSafe('Не сохранено', 'Произошла ошибка при сохранении.', 'error');
    }
  } finally {
    savingInFlight = false;
  }
}
  

/* ============================================================
 *  BLOCK E: Аккордеон
 * ============================================================ */
function setAriaExpanded(h){
  const sec = document.getElementById(h.getAttribute('data-toggle'));
  h.setAttribute('aria-expanded', String(!sec.classList.contains('collapsed')));
}
function toggleSectionByHeader(h){
  const id = h.getAttribute('data-toggle');
  const sec = document.getElementById(id);
  const willBeCollapsed = sec.classList.toggle('collapsed');
  h.setAttribute('aria-expanded', String(!willBeCollapsed));
  if (id === 'sec-measures' && !willBeCollapsed){
    if (typeof fieldsWrap !== 'undefined' && !fieldsWrap._observed){
      observeFields();
      fieldsWrap._observed = true;
    }
  }
}
(function bindAccordion(){
  const root = document;
  root.addEventListener('click', (e)=>{
    const h = e.target.closest ? e.target.closest('.section-h') : null;
    if (!h) return;
    if (!h.hasAttribute('role')) h.setAttribute('role','button');
    if (!h.hasAttribute('tabindex')) h.setAttribute('tabindex','0');
    if (!h.hasAttribute('aria-controls')) h.setAttribute('aria-controls', h.getAttribute('data-toggle'));
    toggleSectionByHeader(h);
  }, {passive:true});
  root.addEventListener('keydown', (e)=>{
    const h = e.target && e.target.closest ? e.target.closest('.section-h') : null;
    if (!h) return;
    if (e.key==='Enter' || e.key===' '){ e.preventDefault(); toggleSectionByHeader(h); }
  });
  document.querySelectorAll('.section-h').forEach(setAriaExpanded);
})();
</script>
</body>
</html>
