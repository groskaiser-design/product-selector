<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="tma:home-url" content="./index.html" />
<meta name="tma:home-hash" content="" />
<title>Замеры — анкета</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root{
    --bg: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    --cardA: rgba(255,255,255,.18);
    --cardB: rgba(255,255,255,.16);
    --border: rgba(255,255,255,.28);
    --shadow: 0 8px 28px rgba(0,0,0,.18);
    --okA:#34d399; --okB:#10b981;
    --row: 36px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}
  html{background:transparent;}
  body{
    min-height:100svh;
    background:transparent;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
    color:#fff;
    position:relative;
    isolation:isolate;
  }
  body::before{
    content:"";
    position:fixed; inset:0;
    background:var(--bg);
    z-index:0;
    pointer-events:none;
    transform:translateZ(0);
  }
  .page{max-width:560px;margin:0 auto;padding:18px 14px 24px;position:relative;z-index:1}

  .section{
    background:linear-gradient(180deg,var(--cardA),var(--cardB));
    border:1px solid var(--border); border-radius:18px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    overflow:hidden; margin-bottom:14px;
  }
  .section-h{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer;user-select:none}
  .section-h h2{font-size:16px;font-weight:800;flex:1}
  .meta{font-size:11px;opacity:.9}
  .toggle{width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:.9}
  .toggle svg{transition:transform .18s ease}
  .section.collapsed .toggle svg{transform:rotate(-90deg)}
  .section-content{padding:0 0 0}
  .section.collapsed .section-content{display:none}

  .field{padding:12px}
  .field + .field{border-top:1px solid rgba(255,255,255,.14)}
  .row{display:flex;align-items:center;justify-content:space-between}
  .label{font-size:13px;font-weight:800}
  .unit{font-size:12px;opacity:.9}
  .help{margin-top:6px;text-align:center;font-size:12px;opacity:.8}

  /* ===== duo-wheel ===== */
  .duo{
    position:relative; display:flex; gap:6px; padding:12px;
    border-radius:14px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.24);
    max-width:320px; margin:8px auto 0; justify-content:center;
  }
  .duo::after{
    content:""; position:absolute; left:4px; right:4px; top:50%;
    height:var(--row); transform:translateY(-50%);
    background:rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.35);
    border-radius:10px; pointer-events:none;
  }
  .col{
    flex:0 0 92px; height:180px; overflow:auto; -webkit-overflow-scrolling:touch;
    overscroll-behavior: contain; scrollbar-width:none; scroll-snap-type:y mandatory;
    mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);
    -webkit-mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);
  }
  .col::-webkit-scrollbar{display:none}
  .option{
    height:var(--row); display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:18px; color:#eef2ff; opacity:.55; scroll-snap-align:center;
  }
  .option.active{ color:#fff; opacity:1; text-shadow:0 1px 0 rgba(0,0,0,.2); }
  .sep{display:flex;align-items:center;justify-content:center;width:10px;color:#e5e7eb;font-weight:800}
  .optline{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:8px}
  .optline input{width:18px;height:18px}

  /* Кнопка сохранения + лоадер */
  .savebar{
    display:flex;justify-content:center;padding:12px;
    border-top:1px solid rgba(255,255,255,.14);
    padding-bottom: calc(12px + env(safe-area-inset-bottom));
  }
  .btn{
    min-width:160px;padding:12px 16px;border:0;border-radius:14px;
    background:#ED2F62; color:#fff;font-weight:900;
    box-shadow:0 12px 26px rgba(237,47,98,.35), inset 0 1px 0 rgba(255,255,255,.4);
    transition: transform .08s ease, box-shadow .12s ease, filter .12s ease, opacity .12s ease;
    -webkit-tap-highlight-color:transparent;
    touch-action: manipulation;
    display:inline-flex; align-items:center; justify-content:center; gap:10px;
  }
  .btn:focus-visible{outline:2px solid rgba(255,255,255,.7); outline-offset:2px; border-radius:16px}
  @media (prefers-reduced-motion: reduce){ .btn{ transition:none; } }
  .btn.pressed{
    transform:translateY(1px) scale(.98);
    box-shadow:0 6px 16px rgba(237,47,98,.35), inset 0 1px 0 rgba(255,255,255,.4);
    filter:saturate(.95);
  }
  .btn.loading{ opacity:.9; pointer-events:none; }
  .spinner{
    width:16px;height:16px;border:2px solid rgba(255,255,255,.55);
    border-top-color:#fff;border-radius:50%;
    animation:spin .8s linear infinite;
  }
  @keyframes spin{ to{ transform:rotate(360deg); } }

  .disabled{opacity:.4;filter:saturate(.6)}

  /* === оформление HTML внутри "Комментарий ИИ" === */
  #ai-comment .field h4{ margin:8px 0 6px; font-weight:900; }
  #ai-comment .field h3{ margin:10px 0 6px; font-weight:900; }
  #ai-comment .field p{ margin:8px 0; }
  #ai-comment .field ul,
  #ai-comment .field ol{ margin:8px 0 8px 18px; }
  #ai-comment .field li{ margin:4px 0; }
  #ai-comment .field hr{
    border:0; border-top:1px solid rgba(255,255,255,.22);
    margin:10px 0;
  }
  #ai-comment .field a{ color:#fff; text-decoration:underline; }
</style>
</head>
<body>
  <div class="page">

    <!-- Блок 1: Замеры (по умолчанию свернут) -->
    <section class="section collapsed" id="sec-measures">
      <div class="section-h" data-toggle="sec-measures" role="button" tabindex="0" aria-controls="sec-measures" aria-expanded="false">
        <h2>Замеры</h2>
        <div class="meta" id="lastTime">Последний замер: нет данных</div>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content">
        <div id="fields"></div>
        <div class="savebar">
          <button class="btn" id="saveBtn" aria-busy="false">
            <span class="btn-label">Сохранить</span>
            <span class="spinner" aria-hidden="true" hidden></span>
          </button>
        </div>
      </div>
    </section>

    <!-- Блок 2: Аналитика (развернут) -->
    <section class="section" id="sec-analytics">
      <div class="section-h" data-toggle="sec-analytics" role="button" tabindex="0" aria-controls="sec-analytics" aria-expanded="true">
        <h2>Аналитика</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content" id="analytics">
        <div class="field">
          <div class="help">Здесь появится динамика по ключевым метрикам после сохранения хотя бы двух замеров.</div>
        </div>
      </div>
    </section>

    <!-- Блок 3: Комментарий ИИ (развернут) -->
    <section class="section" id="sec-ai">
      <div class="section-h" data-toggle="sec-ai" role="button" tabindex="0" aria-controls="sec-ai" aria-expanded="true">
        <h2>Комментарий ИИ</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content" id="ai-comment">
        <div class="field">
          <div class="help">Здесь будет краткий разбор изменений и рекомендации на основе последних замеров.</div>
        </div>
      </div>
    </section>

  </div>

<script>
/* ===== Telegram Mini App boot ===== */
(function initTMA(){
  const tg = window.Telegram?.WebApp;
  if (!tg) return;
  try { tg.ready(); } catch(e){}
  try { tg.expand(); } catch(e){}
  try { tg.setHeaderColor('secondary_bg_color'); } catch(e){}
  try { bindBack(); } catch(e){} // системная «Назад»
})();

/* ===== Back button binding (router.html) ===== */
function bindBack(){
  const tg = window.Telegram?.WebApp;
  if (!tg) return;
  try { tg.BackButton?.offClick?.(); } catch(e){}
  try {
    tg.BackButton?.show();
    tg.BackButton?.onClick(() => {
      try { window.location.href = 'router.html'; }
      catch(err){ console.error('[BackButton] navigation error:', err); }
    });
  } catch(e){ console.error('[BackButton] bind error:', e); }
}

/* ===== КОНСТАНТЫ ХРАНИЛИЩА ===== */
const LS_KEY_LAST  = 'measurements:last';
const SS_KEY_DRAFT = 'measurements:sessionDraft';
const LS_KEY_AI    = 'measurements:ai:last';
const LS_LAST_META = 'measurements:last_meta';
const LS_SENT_IIDS = 'measurements:sent_iids';
const SENT_IIDS_LIMIT = 100;
const SAVE_THROTTLE_MS = 600;

/* ===== СЕТЬ / БЭКЕНД ===== */
const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbzi5b6W_RbJF_t9ojiZoBR2ndeqWhs3v9xbpSVhweYXUGB8EXa3qyzzayU0GxBiq-782A/exec';
const APP_VERSION = '1.0.10';
const AI_API_URL  = BACKEND_URL;

/* авто-пуллинг ИИ-комментария */
const AI_REFRESH_MS = 60000;
let aiPollTimer = null;
function startAIPoll(){ stopAIPoll(); aiPollTimer = setInterval(()=>fetchAIComment({silent:true}), AI_REFRESH_MS); }
function stopAIPoll(){ if (aiPollTimer){ clearInterval(aiPollTimer); aiPollTimer = null; } }

/* ===== Главная страница (мета-теги) ===== */
const HOME_URL = (document.querySelector('meta[name="tma:home-url"]')?.content) || './index.html';
const HOME_HASH = (document.querySelector('meta[name="tma:home-hash"]')?.content) || '';

/* ===== УТИЛИТЫ ===== */
const ROW_VAR = getComputedStyle(document.documentElement).getPropertyValue('--row').trim();
const rowH = ROW_VAR.endsWith('px') ? parseFloat(ROW_VAR) : (parseFloat(ROW_VAR) || 36);
const pad = 4;
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
const DTF = new Intl.DateTimeFormat('ru-RU', { day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit' });
const fmt = ts => (!ts ? 'нет данных' : DTF.format(new Date(ts)));

function readJSON(key, fallback=null){ try{ const v=localStorage.getItem(key); return v?JSON.parse(v):fallback; }catch(e){ return fallback; } }
function writeJSON(key,obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){} }
function readSessionJSON(key,fallback=null){ try{ const v=sessionStorage.getItem(key); return v?JSON.parse(v):fallback; }catch(e){ return fallback; } }
function writeSessionJSON(key,obj){ try{ sessionStorage.setItem(key, JSON.stringify(obj)); }catch(e){} }
function removeSessionKey(key){ try{ sessionStorage.removeItem(key); }catch(e){} }
function safeInitData(){ return window.Telegram?.WebApp?.initData || ''; }

function stableStringify(obj){
  const seen = new WeakSet();
  const sortKeys = (x) => {
    if (x && typeof x === 'object') {
      if (seen.has(x)) return null;
      seen.add(x);
      if (Array.isArray(x)) return x.map(sortKeys);
      return Object.keys(x).sort().reduce((acc,k)=>(acc[k]=sortKeys(x[k]),acc),{});
    }
    return x;
  };
  return JSON.stringify(sortKeys(obj));
}
function hash32(str){ let h=0x811c9dc5; for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h=(h+((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)))>>>0; } return ('00000000'+h.toString(16)).slice(-8); }
function readJSONLS(k,f){ return readJSON(k,f); }
function writeJSONLS(k,v){ writeJSON(k,v); }
function rememberIID(iid){ const m=readJSONLS(LS_SENT_IIDS,{}); m[iid]=Date.now(); const e=Object.entries(m).sort((a,b)=>b[1]-a[1]).slice(0,SENT_IIDS_LIMIT); writeJSONLS(LS_SENT_IIDS,Object.fromEntries(e)); }
function wasIIDSent(iid){ const m=readJSONLS(LS_SENT_IIDS,{}); return Boolean(m[iid]); }
function getLastMeta(){ return readJSONLS(LS_LAST_META,null); }
function setLastMeta(meta){ writeJSONLS(LS_LAST_META,meta); }

function debounce(fn, ms=120){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

/* ===== HTML SANITIZER ===== */
const ALLOWED_TAGS = new Set(['h3','h4','p','br','ul','ol','li','b','strong','i','em','u','s','hr','blockquote','code','pre','a']);
const SAFE_URL_RE  = /^(https?:\/\/|mailto:)/i;
function sanitizeHtml(input){
  if (!input || typeof input !== 'string') return '';
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${input}</div>`, 'text/html');
  const root = doc.body.firstElementChild;
  function clean(node){
    if (node.nodeType === Node.TEXT_NODE) return node.cloneNode(true);
    if (node.nodeType === Node.ELEMENT_NODE){
      const tag=node.tagName.toLowerCase();
      if (!ALLOWED_TAGS.has(tag)){
        const frag=doc.createDocumentFragment(); node.childNodes.forEach(ch=>frag.appendChild(clean(ch))); return frag;
      }
      const el=doc.createElement(tag);
      if (tag==='a'){
        const href=node.getAttribute('href')||''; const title=node.getAttribute('title');
        if (SAFE_URL_RE.test(href)){ el.setAttribute('href',href); if(title) el.setAttribute('title',title); el.setAttribute('target','_blank'); el.setAttribute('rel','noopener noreferrer'); }
      }
      node.childNodes.forEach(ch=>el.appendChild(clean(ch))); return el;
    }
    return doc.createTextNode('');
  }
  const outFrag=doc.createDocumentFragment(); root.childNodes.forEach(ch=>outFrag.appendChild(clean(ch)));
  const tmp=doc.createElement('div'); tmp.appendChild(outFrag); return tmp.innerHTML;
}

/* ===== Навигация домой ===== */
function goHome(){
  if (typeof window.appNavigate==='function'){ try{ window.appNavigate('home'); return; }catch{} }
  if (HOME_HASH && location.hash!==HOME_HASH){ location.hash=HOME_HASH; return; }
  if (HOME_URL){ try{ location.assign(HOME_URL); return; }catch{} }
  try{ window.Telegram?.WebApp?.close(); }catch{}
}

/* ===== Равенство структур данных ===== */
function equalData(a={}, b={}){
  for (const {key} of FIELDS){
    const va=a[key], vb=b[key];
    if (va===null || vb===null){ if (va!==vb) return false; }
    else if (typeof va==='number' && typeof vb==='number'){ if (Math.abs(va-vb)>1e-9) return false; }
    else if (typeof va==='undefined' && typeof vb==='undefined'){ continue; }
    else { return false; }
  }
  return true;
}

/* ===== СЕТЬ: основной backend (GET-первым) ===== */
async function callBackend(action, extra = {}) {
  const base = { action, init_data: safeInitData(), app_version: APP_VERSION, locale: navigator.language || 'ru-RU', ...extra };

  // 1) GET — без отдельного init_data в query
  const qs = new URLSearchParams();
  qs.set('action', action);
  qs.set('json', JSON.stringify(base));
  qs.set('_t', String(Date.now()));
  try{
    const r = await fetch(BACKEND_URL + '?' + qs.toString(), { cache:'no-cache' });
    const tx = await r.text();
    try{ return JSON.parse(tx); }catch{ return { ok:false, error:'bad_json', _raw: tx.slice(0,200) }; }
  }catch(_){}

  // 2) POST fallback (если у тебя есть doPost)
  try{
    const rp = await fetch(BACKEND_URL, {
      method:'POST',
      headers:{'Content-Type':'text/plain;charset=UTF-8'},
      body: JSON.stringify(base),
      keepalive:true, redirect:'follow', credentials:'omit', referrerPolicy:'no-referrer'
    });
    const tp = await rp.text();
    try{ return JSON.parse(tp); }catch{ return { ok:false, error:'bad_json', _raw: tp.slice(0,200) }; }
  }catch(e){
    return { ok:false, error: e?.message || 'network_error' };
  }
}

/* ====== Комментарий ИИ (read-only API) ====== */
function setAILoading(isLoading){
  const cont = document.getElementById('ai-comment');
  if (!cont) return;
  cont.innerHTML = '';
  const field = document.createElement('div');
  field.className = 'field';
  const div = document.createElement('div');
  div.className = 'help';
  div.textContent = isLoading ? 'Идёт анализ данных…' : 'Нет данных для комментария.';
  field.appendChild(div);
  cont.appendChild(field);
}
function renderAIComment(text){
  const cont = document.getElementById('ai-comment');
  if (!cont) return;
  const s = (typeof text === 'string') ? text.trim() : '';
  if (!s){ setAILoading(false); return; }
  cont.innerHTML = '';
  const field = document.createElement('div');
  field.className = 'field';
  const box = document.createElement('div');
  box.setAttribute('aria-live','polite');
  box.innerHTML = sanitizeHtml(s);
  field.appendChild(box);
  cont.appendChild(field);
}
function readAIFromLocal(){ try{ return (JSON.parse(localStorage.getItem(LS_KEY_AI))||{}).text || ''; }catch(_){ return ''; } }
function writeAIToLocal(text){ try{ localStorage.setItem(LS_KEY_AI, JSON.stringify({ ts: Date.now(), text: String(text||'') })); }catch(_){ } }
function rehydrateAIFromLocal(){ const t = readAIFromLocal(); if (t) renderAIComment(t); }

async function fetchAIComment({ silent=false } = {}){
  if (!AI_API_URL){
    if (!silent && !readAIFromLocal()) setAILoading(false);
    return;
  }
  const parseAI = (raw) => {
    try {
      const j = JSON.parse(raw);
      const val = j.ai_comment ?? j.comment ?? j.html ?? j.ai ?? j.text ?? '';
      if (typeof val === 'string') return val;
      if (val && typeof val === 'object' && typeof val.html === 'string') return val.html;
      return '';
    } catch {
      return (typeof raw === 'string' && raw.length < 50000) ? raw : '';
    }
  };

  try{
    if (!silent) setAILoading(true);
    const base = { action: 'ai_comment', init_data: safeInitData(), tz: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC' };
    const prev = readAIFromLocal();

    // 1) GET-первая попытка — короче URL (без отдельного init_data)
    try{
      const qs = new URLSearchParams();
      qs.set('action','ai_comment');
      qs.set('json', JSON.stringify(base));
      qs.set('_t', String(Date.now()));
      const r = await fetch(AI_API_URL + '?' + qs.toString(), { cache:'no-cache' });
      const tx = await r.text();
      const next = parseAI(tx);
      if (next && next !== prev){ writeAIToLocal(next); renderAIComment(next); return; }
    }catch(_){}

    // 2) POST как запасной
    try{
      const rp = await fetch(AI_API_URL, {
        method:'POST',
        headers:{'Content-Type':'text/plain;charset=UTF-8'},
        body: JSON.stringify(base),
        keepalive:true, redirect:'follow', credentials:'omit', referrerPolicy:'no-referrer'
      });
      const tp = await rp.text();
      const next = parseAI(tp);
      if (next && next !== prev){ writeAIToLocal(next); renderAIComment(next); return; }
    }catch(_){}
  } finally {
    if (!readAIFromLocal()) setAILoading(false);
  }
}

/* короткий догон после «Сохранить» */
async function chaseAICommentShort(timeoutMs = 2200, stepMs = 350){
  const start = Date.now();
  const baseline = readAIFromLocal();
  while (Date.now() - start < timeoutMs){
    await fetchAIComment({ silent:true });
    if (readAIFromLocal() !== baseline) break;
    await new Promise(r => setTimeout(r, stepMs));
  }
}

/* ===== АККОРДЕОН ===== */
function setAriaExpanded(h){
  const sec = document.getElementById(h.getAttribute('data-toggle'));
  h.setAttribute('aria-expanded', String(!sec.classList.contains('collapsed')));
}
function toggleSectionByHeader(h){
  const id = h.getAttribute('data-toggle');
  const sec = document.getElementById(id);
  const willBeCollapsed = sec.classList.toggle('collapsed');
  h.setAttribute('aria-expanded', String(!willBeCollapsed));
  if (id === 'sec-measures' && !willBeCollapsed){
    if (typeof fieldsWrap !== 'undefined' && !fieldsWrap._observed){
      observeFields(); fieldsWrap._observed = true;
    }
  }
}
(function bindAccordion(){
  const root = document;
  root.addEventListener('click', (e)=>{
    const h = e.target.closest ? e.target.closest('.section-h') : null;
    if (!h) return;
    if (!h.hasAttribute('role')) h.setAttribute('role','button');
    if (!h.hasAttribute('tabindex')) h.setAttribute('tabindex','0');
    if (!h.hasAttribute('aria-controls')) h.setAttribute('aria-controls', h.getAttribute('data-toggle'));
    toggleSectionByHeader(h);
  }, {passive:true});
  root.addEventListener('keydown', (e)=>{
    const h = e.target && e.target.closest ? e.target.closest('.section-h') : null;
    if (!h) return;
    if (e.key==='Enter' || e.key===' '){ e.preventDefault(); toggleSectionByHeader(h); }
  });
  document.querySelectorAll('.section-h').forEach(setAriaExpanded);
})();

/* ===== КОЛЁСА ===== */
function buildWheel(fieldEl, initial){
  const min = +fieldEl.dataset.min;
  const max = +fieldEl.dataset.max;
  const minInt = Math.floor(min);
  const maxInt = Math.floor(max);
  const intRange = maxInt - minInt;

  const intCol = fieldEl.querySelector('.col-int');
  const fracCol = fieldEl.querySelector('.col-frac');
  const duo = fieldEl.querySelector('.duo');
  const key = fieldEl.dataset.key;

  const opt = t => { const d=document.createElement('div'); d.className='option'; d.textContent=t; return d; };
  function fillCol(col, from, to){
    const frag=document.createDocumentFragment();
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    for(let i=from;i<=to)i++?0:0; // keep linter happy
    for(let i=from;i<=to;i++) frag.appendChild(opt(i));
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    col.innerHTML=''; col.appendChild(frag);
  }
  fillCol(intCol, minInt, maxInt);
  fillCol(fracCol, 0, 9);

  const nearestIndex = col =>
    Math.round((col.scrollTop + (col.clientHeight-rowH)/2)/rowH) - pad;

  const lastActiveIdx = new WeakMap();
  function markActive(col){
    const idx = nearestIndex(col) + pad;
    const prev = lastActiveIdx.get(col);
    if (typeof prev === 'number' && col.children[prev]) col.children[prev].classList.remove('active');
    const el = col.children[idx];
    if (el) el.classList.add('active');
    lastActiveIdx.set(col, idx);
  }

  const setScrollInstant = (col, idx) => {
    const top = (idx + pad) * rowH - (col.clientHeight-rowH)/2;
    col.scrollTop = top;
  };

  function withNoSnap(fn){
    const prevInt = intCol.style.scrollSnapType;
    const prevFrac = fracCol.style.scrollSnapType;
    intCol.style.scrollSnapType = 'none';
    fracCol.style.scrollSnapType = 'none';
    try { fn(); }
    finally {
      requestAnimationFrame(()=>{
        intCol.style.scrollSnapType = prevInt || '';
        fracCol.style.scrollSnapType = prevFrac || '';
        markActive(intCol); markActive(fracCol);
      });
    }
  }

  let isProgrammatic = false;
  let rafInt = 0, rafFrac = 0;
  let snapTimer=null;
  const supportsScrollEnd = 'onscrollend' in window;
  let disabled = false;

  function applyFracLock(iVal){
    if (disabled) return;
    const lock = (iVal === maxInt);
    fracCol.style.pointerEvents = lock ? 'none' : 'auto';
    fracCol.style.opacity = lock ? 0.5 : 1;
  }

  function dispatchChange(){
    const v = api.value;
    document.dispatchEvent(new CustomEvent('wheelchange', {
      detail:{ key, value: v, programmatic: isProgrammatic }
    }));
  }

  function setValue(v){
    const clamped = clamp(+v, min, max);
    const rounded = Math.round(clamped * 10) / 10;
    const iVal = Math.trunc(rounded);
    let f = Math.round((rounded - iVal) * 10);
    if (iVal === maxInt) f = 0;
    const iIdx = iVal - minInt;

    const prev = isProgrammatic; isProgrammatic = true;
    withNoSnap(()=>{
      setScrollInstant(intCol, iIdx);
      setScrollInstant(fracCol, f);
    });
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = prev; dispatchChange(); });
  }

  function snapNow(){
    if (isProgrammatic) return;
    let iIdx = clamp(nearestIndex(intCol), 0, intRange);
    let f = clamp(nearestIndex(fracCol), 0, 9);
    const iVal = minInt + iIdx;
    if (iVal === maxInt) f = 0;

    const prev = isProgrammatic; isProgrammatic = true;
    setScrollInstant(intCol, iIdx);
    setScrollInstant(fracCol, f);
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = prev; dispatchChange(); });
  }

  function onScrollInt(){
    if (isProgrammatic) return;
    if (rafInt) cancelAnimationFrame(rafInt);
    rafInt = requestAnimationFrame(()=>markActive(intCol));
    scheduleSnap();
  }
  function onScrollFrac(){
    if (isProgrammatic) return;
    if (rafFrac) cancelAnimationFrame(rafFrac);
    rafFrac = requestAnimationFrame(()=>markActive(fracCol));
    scheduleSnap();
  }
  function scheduleSnap(){
    if (supportsScrollEnd) return;
    clearTimeout(snapTimer);
    snapTimer = setTimeout(snapNow, 80);
  }

  intCol.addEventListener('scroll', onScrollInt, {passive:true});
  fracCol.addEventListener('scroll', onScrollFrac, {passive:true});
  if (supportsScrollEnd){
    intCol.addEventListener('scrollend', snapNow, {passive:true});
    fracCol.addEventListener('scrollend', snapNow, {passive:true});
  }

  function setDisabled(dis, programmatic=false){
    const prev = isProgrammatic; if (programmatic) isProgrammatic = true;
    disabled = dis;
    duo.classList.toggle('disabled', dis);
    duo.setAttribute('aria-disabled', String(dis));
    [intCol, fracCol].forEach(c=>c.style.pointerEvents = dis ? 'none':'auto');
    if (!dis){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      const iVal = minInt + iIdx;
      applyFracLock(iVal);
    }
    dispatchChange();
    isProgrammatic = prev;
  }

  const initVal = (typeof initial==='number') ? initial : (min + (max - min) / 2);
  requestAnimationFrame(()=>requestAnimationFrame(()=>setValue(initVal)));

  const api = {
    setValue,
    get value(){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      let f = clamp(nearestIndex(fracCol), 0, 9);
      const iVal = minInt + iIdx;
      if (iVal === maxInt) f = 0;
      return +(iVal + f/10).toFixed(1);
    },
    setDisabled,
    destroy(){
      clearTimeout(snapTimer);
      intCol.removeEventListener('scroll', onScrollInt);
      fracCol.removeEventListener('scroll', onScrollFrac);
      if (supportsScrollEnd){
        intCol.removeEventListener('scrollend', snapNow);
        fracCol.removeEventListener('scrollend', snapNow);
      }
    }
  };
  return api;
}

/* ===== КОНФИГ ПОЛЕЙ ===== */
const FIELDS = [
  { key:'weight', label:'Вес', unit:'кг', min:40, max:250, initial:70.0 },
  { key:'height', label:'Рост', unit:'см', min:120, max:230, initial:160.0 },
  { key:'fat',    label:'% жира', unit:'%',  min:3,  max:60,  initial:20.0, optional:true },
  { key:'neck',   label:'Шея', unit:'см', min:20, max:70, initial:38 },
  { key:'shoulders',label:'Плечи обхват', unit:'см', min:60, max:180, initial:90.0 },
  { key:'chest',  label:'Грудь', unit:'см', min:60, max:160, initial:100 },
  { key:'waist',  label:'Талия', unit:'см', min:40, max:160, initial:70 },
  { key:'bicep_l_rel', label:'Бицепс левый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_rel', label:'Бицепс правый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_l_flex',label:'Бицепс левый (напряж.)',  unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_flex',label:'Бицепс правый (напряж.)',  unit:'см', min:15, max:70, initial:31 },
  { key:'thigh_l', label:'Бедро левое', unit:'см', min:30, max:100, initial:50 },
  { key:'thigh_r', label:'Бедро правое', unit:'см', min:30, max:100, initial:50 },
  { key:'calf_l',  label:'Икра левая', unit:'см', min:25, max:70, initial:35 },
  { key:'calf_r',  label:'Икра правая', unit:'см', min:25, max:70, initial:35 },
  { key:'hips',    label:'Ягодицы', unit:'см', min:70, max:160, initial:90 },
  { key:'wrist',   label:'Обхват запястья', unit:'см', min:10, max:30, initial:17 },
  { key:'knee',    label:'Обхват колена',   unit:'см', min:25, max:60, initial:36 },
  { key:'ankle',   label:'Обхват лодыжки',  unit:'см', min:15, max:35, initial:22 },
];
const CFG = Object.fromEntries(FIELDS.map(f=>[f.key, f]));

/* ===== ИСХОДНОЕ СОСТОЯНИЕ ===== */
let last = readJSON(LS_KEY_LAST) || null;
let sessionDraft = readSessionJSON(SS_KEY_DRAFT);
if (sessionDraft && last?.ts && sessionDraft.ts && last.ts >= sessionDraft.ts){ sessionDraft=null; removeSessionKey(SS_KEY_DRAFT); }
if (sessionDraft && (!sessionDraft.dirty) && last?.data && equalData(sessionDraft.data||{}, last.data||{})){ sessionDraft=null; removeSessionKey(SS_KEY_DRAFT); }

/* ===== UI ===== */
const fieldsWrap = document.getElementById('fields');
const wheels = {};
const nullChecks = {};

function fieldEl(f){
  const el = document.createElement('div');
  el.className = 'field';
  el.dataset.key = f.key;
  el.dataset.min = String(f.min);
  el.dataset.max = String(f.max);
  el.innerHTML = `
    <div class="row">
      <div class="label">${f.label}</div>
      <div class="unit">${f.unit}</div>
    </div>
    <div class="duo" aria-label="${f.label}">
      <div class="col col-int" aria-hidden="true"></div>
      <div class="sep">.</div>
      <div class="col col-frac" aria-hidden="true"></div>
    </div>
    ${f.optional ? `
    <div class="optline">
      <input type="checkbox" id="cb_${f.key}" />
      <label for="cb_${f.key}">нет данных</label>
    </div>` : ``}
  `;
  return el;
}
function buildAllFields(){
  const frag = document.createDocumentFragment();
  for (const f of FIELDS){
    const el = fieldEl(f);
    frag.appendChild(el);
  }
  fieldsWrap.innerHTML = '';
  fieldsWrap.appendChild(frag);

  for (const f of FIELDS){
    const el = fieldsWrap.querySelector(`[data-key="${f.key}"]`);
    const initVal = sessionDraft?.data?.[f.key] ?? last?.data?.[f.key] ?? f.initial;
    wheels[f.key] = buildWheel(el, (initVal==null? f.initial : initVal));
    if (f.optional){
      const cb = el.querySelector(`#cb_${f.key}`);
      nullChecks[f.key] = cb;
      const isNull = (sessionDraft?.data?.[f.key] === null) || (last?.data?.[f.key] === null);
      cb.checked = !!isNull;
      wheels[f.key].setDisabled(!!isNull, /*programmatic*/true);
      cb.addEventListener('change', ()=>{
        wheels[f.key].setDisabled(cb.checked, /*programmatic*/true);
        markDirtyAndDraft(); recomputeSaveDisabled();
      }, {passive:true});
    }
  }
}
function observeFields(){}

/* ===== СБОР/ПРИМЕНЕНИЕ ===== */
function collectCurrentData(){
  const out = {};
  for (const f of FIELDS){
    const cb = nullChecks[f.key];
    out[f.key] = (cb && cb.checked) ? null : wheels[f.key].value;
  }
  return out;
}
function applyDataToUI(data){
  for (const f of FIELDS){
    const v = data?.[f.key];
    const cb = nullChecks[f.key];
    if (v === null){
      if (cb){ cb.checked = true; }
      wheels[f.key].setDisabled(true, /*programmatic*/true);
    }else if (typeof v === 'number'){
      if (cb){ cb.checked = false; }
      wheels[f.key].setDisabled(false, /*programmatic*/true);
      wheels[f.key].setValue(v);
    }
  }
}

/* ===== SAVE UI ===== */
const saveBtn = document.getElementById('saveBtn');
const saveSpinner = saveBtn.querySelector('.spinner');
const saveLabel = saveBtn.querySelector('.btn-label');
let isSaving = false;

function setSaveBusy(b){
  isSaving = b;
  saveBtn.classList.toggle('loading', b);
  saveBtn.setAttribute('aria-busy', String(b));
  saveSpinner.hidden = !b;
  saveLabel.textContent = b ? 'Сохраняю…' : 'Сохранить';
  recomputeSaveDisabled();
}
function recomputeSaveDisabled(){
  const curr = collectCurrentData();
  const same = last?.data ? equalData(curr, last.data) : false;
  const disabled = isSaving || same;
  saveBtn.disabled = disabled;
  saveBtn.style.opacity = disabled ? .6 : 1;
}

function markDirtyAndDraft(){
  const d = collectCurrentData();
  writeSessionJSON(SS_KEY_DRAFT, { ts: Date.now(), data:d, dirty:true });
}
const writeDraftDebounced = debounce(()=>markDirtyAndDraft(), 120);

document.addEventListener('wheelchange', (e)=>{
  if (e?.detail?.programmatic) return;
  writeDraftDebounced();
  recomputeSaveDisabled();
}, {passive:true});

/* ===== Подписи ===== */
const lastTimeEl = document.getElementById('lastTime');
function updateLastMeta(){
  const ts = last?.ts || null;
  lastTimeEl.textContent = 'Последний замер: ' + fmt(ts);
}

/* ===== ИНИЦ ===== */
function initUI(){
  buildAllFields();
  if (sessionDraft?.data)      applyDataToUI(sessionDraft.data);
  else if (last?.data)         applyDataToUI(last.data);
  updateLastMeta();
  recomputeSaveDisabled();
}

/* ===== INIT с бэка ===== */
async function fetchAndApplyFromBackend(){
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
  const res = await callBackend('init', { tz });
  if (res?.ok && res.last){
    const ls = {
      ts: res.last.ts_iso ? Date.parse(res.last.ts_iso) : Date.now(),
      day_local: res.last.day_local || '',
      data: res.last.data || {}
    };
    writeJSON(LS_KEY_LAST, ls);
    last = ls;
  }
  initUI();
}

/* ===== Сохранение ===== */
let saveInFlight = null;
let lastSaveTs = 0;

async function saveWithGuards(){
  const now = Date.now();
  if (now - lastSaveTs < SAVE_THROTTLE_MS) return saveInFlight || Promise.resolve();
  lastSaveTs = now;
  if (saveInFlight) return saveInFlight;

  const data = collectCurrentData();
  const sig  = hash32(stableStringify(data));
  const meta = getLastMeta();
  if (meta && meta.sig === sig) return Promise.resolve({ok:true, skipped:true});

  const iid = (crypto?.randomUUID?.() || Math.random().toString(36).slice(2)) + '-' + now;

  setSaveBusy(true);
  saveInFlight = (async ()=>{
    try{
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
      const payload = { tz, source:'webapp', app_version: APP_VERSION, t_client: now, data, iid };
      const res = await callBackend('save', payload);
      if (res?.ok){
        const ls = { ts: res.ts_iso ? Date.parse(res.ts_iso) : Date.now(), day_local: res.day_local || '', data };
        writeJSON(LS_KEY_LAST, ls);
        removeSessionKey(SS_KEY_DRAFT);
        last = ls;
        setLastMeta({ ts: Date.now(), sig, iid, serverTs: Date.now() });
        rememberIID(iid);
        updateLastMeta();
        recomputeSaveDisabled();
        chaseAICommentShort();
      } else {
        console.warn('[save] backend error:', res);
      }
      return res;
    } catch(err){
      console.error('[save] error:', err);
      return { ok:false, error: String(err?.message||err) };
    } finally {
      setSaveBusy(false);
      saveInFlight = null;
    }
  })();
  return saveInFlight;
}

/* ===== Привязка кнопки ===== */
(function wireSaveOnce(){
  if (!saveBtn || saveBtn.__wired) return;
  saveBtn.__wired = true;
  function pressFX(on){ saveBtn.classList.toggle('pressed', !!on); }
  saveBtn.addEventListener('pointerdown', ()=>pressFX(true));
  saveBtn.addEventListener('pointerup',   ()=>pressFX(false));
  saveBtn.addEventListener('pointercancel',()=>pressFX(false));
  saveBtn.addEventListener('click', (e)=>{ e.preventDefault(); saveWithGuards(); });
  const form = document.querySelector('form[data-measure]');
  if (form && !form.__wired){
    form.__wired = true;
    form.addEventListener('submit', (e)=>{ e.preventDefault(); saveWithGuards(); });
  }
})();

/* ===== LOCAL-FIRST старт ===== */
function bootLocalFirst(){
  initUI();
  const meta = getLastMeta();
  const WEEK = 7*24*60*60*1000;
  const needsSync = !meta || (Date.now() - meta.ts > WEEK);
  if (needsSync){
    callBackend('init', { tz: Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC' })
      .then((res)=>{
        if (!res?.ok || !res.last) return;
        const serverLast = {
          ts: res.last.ts_iso ? Date.parse(res.last.ts_iso) : Date.now(),
          day_local: res.last.day_local || '',
          data: res.last.data || {}
        };
        const sig = hash32(stableStringify(serverLast.data));
        writeJSON(LS_KEY_LAST, serverLast);
        setLastMeta({ ts: Date.now(), sig, iid: meta?.iid, serverTs: Date.now() });
        last = serverLast;
        applyDataToUI(serverLast.data);
        updateLastMeta();
        recomputeSaveDisabled();
      })
      .catch(()=>{ /* игнорим */ });
  }
}

/* ===== СТАРТ ===== */
(function main(){
  bootLocalFirst();
  rehydrateAIFromLocal();
  fetchAIComment().catch(console.error);
  startAIPoll();
  document.addEventListener('visibilitychange', () => { if (document.hidden) stopAIPoll(); else startAIPoll(); }, {passive:true});
  window.addEventListener('pageshow', ()=>recomputeSaveDisabled(), {once:true});
})();
</script>
</body>
</html>
