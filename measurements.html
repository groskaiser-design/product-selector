<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Замеры — анкета (двойные колёса)</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<style>
  :root{
    --bg: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    --cardA: rgba(255,255,255,.18);
    --cardB: rgba(255,255,255,.16);
    --border: rgba(255,255,255,.28);
    --shadow: 0 8px 28px rgba(0,0,0,.18);
    --okA:#34d399; --okB:#10b981;
    --row: 36px;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%}

  html{background:transparent;}
  body{
    min-height:100svh;
    background:transparent;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
    color:#fff;
    position:relative;
    isolation:isolate;
  }
  body::before{
    content:"";
    position:fixed; inset:0;
    background:var(--bg);
    z-index:0;
    pointer-events:none;
    transform:translateZ(0);
  }

  .page{max-width:560px;margin:0 auto;padding:18px 14px 24px;position:relative;z-index:1}

  .section{
    background:linear-gradient(180deg,var(--cardA),var(--cardB));
    border:1px solid var(--border); border-radius:18px;
    box-shadow:var(--shadow);
    backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
    overflow:hidden; margin-bottom:14px;
  }
  .section-h{display:flex;align-items:center;gap:10px;padding:14px 16px;cursor:pointer;user-select:none}
  .section-h h2{font-size:16px;font-weight:800;flex:1}
  .meta{font-size:11px;opacity:.9}
  .toggle{width:22px;height:22px;border-radius:50%;display:flex;align-items:center;justify-content:center;opacity:.9}
  .toggle svg{transition:transform .18s ease}
  .section.collapsed .toggle svg{transform:rotate(-90deg)}
  .section-content{padding:0 0 0}
  .section.collapsed .section-content{display:none}

  .field{padding:12px}
  .field + .field{border-top:1px solid rgba(255,255,255,.14)}
  .row{display:flex;align-items:center;justify-content:space-between}
  .label{font-size:13px;font-weight:800}
  .unit{font-size:12px;opacity:.9}
  .help{margin-top:6px;text-align:center;font-size:12px;opacity:.8}

  /* ===== duo-wheel ===== */
  .duo{
    position:relative; display:flex; gap:6px; padding:12px;
    border-radius:14px; background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.24);
    max-width:320px; margin:8px auto 0; justify-content:center;
  }
  .duo::after{
    content:""; position:absolute; left:4px; right:4px; top:50%;
    height:var(--row); transform:translateY(-50%);
    background:rgba(255,255,255,.14); border:1px solid rgba(255,255,255,.35);
    border-radius:10px; pointer-events:none;
  }
  .col{
    flex:0 0 92px; height:180px; overflow:auto; -webkit-overflow-scrolling:touch;
    overscroll-behavior: contain; scrollbar-width:none; scroll-snap-type:y mandatory;
    mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);
    -webkit-mask-image: linear-gradient(180deg, transparent, #000 18%, #000 82%, transparent);
  }
  .col::-webkit-scrollbar{display:none}
  .option{
    height:var(--row); display:flex; align-items:center; justify-content:center;
    font-weight:900; font-size:18px; color:#eef2ff; opacity:.55; scroll-snap-align:center;
  }
  .option.active{ color:#fff; opacity:1; text-shadow:0 1px 0 rgba(0,0,0,.2); }
  .sep{display:flex;align-items:center;justify-content:center;width:10px;color:#e5e7eb;font-weight:800}
  .optline{display:flex;align-items:center;justify-content:center;gap:8px;margin-top:8px}
  .optline input{width:18px;height:18px}

  /* Кнопка сохранения */
  .savebar{
    display:flex;justify-content:center;padding:12px;
    border-top:1px solid rgba(255,255,255,.14);
    padding-bottom: calc(12px + env(safe-area-inset-bottom));
  }
  .btn{
    min-width:160px;padding:12px 16px;border:0;border-radius:14px;
    background:#ED2F62; color:#fff;font-weight:900;
    box-shadow:0 12px 26px rgba(237,47,98,.35), inset 0 1px 0 rgba(255,255,255,.4);
    transition: transform .08s ease, box-shadow .12s ease, filter .12s ease;
    -webkit-tap-highlight-color:transparent;
    touch-action: manipulation; /* ускоряет на мобилах */
  }
  .btn:active{
    transform:translateY(1px) scale(.98);
    box-shadow:0 6px 16px rgba(237,47,98,.35), inset 0 1px 0 rgba(255,255,255,.4);
    filter:saturate(.95);
  }
  .btn:focus-visible{outline:2px solid rgba(255,255,255,.7); outline-offset:2px; border-radius:16px}

  @media (prefers-reduced-motion: reduce){
    .btn{ transition:none; }
    .btn:active{ transform:none; filter:none; }
  }

  /* Только колесо делаем неактивным */
  .disabled{opacity:.4;filter:saturate(.6)}
</style>
</head>
<body>
  <div class="page">

    <!-- Блок 1: Замеры (по умолчанию свернут) -->
    <section class="section collapsed" id="sec-measures">
      <div class="section-h" data-toggle="sec-measures" role="button" tabindex="0" aria-controls="sec-measures" aria-expanded="false">
        <h2>Замеры</h2>
        <div class="meta" id="lastTime">Последний замер: нет данных</div>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content">
        <div id="fields"></div>
        <div class="savebar"><button class="btn" id="saveBtn">Сохранить</button></div>
      </div>
    </section>

    <!-- Блок 2: Аналитика (развернут) -->
    <section class="section" id="sec-analytics">
      <div class="section-h" data-toggle="sec-analytics" role="button" tabindex="0" aria-controls="sec-analytics" aria-expanded="true">
        <h2>Аналитика</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content" id="analytics">
        <div class="field">
          <div class="help">Здесь появится динамика по ключевым метрикам после сохранения хотя бы двух замеров.</div>
        </div>
      </div>
    </section>

    <!-- Блок 3: Комментарий ИИ (развернут) -->
    <section class="section" id="sec-ai">
      <div class="section-h" data-toggle="sec-ai" role="button" tabindex="0" aria-controls="sec-ai" aria-expanded="true">
        <h2>Комментарий ИИ</h2>
        <div class="toggle" aria-hidden="true">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none">
            <path d="M8 10l4 4 4-4" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </div>
      </div>
      <div class="section-content" id="ai-comment">
        <div class="field">
          <div class="help">Здесь будет краткий разбор изменений и мягкие рекомендации на основе последних замеров.</div>
        </div>
      </div>
    </section>

  </div>

<script>
/* ===== КОНСТАНТЫ ХРАНИЛИЩА ===== */
const LS_KEY_LAST  = 'measurements:last';   // { ts, data }
const LS_KEY_DRAFT = 'measurements:draft';  // { ts, data }

/* ===== СЕТЬ / БЭКЕНД ===== */
const BACKEND_URL = 'https://script.google.com/macros/s/AKfycbwxf0taY1yMZ5ALfPTmPw9Y_P2t522K2BUT3xnLsiHs1J7MHaCF5pC6O1Qdj4iNEsD67Q/exec'; // <-- вы подставите
const APP_VERSION = '1.0.0';

// CHANGED: отправляем как text/plain, чтобы избежать CORS preflight в iOS WebView/Telegram
async function postJSON(payload){
  const resp = await fetch(BACKEND_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'text/plain;charset=UTF-8' },
    body: JSON.stringify(payload),
    mode: 'cors',
    redirect: 'follow',
    credentials: 'omit',
    referrerPolicy: 'no-referrer',
    keepalive: true
  });
  const text = await resp.text();
  try { return JSON.parse(text); }
  catch { return { ok:false, error:'bad_json', _raw:text.slice(0,200) }; }
}

/* ===== УТИЛИТЫ ===== */
const ROW_VAR = getComputedStyle(document.documentElement).getPropertyValue('--row').trim();
const rowH = ROW_VAR.endsWith('px') ? parseFloat(ROW_VAR) : (parseFloat(ROW_VAR) || 36);
const pad = 4;
const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));

/* Кэш форматтера даты */
const DTF = new Intl.DateTimeFormat('ru-RU', {
  day:'2-digit', month:'2-digit', year:'numeric', hour:'2-digit', minute:'2-digit'
});
const fmt = (ts)=>(!ts ? 'нет данных' : DTF.format(new Date(ts)));

function readJSON(key, fallback=null){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch(e){ return fallback; } }
function writeJSON(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(e){} }
function removeKey(key){ try{ localStorage.removeItem(key); }catch(e){} }
function safeInitData(){ return window.Telegram?.WebApp?.initData || ''; }

/* ===== АККОРДЕОН (a11y + клавиатура) ===== */
function setAriaExpanded(h){
  const sec = document.getElementById(h.getAttribute('data-toggle'));
  h.setAttribute('aria-expanded', String(!sec.classList.contains('collapsed')));
}
function toggleSectionByHeader(h){
  const id = h.getAttribute('data-toggle');
  const sec = document.getElementById(id);
  const willBeCollapsed = sec.classList.toggle('collapsed');
  h.setAttribute('aria-expanded', String(!willBeCollapsed));
  if (id === 'sec-measures' && !willBeCollapsed && !fieldsWrap._observed){
    observeFields();
    fieldsWrap._observed = true;
  }
}
document.querySelectorAll('.section-h').forEach(h=>{
  if (!h.hasAttribute('role')) h.setAttribute('role','button');
  if (!h.hasAttribute('tabindex')) h.setAttribute('tabindex','0');
  if (!h.hasAttribute('aria-controls')) h.setAttribute('aria-controls', h.getAttribute('data-toggle'));
  setAriaExpanded(h);

  h.addEventListener('click', ()=>toggleSectionByHeader(h));
  h.addEventListener('keydown', (e)=>{
    if (e.key==='Enter' || e.key===' ') { e.preventDefault(); toggleSectionByHeader(h); }
  });
});

/* ===== КОЛЁСА ===== */
function buildWheel(fieldEl, initial){
  const min = +fieldEl.dataset.min;
  const max = +fieldEl.dataset.max;
  const minInt = Math.floor(min);
  const maxInt = Math.floor(max);
  const intRange = maxInt - minInt;

  const intCol = fieldEl.querySelector('.col-int');
  const fracCol = fieldEl.querySelector('.col-frac');
  const duo = fieldEl.querySelector('.duo');
  const key = fieldEl.dataset.key;

  const opt = t => { const d=document.createElement('div'); d.className='option'; d.textContent=t; return d; };
  function fillCol(col, from, to){
    const frag=document.createDocumentFragment();
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    for(let i=from;i<=to;i++) frag.appendChild(opt(i));
    for(let i=0;i<pad;i++) frag.appendChild(opt(''));
    col.innerHTML=''; col.appendChild(frag);
  }
  fillCol(intCol, minInt, maxInt);
  fillCol(fracCol, 0, 9);

  const nearestIndex = col =>
    Math.round((col.scrollTop + (col.clientHeight-rowH)/2)/rowH) - pad;

  /* Оптимизированный markActive: меняем класс только у двух элементов */
  const lastActiveIdx = new WeakMap(); // col -> idx
  function markActive(col){
    const idx = nearestIndex(col) + pad;
    const prev = lastActiveIdx.get(col);
    if (prev === idx) return;
    if (typeof prev === 'number' && col.children[prev]) col.children[prev].classList.remove('active');
    const el = col.children[idx];
    if (el) el.classList.add('active');
    lastActiveIdx.set(col, idx);
  }

  const setScrollInstant = (col, idx) => {
    const top = (idx + pad) * rowH - (col.clientHeight-rowH)/2;
    col.scrollTop = top;
  };

  let isProgrammatic = false;
  let rafInt = 0, rafFrac = 0;
  let snapTimer=null;
  const supportsScrollEnd = 'onscrollend' in window;
  let disabled = false; // локальное состояние disable

  function applyFracLock(iVal){
    if (disabled) return;
    const lock = (iVal === maxInt);
    fracCol.style.pointerEvents = lock ? 'none' : 'auto';
    fracCol.style.opacity = lock ? 0.5 : 1;
  }

  function dispatchChange(){
    const v = api.value;
    document.dispatchEvent(new CustomEvent('wheelchange', { detail:{ key, value: v }}));
  }

  function setValue(v){
    const clamped = clamp(+v, min, max);
    const rounded = Math.round(clamped * 10) / 10;
    const iVal = Math.trunc(rounded);
    let f = Math.round((rounded - iVal) * 10);
    if (iVal === maxInt) f = 0;
    const iIdx = iVal - minInt;

    isProgrammatic = true;
    setScrollInstant(intCol, iIdx);
    setScrollInstant(fracCol, f);
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = false; dispatchChange(); });
  }

  function snapNow(){
    if (isProgrammatic) return;
    let iIdx = clamp(nearestIndex(intCol), 0, intRange);
    let f = clamp(nearestIndex(fracCol), 0, 9);
    const iVal = minInt + iIdx;
    if (iVal === maxInt) f = 0;

    isProgrammatic = true;
    setScrollInstant(intCol, iIdx);
    setScrollInstant(fracCol, f);
    applyFracLock(iVal);
    markActive(intCol); markActive(fracCol);
    requestAnimationFrame(()=>{ isProgrammatic = false; dispatchChange(); });
  }

  function onScrollInt(){
    if (isProgrammatic) return;
    if (rafInt) cancelAnimationFrame(rafInt);
    rafInt = requestAnimationFrame(()=>markActive(intCol));
    scheduleSnap();
  }
  function onScrollFrac(){
    if (isProgrammatic) return;
    if (rafFrac) cancelAnimationFrame(rafFrac);
    rafFrac = requestAnimationFrame(()=>markActive(fracCol));
    scheduleSnap();
  }
  function scheduleSnap(){
    if (supportsScrollEnd) return;
    clearTimeout(snapTimer);
    snapTimer = setTimeout(snapNow, 80);
  }

  intCol.addEventListener('scroll', onScrollInt, {passive:true});
  fracCol.addEventListener('scroll', onScrollFrac, {passive:true});
  if (supportsScrollEnd){
    intCol.addEventListener('scrollend', snapNow, {passive:true});
    fracCol.addEventListener('scrollend', snapNow, {passive:true});
  }

  function setDisabled(dis){
    disabled = dis;
    duo.classList.toggle('disabled', dis);
    duo.setAttribute('aria-disabled', String(dis));
    [intCol, fracCol].forEach(c=>c.style.pointerEvents = dis ? 'none':'auto');
    if (!dis){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      const iVal = minInt + iIdx;
      applyFracLock(iVal);
    }
    dispatchChange();
  }

  const initVal = (typeof initial==='number') ? initial : (min + (max - min) / 2);
  requestAnimationFrame(()=>requestAnimationFrame(()=>setValue(initVal)));

  const api = {
    setValue,
    get value(){
      const iIdx = clamp(nearestIndex(intCol), 0, intRange);
      let f = clamp(nearestIndex(fracCol), 0, 9);
      const iVal = minInt + iIdx;
      if (iVal === maxInt) f = 0;
      return +(iVal + f/10).toFixed(1);
    },
    setDisabled,
    destroy(){
      clearTimeout(snapTimer);
      intCol.removeEventListener('scroll', onScrollInt);
      fracCol.removeEventListener('scroll', onScrollFrac);
      if (supportsScrollEnd){
        intCol.removeEventListener('scrollend', snapNow);
        fracCol.removeEventListener('scrollend', snapNow);
      }
    }
  };
  return api;
}

/* ===== КОНФИГ ПОЛЕЙ ===== */
const FIELDS = [
  { key:'weight', label:'Вес', unit:'кг', min:40, max:250, initial:70.0 },
  { key:'height', label:'Рост', unit:'см', min:120, max:230, initial:160.0 },
  { key:'fat',    label:'% жира', unit:'%',  min:3,  max:60,  initial:20.0, optional:true },

  { key:'neck',   label:'Шея', unit:'см', min:20, max:70, initial:38 },
  { key:'shoulders',label:'Плечи обхват', unit:'см', min:60, max:180, initial:90.0 },
  { key:'chest',  label:'Грудь', unit:'см', min:60, max:160, initial:100 },
  { key:'waist',  label:'Талия', unit:'см', min:40, max:160, initial:70 },

  { key:'bicep_l_rel', label:'Бицепс левый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_rel', label:'Бицепс правый (расслаб.)', unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_l_flex',label:'Бицепс левый (напряж.)',  unit:'см', min:15, max:70, initial:31 },
  { key:'bicep_r_flex',label:'Бицепс правый (напряж.)',  unit:'см', min:15, max:70, initial:31 },

  { key:'thigh_l', label:'Бедро левое', unit:'см', min:30, max:100, initial:50 },
  { key:'thigh_r', label:'Бедро правое', unit:'см', min:30, max:100, initial:50 },

  { key:'calf_l',  label:'Икра левая', unit:'см', min:25, max:70, initial:35 },
  { key:'calf_r',  label:'Икра правая', unit:'см', min:25, max:70, initial:35 },

  { key:'hips',    label:'Ягодицы', unit:'см', min:70, max:160, initial:90 },
  { key:'wrist',   label:'Обхват запястья', unit:'см', min:10, max:30, initial:17 },
  { key:'knee',    label:'Обхват колена',   unit:'см', min:25, max:60, initial:36 },
  { key:'ankle',   label:'Обхват лодыжки',  unit:'см', min:15, max:35, initial:22 },
];

/* Быстрый доступ к конфигу по ключу */
const CFG = Object.fromEntries(FIELDS.map(f=>[f.key, f]));

/* ===== ЗАГРУЗКА ДАННЫХ (последние/черновик) ===== */
const last = readJSON(LS_KEY_LAST);
const draft = readJSON(LS_KEY_DRAFT);
document.getElementById('lastTime').textContent = 'Последний замер: ' + fmt(last?.ts);

// базовая матрица значений на старте: черновик (если свежее) → последние → дефолт
const baseData = {};
for (const cfg of FIELDS){
  const fromDraft = (draft && (!last || (draft.ts >= last.ts))) ? draft.data?.[cfg.key] : undefined;
  const fromLast  = last?.data?.[cfg.key];
  baseData[cfg.key] = (typeof fromDraft === 'number' || fromDraft===null) ? fromDraft
                     : (typeof fromLast  === 'number' || fromLast===null)  ? fromLast
                     : undefined;
}

/* ===== РЕНДЕР ПОЛЕЙ (ленивая инициализация) ===== */
const fieldsWrap = document.getElementById('fields');
const wheels = {};
const wheelMap = new WeakMap();
/* Кэш DOM-элементов полей */
const fieldByKey = Object.create(null);

function ensureWheel(fieldEl, cfg){
  let w = wheelMap.get(fieldEl);
  if (!w){
    const initVal = (typeof baseData[cfg.key]==='number') ? baseData[cfg.key] : cfg.initial;
    w = buildWheel(fieldEl, initVal);
    wheelMap.set(fieldEl, w);
    wheels[cfg.key] = w;

    if (cfg.optional){
      const cb = fieldEl.querySelector('#opt_'+cfg.key);
      const isNull = baseData[cfg.key] === null;
      if (cb){ cb.checked = !!isNull; }
      if (isNull){ w.setDisabled(true); }
      if (cb && !cb._bound){
        cb.addEventListener('change', ()=>{ w.setDisabled(cb.checked); scheduleDraftSave(); });
        cb._bound = true;
      }
    }
  }
  return w;
}

for (const cfg of FIELDS){
  const f = document.createElement('div');
  f.className = 'field';
  f.dataset.key = cfg.key;
  f.dataset.min = cfg.min;
  f.dataset.max = cfg.max;

  f.innerHTML = `
    <div class="row">
      <div class="label">${cfg.label}</div>
      <div class="unit">${cfg.unit}</div>
    </div>
    <div class="duo">
      <div class="col col-int"></div>
      <div class="sep">,</div>
      <div class="col col-frac"></div>
    </div>
  `;

  if (cfg.optional){
    const opt = document.createElement('div');
    opt.className = 'optline';
    opt.innerHTML = `<label style="display:flex;align-items:center;gap:8px;opacity:.95">
        <input type="checkbox" id="opt_${cfg.key}"> нет данных
      </label>`;
    f.appendChild(opt);
  }

  const h = document.createElement('div');
  h.className = 'help';
  h.textContent = cfg.unit==='кг' ? 'кг целых и десятых килограмма' :
                  cfg.unit==='см' ? 'сантиметры и миллиметры' : 'проценты целых и десятых процента';
  f.appendChild(h);

  fieldsWrap.appendChild(f);
  fieldByKey[cfg.key] = f; // кеш ссылки на DOM-элемент поля
}

/* Lazy init */
const allFields = Array.from(fieldsWrap.querySelectorAll('.field'));
const canObserve = 'IntersectionObserver' in window;
function observeFields(){
  if (!canObserve){
    for (const f of allFields){
      const key = f.dataset.key;
      ensureWheel(f, CFG[key]);
    }
    return;
  }
  const io = new IntersectionObserver((entries)=>{
    for (const e of entries){
      if (e.isIntersecting){
        const f = e.target;
        ensureWheel(f, CFG[f.dataset.key]);
        io.unobserve(f);
      }
    }
  }, {root:null, rootMargin:'100px 0px', threshold:0});

  for (const f of allFields){
    const rect = f.getBoundingClientRect();
    if (rect.top < (window.innerHeight + 100) && rect.bottom > -100){
      ensureWheel(f, CFG[f.dataset.key]);
    } else {
      io.observe(f);
    }
  }
}

/* Если секция изначально развёрнута (у нас — свернута), всё равно проверим */
if (!document.getElementById('sec-measures').classList.contains('collapsed')){
  observeFields(); fieldsWrap._observed = true;
}

/* ===== ЧЕРНОВИК (автосохранение офлайн до нажатия "Сохранить") ===== */
let draftTimer=null;
function scheduleDraftSave(){
  clearTimeout(draftTimer);
  draftTimer = setTimeout(saveDraft, 300);
}
function collectCurrentData(withEnsure=false){
  const out = {};
  for (const cfg of FIELDS){
    const fieldEl = fieldByKey[cfg.key];
    const wheel = wheels[cfg.key] || (withEnsure ? ensureWheel(fieldEl, cfg) : null);
    const cb = fieldEl?.querySelector('#opt_'+cfg.key);
    if (cfg.optional && cb && cb.checked){
      out[cfg.key] = null;
    } else if (wheel){
      out[cfg.key] = wheel.value;
    } else {
      const v = baseData[cfg.key];
      out[cfg.key] = (typeof v==='number' || v===null) ? v : cfg.initial;
    }
  }
  return out;
}
function saveDraft(){
  const data = collectCurrentData(false);
  writeJSON(LS_KEY_DRAFT, { ts: Date.now(), data });
}
document.addEventListener('wheelchange', scheduleDraftSave);

/* Надёжный финальный сейв при уходе/сворачивании вкладки */
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'hidden') { try{ saveDraft(); }catch(e){} }
});
window.addEventListener('beforeunload', ()=>{ try{ saveDraft(); }catch(e){} });

/* ===== ИНИЦИАЛИЗАЦИЯ С БЭКЕНДА (мягкая) ===== */
(async function softInitFromBackend(){
  // если есть более свежий черновик — уважаем его и не трогаем
  if (draft && (!last || draft.ts >= last.ts)) return;
  // пробуем подтянуть последний замер из БД
  try{
    const res = await postJSON({ action:'init', init_data: safeInitData() });
    if (res && res.ok && res.last){
      // обновим бейдж и локальный last (включая дату — важно)
      const tsMs = Date.parse(res.last.ts_iso);
      document.getElementById('lastTime').textContent = 'Последний замер: ' + fmt(tsMs);
      writeJSON(LS_KEY_LAST, { ts: tsMs, data: res.last.data });
      // обновим базовые значения и уже инициализированные крутилки
      for (const k of Object.keys(res.last.data || {})){
        baseData[k] = res.last.data[k];
        if (wheels[k] && typeof res.last.data[k] === 'number') wheels[k].setValue(res.last.data[k]);
        if (wheels[k] && res.last.data[k] === null) wheels[k].setDisabled(true);
      }
    }
  }catch(e){ /* тихо, оффлайн режим ок */ }
})();

/* ===== СОХРАНЕНИЕ ===== */
document.getElementById('saveBtn').addEventListener('click', async ()=>{
  try{ window.Telegram?.WebApp?.HapticFeedback?.impactOccurred('light'); }catch(e){}

  const data = collectCurrentData(true);

  // служебные отметки клиента (дозаписываем дату замера локально и отправляем на сервер)
  const clientTs = Date.now();
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
  const dayLocal = new Intl.DateTimeFormat('sv-SE', { timeZone: tz, year:'numeric', month:'2-digit', day:'2-digit' })
                    .format(new Date(clientTs)); // YYYY-MM-DD

  const payload = {
    action: 'save',
    init_data: safeInitData(),
    app_version: APP_VERSION,
    locale: navigator.language || 'ru-RU',
    tz,
    save_id: (crypto?.randomUUID ? crypto.randomUUID() : String(clientTs)),
    client_ts: clientTs,                // <— дозапись даты/времени клиента
    client_day_local: dayLocal,         // <— дозапись локального дня клиента
    data
  };

  // сначала локально фиксируем черновик как last (на случай потери связи)
  writeJSON(LS_KEY_LAST, { ts: clientTs, data });
  removeKey(LS_KEY_DRAFT);
  document.getElementById('lastTime').textContent = 'Последний замер: ' + fmt(clientTs);
  Object.assign(baseData, data);

  // отправляем на сервер (тихо и надёжно)
  let serverTs = null;
  try{
    const res = await postJSON(payload);
    if (res && res.ok){
      serverTs = Date.parse(res.ts_iso);
      // перезапишем локальный last серверным временем (истина в БД)
      writeJSON(LS_KEY_LAST, { ts: serverTs, data });
      document.getElementById('lastTime').textContent = 'Последний замер: ' + fmt(serverTs);
      // сворачиваем блок «Замеры»
      const measuresSec = document.getElementById('sec-measures');
      const measuresHeader = document.querySelector('[data-toggle="sec-measures"]');
      if (measuresSec) measuresSec.classList.add('collapsed');
      if (measuresHeader) measuresHeader.setAttribute('aria-expanded','false');
      // мягкое подтверждение
      window.Telegram?.WebApp?.showPopup?.({title:'Сохранено', message:'Данные обновлены', buttons:[{type:'ok'}]});
    } else {
      // сервер ответил ошибкой — информируем, но локальный last уже есть
      alert('Ошибка сохранения: ' + (res?.error || 'unknown'));
    }
  }catch(err){
    // сеть/доступ — остаёмся на локальном last, пользователь сможет повторить попытку
    const msg = (err && err.message) ? String(err.message) : 'Неизвестная ошибка сети';
    (window.Telegram?.WebApp?.showAlert
      ? window.Telegram.WebApp.showAlert('Не удалось отправить на сервер.\nДанные сохранены локально.\nПричина: ' + msg)
      : alert('Не удалось отправить на сервер.\nДанные сохранены локально.\nПричина: ' + msg)
    );
  }
});
</script>
</body>
</html>
